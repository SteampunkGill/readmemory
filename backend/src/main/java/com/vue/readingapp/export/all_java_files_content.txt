--- 开始文件: BatchExport.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@RestController
@RequestMapping("/api/v1/export")
public class BatchExport {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到批量导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class BatchExportRequest {
        private List<String> types;
        private String format = "zip";
        private Map<String, Object> template;

        public List<String> getTypes() { return types; }
        public void setTypes(List<String> types) { this.types = types; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 支持的导出类型
    private static final Set<String> SUPPORTED_TYPES = new HashSet<>(Arrays.asList(
            "documents", "vocabulary", "reviews", "statistics", "notes", "highlights", "reading_history"
    ));

    @PostMapping("/batch")
    public ResponseEntity<?> batchExport(@RequestBody BatchExportRequest request,
                                         @RequestHeader(value = "Authorization", required = false) String authHeader) {
        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getTypes() == null || request.getTypes().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("types", "导出类型列表不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 验证每个类型是否支持
            List<String> invalidTypes = new ArrayList<>();
            for (String type : request.getTypes()) {
                if (!SUPPORTED_TYPES.contains(type.toLowerCase())) {
                    invalidTypes.add(type);
                }
            }

            if (!invalidTypes.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("invalid_types", invalidTypes);
                details.put("supported_types", SUPPORTED_TYPES);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "包含不支持的导出类型", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (!"zip".equalsIgnoreCase(request.getFormat())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "批量导出只支持ZIP格式");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 收集导出数据
            Map<String, byte[]> exportFiles = new HashMap<>();
            Map<String, String> fileDescriptions = new HashMap<>();

            for (String type : request.getTypes()) {
                switch (type.toLowerCase()) {
                    case "documents":
                        byte[] documentsData = exportDocumentsData(userId);
                        exportFiles.put("documents.json", documentsData);
                        fileDescriptions.put("documents.json", "文档数据");
                        break;

                    case "vocabulary":
                        byte[] vocabularyData = exportVocabularyData(userId);
                        exportFiles.put("vocabulary.json", vocabularyData);
                        fileDescriptions.put("vocabulary.json", "词汇数据");
                        break;

                    case "reviews":
                        byte[] reviewsData = exportReviewsData(userId);
                        exportFiles.put("reviews.json", reviewsData);
                        fileDescriptions.put("reviews.json", "复习记录");
                        break;

                    case "statistics":
                        byte[] statisticsData = exportStatisticsData(userId);
                        exportFiles.put("statistics.json", statisticsData);
                        fileDescriptions.put("statistics.json", "学习统计");
                        break;

                    case "notes":
                        byte[] notesData = exportNotesData(userId);
                        exportFiles.put("notes.json", notesData);
                        fileDescriptions.put("notes.json", "阅读笔记");
                        break;

                    case "highlights":
                        byte[] highlightsData = exportHighlightsData(userId);
                        exportFiles.put("highlights.json", highlightsData);
                        fileDescriptions.put("highlights.json", "文档高亮");
                        break;

                    case "reading_history":
                        byte[] readingHistoryData = exportReadingHistoryData(userId);
                        exportFiles.put("reading_history.json", readingHistoryData);
                        fileDescriptions.put("reading_history.json", "阅读历史");
                        break;
                }
            }

            if (exportFiles.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("types", request.getTypes());
                ErrorResponse errorResponse = new ErrorResponse("EXPORT_ERROR", "没有生成任何导出文件", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 创建ZIP文件
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ZipOutputStream zos = new ZipOutputStream(baos);

            // 添加README文件
            String readmeContent = generateReadmeContent(request.getTypes(), fileDescriptions, userId);
            ZipEntry readmeEntry = new ZipEntry("README.txt");
            zos.putNextEntry(readmeEntry);
            zos.write(readmeContent.getBytes(StandardCharsets.UTF_8));
            zos.closeEntry();

            // 添加导出文件
            for (Map.Entry<String, byte[]> entry : exportFiles.entrySet()) {
                ZipEntry fileEntry = new ZipEntry(entry.getKey());
                zos.putNextEntry(fileEntry);
                zos.write(entry.getValue());
                zos.closeEntry();
            }

            zos.close();
            byte[] zipBytes = baos.toByteArray();

            // 5. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String filename = "batch_export_" + timestamp + ".zip";

            // 6. 记录导出历史
            String exportId = "export_batch_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String typesJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", request.getTypes())
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("types", request.getTypes());
            exportDetails.put("file_count", exportFiles.size() + 1); // +1 for README
            exportDetails.put("total_size", zipBytes.length);
            exportDetails.put("filename", filename);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "types", String.join(",", request.getTypes()),
                    "file_count", exportFiles.size() + 1,
                    "total_size", zipBytes.length,
                    "filename", filename
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "BATCH",
                    typesJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 7. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.parseMediaType("application/zip"));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(zipBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", zipBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("types", request.getTypes());
            responseInfo.put("file_count", exportFiles.size() + 1);
            printResponse(responseInfo);

            return new ResponseEntity<>(zipBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("批量导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("BATCH_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 导出文档数据
    private byte[] exportDocumentsData(int userId) {
        String sql = "SELECT document_id, title, author, description, file_path, " +
                "file_size, page_count, reading_progress, created_at, updated_at " +
                "FROM documents WHERE user_id = ?";

        List<Map<String, Object>> documents = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "documents");
            put("count", documents.size());
        }});
        result.put("documents", documents);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出词汇数据
    private byte[] exportVocabularyData(int userId) {
        String sql = "SELECT uv.user_vocabulary_id, w.word, w.phonetic, wd.definition as meaning, " +
                "w.part_of_speech, uv.mastery_level, uv.study_count, uv.correct_count, " +
                "uv.wrong_count, uv.last_studied_at, uv.created_at " +
                "FROM user_vocabulary uv " +
                "JOIN words w ON uv.word_id = w.word_id " +
                "LEFT JOIN word_definitions wd ON w.word_id = wd.word_id AND wd.is_primary = 1 " +
                "WHERE uv.user_id = ?";

        List<Map<String, Object>> vocabulary = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "vocabulary");
            put("count", vocabulary.size());
        }});
        result.put("vocabulary", vocabulary);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出复习数据
    private byte[] exportReviewsData(int userId) {
        String sql = "SELECT review_session_id, start_time, end_time, total_items, " +
                "correct_count, wrong_count, accuracy, session_type, created_at " +
                "FROM review_sessions WHERE user_id = ?";

        List<Map<String, Object>> reviews = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "reviews");
            put("count", reviews.size());
        }});
        result.put("reviews", reviews);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出统计数据
    private byte[] exportStatisticsData(int userId) {
        // 查询各种统计数据
        Map<String, Object> statistics = new HashMap<>();

        // 每日统计
        String dailySql = "SELECT date, total_study_time, words_studied, documents_read, " +
                "notes_created, highlights_created FROM daily_learning_stats " +
                "WHERE user_id = ? ORDER BY date DESC LIMIT 30";
        statistics.put("daily_stats", jdbcTemplate.queryForList(dailySql, userId));

        // 词汇统计
        String vocabSql = "SELECT mastery_level, COUNT(*) as count FROM user_vocabulary " +
                "WHERE user_id = ? GROUP BY mastery_level";
        statistics.put("vocabulary_stats", jdbcTemplate.queryForList(vocabSql, userId));

        // 成就统计
        String achieveSql = "SELECT COUNT(*) as total_achievements FROM user_achievements " +
                "WHERE user_id = ?";
        statistics.put("achievement_stats", jdbcTemplate.queryForList(achieveSql, userId));

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "statistics");
        }});
        result.put("statistics", statistics);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出笔记数据
    private byte[] exportNotesData(int userId) {
        String sql = "SELECT note_id, document_id, page_number, content, " +
                "highlight_id, created_at, updated_at " +
                "FROM document_notes WHERE user_id = ?";

        List<Map<String, Object>> notes = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "notes");
            put("count", notes.size());
        }});
        result.put("notes", notes);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出高亮数据
    private byte[] exportHighlightsData(int userId) {
        String sql = "SELECT highlight_id, document_id, page_number, text_content, " +
                "color, start_position, end_position, created_at " +
                "FROM document_highlights WHERE user_id = ?";

        List<Map<String, Object>> highlights = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "highlights");
            put("count", highlights.size());
        }});
        result.put("highlights", highlights);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 导出阅读历史数据
    private byte[] exportReadingHistoryData(int userId) {
        String sql = "SELECT history_id, document_id, start_time, end_time, " +
                "duration_seconds, pages_read, created_at " +
                "FROM reading_history WHERE user_id = ? ORDER BY start_time DESC LIMIT 100";

        List<Map<String, Object>> history = jdbcTemplate.queryForList(sql, userId);

        Map<String, Object> result = new HashMap<>();
        result.put("metadata", new HashMap<String, Object>() {{
            put("exportedAt", LocalDateTime.now().toString());
            put("type", "reading_history");
            put("count", history.size());
        }});
        result.put("reading_history", history);

        return result.toString().getBytes(StandardCharsets.UTF_8);
    }

    // 生成README内容
    private String generateReadmeContent(List<String> types, Map<String, String> fileDescriptions, int userId) {
        StringBuilder readme = new StringBuilder();
        readme.append("批量导出数据包\n");
        readme.append("============\n\n");
        readme.append("导出信息:\n");
        readme.append("--------\n");
        readme.append("用户ID: ").append(userId).append("\n");
        readme.append("导出时间: ").append(LocalDateTime.now()).append("\n");
        readme.append("导出类型: ").append(String.join(", ", types)).append("\n");
        readme.append("文件格式: ZIP压缩包\n\n");

        readme.append("包含文件:\n");
        readme.append("--------\n");
        for (Map.Entry<String, String> entry : fileDescriptions.entrySet()) {
            readme.append("• ").append(entry.getKey()).append(" - ").append(entry.getValue()).append("\n");
        }
        readme.append("• README.txt - 本说明文件\n\n");

        readme.append("数据说明:\n");
        readme.append("--------\n");
        readme.append("1. 所有数据均为JSON格式，便于解析和处理\n");
        readme.append("2. 每个文件都包含metadata元数据，说明导出信息\n");
        readme.append("3. 数据时间范围为用户账户创建至今\n");
        readme.append("4. 敏感信息（如密码）已进行安全处理\n\n");

        readme.append("使用建议:\n");
        readme.append("--------\n");
        readme.append("1. 建议定期备份此数据包\n");
        readme.append("2. 可用于数据迁移或第三方分析\n");
        readme.append("3. 如需导入回系统，请使用专门的导入功能\n");
        readme.append("4. 妥善保管此文件，避免数据泄露\n");

        return readme.toString();
    }
}
--- 结束文件: BatchExport.java ---

--- 开始文件: CleanupExportFiles.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.util.*;

@RestController
@RequestMapping("/api/v1/export")
public class CleanupExportFiles {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到清理导出文件请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class CleanupExportFilesResponse {
        private boolean success = true;
        private String message = "清理成功";
        private CleanupData data;

        public CleanupExportFilesResponse(CleanupData data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public CleanupData getData() { return data; }
        public void setData(CleanupData data) { this.data = data; }
    }

    public static class CleanupData {
        private int deletedCount;
        private long freedSpace;
        private Map<String, Integer> deletedByType;
        private LocalDateTime cleanupTime;

        public CleanupData(int deletedCount, long freedSpace, Map<String, Integer> deletedByType, LocalDateTime cleanupTime) {
            this.deletedCount = deletedCount;
            this.freedSpace = freedSpace;
            this.deletedByType = deletedByType;
            this.cleanupTime = cleanupTime;
        }

        public int getDeletedCount() { return deletedCount; }
        public void setDeletedCount(int deletedCount) { this.deletedCount = deletedCount; }

        public long getFreedSpace() { return freedSpace; }
        public void setFreedSpace(long freedSpace) { this.freedSpace = freedSpace; }

        public Map<String, Integer> getDeletedByType() { return deletedByType; }
        public void setDeletedByType(Map<String, Integer> deletedByType) { this.deletedByType = deletedByType; }

        public LocalDateTime getCleanupTime() { return cleanupTime; }
        public void setCleanupTime(LocalDateTime cleanupTime) { this.cleanupTime = cleanupTime; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @DeleteMapping("/cleanup")
    public ResponseEntity<?> cleanupExportFiles(@RequestParam(required = false, defaultValue = "30") int daysOld,
                                                @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest("daysOld=" + daysOld);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (daysOld < 1 || daysOld > 365) {
                Map<String, Object> details = new HashMap<>();
                details.put("daysOld", daysOld);
                details.put("valid_range", "1-365天");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "清理天数应在1-365之间", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询要清理的记录
            String findOldSql = "SELECT log_id, entity_type, details FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "AND created_at < DATE_SUB(NOW(), INTERVAL ? DAY) " +
                    "ORDER BY created_at";

            List<Map<String, Object>> oldRecords = jdbcTemplate.queryForList(findOldSql, userId, daysOld);
            printQueryResult("找到需要清理的记录: " + oldRecords.size() + "条");

            if (oldRecords.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("daysOld", daysOld);
                details.put("recordsFound", 0);
                ErrorResponse errorResponse = new ErrorResponse("NO_RECORDS_TO_CLEANUP", "没有找到需要清理的记录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 计算要释放的空间
            long totalFreedSpace = 0;
            Map<String, Integer> deletedByType = new HashMap<>();

            for (Map<String, Object> record : oldRecords) {
                String entityType = (String) record.get("entity_type");
                String detailsJson = (String) record.get("details");

                // 从details中提取文件大小
                if (detailsJson != null && detailsJson.contains("\"file_size\":")) {
                    try {
                        String sizePart = detailsJson.split("\"file_size\":")[1].split(",")[0].replace("\"", "").trim();
                        long fileSize = Long.parseLong(sizePart);
                        totalFreedSpace += fileSize;
                    } catch (Exception e) {
                        System.out.println("无法解析文件大小: " + detailsJson);
                    }
                }

                // 统计按类型删除的数量
                deletedByType.put(entityType, deletedByType.getOrDefault(entityType, 0) + 1);
            }

            // 5. 执行清理
            String deleteSql = "DELETE FROM sync_logs WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "AND created_at < DATE_SUB(NOW(), INTERVAL ? DAY)";

            int deletedCount = jdbcTemplate.update(deleteSql, userId, daysOld);

            if (deletedCount != oldRecords.size()) {
                System.out.println("警告: 预期删除 " + oldRecords.size() + " 条记录，实际删除 " + deletedCount + " 条");
            }

            // 6. 构建响应数据
            CleanupData cleanupData = new CleanupData(
                    deletedCount,
                    totalFreedSpace,
                    deletedByType,
                    LocalDateTime.now()
            );

            CleanupExportFilesResponse response = new CleanupExportFilesResponse(cleanupData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("清理导出文件过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            details.put("daysOld", daysOld);
            ErrorResponse errorResponse = new ErrorResponse("CLEANUP_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}
--- 结束文件: CleanupExportFiles.java ---

--- 开始文件: CreateExportTemplate.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.time.format.DateTimeFormatter;

@RestController
@RequestMapping("/api/v1/export")
public class CreateExportTemplate {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到创建导出模板请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class CreateExportTemplateRequest {
        private String name;
        private String type;
        private String format;
        private String description;
        private Map<String, Object> config;
        private boolean isDefault = false;
        private boolean isPublic = false;

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public Map<String, Object> getConfig() { return config; }
        public void setConfig(Map<String, Object> config) { this.config = config; }

        public boolean isDefault() { return isDefault; }
        public void setDefault(boolean aDefault) { isDefault = aDefault; }

        public boolean isPublic() { return isPublic; }
        public void setPublic(boolean aPublic) { isPublic = aPublic; }
    }

    // 响应DTO
    public static class CreateExportTemplateResponse {
        private boolean success = true;
        private String message = "创建成功";
        private TemplateData data;

        public CreateExportTemplateResponse(TemplateData data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public TemplateData getData() { return data; }
        public void setData(TemplateData data) { this.data = data; }
    }

    public static class TemplateData {
        private String id;
        private String name;
        private String type;
        private String format;
        private String description;
        private Map<String, Object> config;
        private boolean isDefault;
        private boolean isPublic;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;

        public TemplateData(String id, String name, String type, String format,
                            String description, Map<String, Object> config,
                            boolean isDefault, boolean isPublic,
                            LocalDateTime createdAt, LocalDateTime updatedAt) {
            this.id = id;
            this.name = name;
            this.type = type;
            this.format = format;
            this.description = description;
            this.config = config;
            this.isDefault = isDefault;
            this.isPublic = isPublic;
            this.createdAt = createdAt;
            this.updatedAt = updatedAt;
        }

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public Map<String, Object> getConfig() { return config; }
        public void setConfig(Map<String, Object> config) { this.config = config; }

        public boolean isDefault() { return isDefault; }
        public void setDefault(boolean aDefault) { isDefault = aDefault; }

        public boolean isPublic() { return isPublic; }
        public void setPublic(boolean aPublic) { isPublic = aPublic; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public LocalDateTime getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 支持的导出类型
    private static final Set<String> SUPPORTED_TYPES = new HashSet<>(Arrays.asList(
            "documents", "vocabulary", "reviews", "statistics",
            "notes", "highlights", "reading_history", "batch", "all_data"
    ));

    // 支持的格式
    private static final Map<String, Set<String>> SUPPORTED_FORMATS_BY_TYPE = new HashMap<>();

    static {
        SUPPORTED_FORMATS_BY_TYPE.put("documents", new HashSet<>(Arrays.asList("pdf", "docx", "xlsx", "csv", "json", "html", "txt")));
        SUPPORTED_FORMATS_BY_TYPE.put("vocabulary", new HashSet<>(Arrays.asList("xlsx", "csv", "json", "pdf")));
        SUPPORTED_FORMATS_BY_TYPE.put("reviews", new HashSet<>(Arrays.asList("csv", "json", "pdf", "xlsx")));
        SUPPORTED_FORMATS_BY_TYPE.put("statistics", new HashSet<>(Arrays.asList("pdf", "xlsx", "csv", "json")));
        SUPPORTED_FORMATS_BY_TYPE.put("notes", new HashSet<>(Arrays.asList("pdf", "html", "txt", "docx")));
        SUPPORTED_FORMATS_BY_TYPE.put("highlights", new HashSet<>(Arrays.asList("json", "csv", "pdf")));
        SUPPORTED_FORMATS_BY_TYPE.put("reading_history", new HashSet<>(Arrays.asList("csv", "json", "pdf")));
        SUPPORTED_FORMATS_BY_TYPE.put("batch", new HashSet<>(Arrays.asList("zip")));
        SUPPORTED_FORMATS_BY_TYPE.put("all_data", new HashSet<>(Arrays.asList("json")));
    }

    @PostMapping("/templates")
    public ResponseEntity<?> createExportTemplate(@RequestBody CreateExportTemplateRequest request,
                                                  @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            Map<String, Object> validationErrors = new HashMap<>();

            if (request.getName() == null || request.getName().trim().isEmpty()) {
                validationErrors.put("name", "模板名称不能为空");
            } else if (request.getName().length() > 100) {
                validationErrors.put("name", "模板名称不能超过100个字符");
            }

            if (request.getType() == null || request.getType().trim().isEmpty()) {
                validationErrors.put("type", "模板类型不能为空");
            } else if (!SUPPORTED_TYPES.contains(request.getType().toLowerCase())) {
                validationErrors.put("type", "不支持的模板类型: " + request.getType());
                validationErrors.put("supported_types", SUPPORTED_TYPES);
            }

            if (request.getFormat() == null || request.getFormat().trim().isEmpty()) {
                validationErrors.put("format", "导出格式不能为空");
            } else if (request.getType() != null && SUPPORTED_FORMATS_BY_TYPE.containsKey(request.getType().toLowerCase())) {
                Set<String> supportedFormats = SUPPORTED_FORMATS_BY_TYPE.get(request.getType().toLowerCase());
                if (!supportedFormats.contains(request.getFormat().toLowerCase())) {
                    validationErrors.put("format", "不支持的导出格式: " + request.getFormat() + " 对于类型: " + request.getType());
                    validationErrors.put("supported_formats", supportedFormats);
                }
            }

            if (request.getDescription() != null && request.getDescription().length() > 500) {
                validationErrors.put("description", "描述不能超过500个字符");
            }

            if (request.getConfig() == null) {
                validationErrors.put("config", "配置不能为空");
            }

            if (!validationErrors.isEmpty()) {
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数验证失败", validationErrors);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 检查是否已存在同名模板
            String checkSql = "SELECT COUNT(*) as count FROM export_templates WHERE user_id = ? AND template_name = ?";
            int existingCount = jdbcTemplate.queryForObject(checkSql, Integer.class, userId, request.getName());

            if (existingCount > 0) {
                Map<String, Object> details = new HashMap<>();
                details.put("name", request.getName());
                details.put("user_id", userId);
                ErrorResponse errorResponse = new ErrorResponse("DUPLICATE_TEMPLATE", "已存在同名模板", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
            }

            // 4. 如果设置为默认模板，先取消其他默认模板
            if (request.isDefault()) {
                String unsetDefaultSql = "UPDATE export_templates SET is_default = false WHERE user_id = ? AND template_type = ?";
                jdbcTemplate.update(unsetDefaultSql, userId, request.getType());
            }

            // 5. 创建模板
            LocalDateTime now = LocalDateTime.now();

            // 将config Map转换为JSON字符串
            String configJson = convertMapToJson(request.getConfig());

            String insertSql = "INSERT INTO export_templates (user_id, template_name, template_type, " +
                    "export_format, description, config, is_default, is_public, created_at, updated_at) " +
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

            jdbcTemplate.update(insertSql,
                    userId,
                    request.getName(),
                    request.getType(),
                    request.getFormat(),
                    request.getDescription() != null ? request.getDescription() : "",
                    configJson,
                    request.isDefault(),
                    request.isPublic(),
                    now,
                    now
            );

            // 6. 获取新创建的模板ID
            String getIdSql = "SELECT LAST_INSERT_ID() as template_id";
            int templateId = jdbcTemplate.queryForObject(getIdSql, Integer.class);

            // 7. 构建响应数据
            String templateIdStr = "template_" + templateId;
            TemplateData templateData = new TemplateData(
                    templateIdStr,
                    request.getName(),
                    request.getType(),
                    request.getFormat(),
                    request.getDescription(),
                    request.getConfig(),
                    request.isDefault(),
                    request.isPublic(),
                    now,
                    now
            );

            CreateExportTemplateResponse response = new CreateExportTemplateResponse(templateData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.status(HttpStatus.CREATED).body(response);

        } catch (Exception e) {
            System.err.println("创建导出模板过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("TEMPLATE_CREATION_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 将Map转换为JSON字符串（简化版）
    private String convertMapToJson(Map<String, Object> map) {
        if (map == null || map.isEmpty()) {
            return "{}";
        }

        StringBuilder json = new StringBuilder();
        json.append("{");

        int count = 0;
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (count > 0) {
                json.append(",");
            }

            json.append("\"").append(entry.getKey()).append("\":");

            Object value = entry.getValue();
            if (value instanceof String) {
                json.append("\"").append(escapeJson(value.toString())).append("\"");
            } else if (value instanceof Number) {
                json.append(value);
            } else if (value instanceof Boolean) {
                json.append(value);
            } else if (value instanceof Map) {
                json.append(convertMapToJson((Map<String, Object>) value));
            } else {
                json.append("\"").append(escapeJson(value.toString())).append("\"");
            }

            count++;
        }

        json.append("}");
        return json.toString();
    }

    // 转义JSON字符串
    private String escapeJson(String str) {
        if (str == null) return "";
        return str
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}
--- 结束文件: CreateExportTemplate.java ---

--- 开始文件: DeleteExportHistory.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.time.format.DateTimeFormatter;

@RestController
@RequestMapping("/api/v1/export")
public class DeleteExportHistory {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到删除导出历史请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class DeleteExportHistoryRequest {
        private String historyId;

        public String getHistoryId() { return historyId; }
        public void setHistoryId(String historyId) { this.historyId = historyId; }
    }

    // 响应DTO
    public static class DeleteExportHistoryResponse {
        private boolean success = true;
        private String message = "删除成功";
        private Map<String, Object> data;

        public DeleteExportHistoryResponse(Map<String, Object> data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public Map<String, Object> getData() { return data; }
        public void setData(Map<String, Object> data) { this.data = data; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @DeleteMapping("/history/{historyId}")
    public ResponseEntity<?> deleteExportHistory(@PathVariable String historyId,
                                                 @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 构建请求对象
        DeleteExportHistoryRequest request = new DeleteExportHistoryRequest();
        request.setHistoryId(historyId);

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (historyId == null || historyId.trim().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("historyId", "历史记录ID不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 解析historyId，获取实际的log_id
            int logId = -1;

            if (historyId.startsWith("export_")) {
                // 尝试从historyId中提取数字部分
                try {
                    // 格式可能是: export_1234567890_abc123 或 export_123
                    String[] parts = historyId.split("_");
                    if (parts.length >= 2) {
                        // 尝试解析数字
                        String numericPart = parts[1];
                        logId = Integer.parseInt(numericPart);
                    }
                } catch (NumberFormatException e) {
                    // 如果解析失败，尝试查询数据库
                    System.out.println("无法从historyId解析log_id，尝试查询数据库");
                }
            }

            // 4. 查询要删除的记录是否存在且属于当前用户
            String checkSql;
            List<Object> checkParams = new ArrayList<>();

            if (logId > 0) {
                checkSql = "SELECT log_id, operation_type, entity_type, details FROM sync_logs " +
                        "WHERE log_id = ? AND user_id = ? AND operation_type = 'EXPORT'";
                checkParams.add(logId);
                checkParams.add(userId);
            } else {
                // 如果无法解析log_id，尝试通过details中的export_id查找
                checkSql = "SELECT log_id, operation_type, entity_type, details FROM sync_logs " +
                        "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                        "AND details LIKE ?";
                checkParams.add(userId);
                checkParams.add("%\"" + historyId + "\"%");
            }

            List<Map<String, Object>> records = jdbcTemplate.queryForList(checkSql, checkParams.toArray());

            if (records.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("historyId", historyId);
                details.put("userId", userId);
                ErrorResponse errorResponse = new ErrorResponse("HISTORY_NOT_FOUND", "未找到指定的导出历史记录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 5. 获取要删除的log_id
            Map<String, Object> record = records.get(0);
            int actualLogId = (int) record.get("log_id");

            // 6. 删除记录
            String deleteSql = "DELETE FROM sync_logs WHERE log_id = ? AND user_id = ?";
            int deletedCount = jdbcTemplate.update(deleteSql, actualLogId, userId);

            if (deletedCount == 0) {
                Map<String, Object> details = new HashMap<>();
                details.put("logId", actualLogId);
                details.put("userId", userId);
                ErrorResponse errorResponse = new ErrorResponse("DELETE_FAILED", "删除失败，记录可能已被删除", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
            }

            // 7. 构建响应数据
            Map<String, Object> responseData = new HashMap<>();
            responseData.put("deletedId", historyId);
            responseData.put("logId", actualLogId);
            responseData.put("deletedAt", LocalDateTime.now().toString());
            responseData.put("operationType", record.get("operation_type"));
            responseData.put("entityType", record.get("entity_type"));

            // 解析details字段
            String detailsJson = (String) record.get("details");
            if (detailsJson != null && detailsJson.startsWith("{")) {
                // 简单解析details
                Map<String, Object> detailsMap = new HashMap<>();
                String content = detailsJson.substring(1, detailsJson.length() - 1);
                String[] pairs = content.split(",");

                for (String pair : pairs) {
                    String[] keyValue = pair.split(":");
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim().replace("\"", "");
                        String value = keyValue[1].trim().replace("\"", "");
                        detailsMap.put(key, value);
                    }
                }

                responseData.put("details", detailsMap);
            }

            DeleteExportHistoryResponse response = new DeleteExportHistoryResponse(responseData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("删除导出历史过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            details.put("historyId", historyId);
            ErrorResponse errorResponse = new ErrorResponse("HISTORY_DELETION_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}
--- 结束文件: DeleteExportHistory.java ---

--- 开始文件: ExportAllData.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportAllData {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到所有数据导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportAllDataRequest {
        private String format = "json";
        private boolean encrypt = false;

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public boolean isEncrypt() { return encrypt; }
        public void setEncrypt(boolean encrypt) { this.encrypt = encrypt; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @GetMapping("/all")
    public ResponseEntity<?> exportAllData(@RequestParam(required = false, defaultValue = "json") String format,
                                           @RequestParam(required = false, defaultValue = "false") boolean encrypt,
                                           @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 构建请求对象
        ExportAllDataRequest request = new ExportAllDataRequest();
        request.setFormat(format);
        request.setEncrypt(encrypt);

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (!"json".equalsIgnoreCase(request.getFormat())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "所有数据导出只支持JSON格式");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.isEncrypt()) {
                // 加密功能暂不支持
                Map<String, Object> details = new HashMap<>();
                details.put("encrypt", "加密功能暂未实现");
                ErrorResponse errorResponse = new ErrorResponse("FEATURE_NOT_AVAILABLE", "加密功能暂未实现", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询所有数据
            Map<String, Object> allData = new HashMap<>();

            // 3.1 用户基本信息
            String userInfoSql = "SELECT user_id, username, email, nickname, avatar_url, " +
                    "role, is_verified, created_at, last_login_at FROM users " +
                    "WHERE user_id = ?";
            List<Map<String, Object>> userInfo = jdbcTemplate.queryForList(userInfoSql, userId);
            allData.put("user_info", userInfo.isEmpty() ? new HashMap<>() : userInfo.get(0));
            printQueryResult("用户信息查询完成");

            // 3.2 文档数据
            String documentsSql = "SELECT document_id, title, author, description, file_path, " +
                    "file_size, page_count, reading_progress, created_at, updated_at " +
                    "FROM documents WHERE user_id = ?";
            List<Map<String, Object>> documents = jdbcTemplate.queryForList(documentsSql, userId);
            allData.put("documents", documents);
            printQueryResult("文档数据查询完成: " + documents.size() + "条记录");

            // 3.3 词汇数据
            String vocabularySql = "SELECT uv.user_vocabulary_id, w.word, w.phonetic, wd.definition as meaning, " +
                    "w.part_of_speech, uv.mastery_level, uv.study_count, uv.correct_count, " +
                    "uv.wrong_count, uv.last_studied_at, uv.created_at " +
                    "FROM user_vocabulary uv " +
                    "JOIN words w ON uv.word_id = w.word_id " +
                    "LEFT JOIN word_definitions wd ON w.word_id = wd.word_id AND wd.is_primary = 1 " +
                    "WHERE uv.user_id = ?";
            List<Map<String, Object>> vocabulary = jdbcTemplate.queryForList(vocabularySql, userId);
            allData.put("vocabulary", vocabulary);
            printQueryResult("词汇数据查询完成: " + vocabulary.size() + "条记录");

            // 3.4 复习记录
            String reviewsSql = "SELECT review_session_id, start_time, end_time, total_items, " +
                    "correct_count, wrong_count, accuracy, session_type, created_at " +
                    "FROM review_sessions WHERE user_id = ?";
            List<Map<String, Object>> reviews = jdbcTemplate.queryForList(reviewsSql, userId);
            allData.put("reviews", reviews);
            printQueryResult("复习记录查询完成: " + reviews.size() + "条记录");

            // 3.5 学习统计
            String statsSql = "SELECT date, total_study_time, words_studied, documents_read, " +
                    "notes_created, highlights_created FROM daily_learning_stats " +
                    "WHERE user_id = ? ORDER BY date DESC";
            List<Map<String, Object>> learningStats = jdbcTemplate.queryForList(statsSql, userId);
            allData.put("learning_stats", learningStats);
            printQueryResult("学习统计查询完成: " + learningStats.size() + "条记录");

            // 3.6 笔记数据
            String notesSql = "SELECT note_id, document_id, page_number, content, " +
                    "highlight_id, created_at, updated_at " +
                    "FROM document_notes WHERE user_id = ?";
            List<Map<String, Object>> notes = jdbcTemplate.queryForList(notesSql, userId);
            allData.put("notes", notes);
            printQueryResult("笔记数据查询完成: " + notes.size() + "条记录");

            // 3.7 高亮数据
            String highlightsSql = "SELECT highlight_id, document_id, page_number, text_content, " +
                    "color, start_position, end_position, created_at " +
                    "FROM document_highlights WHERE user_id = ?";
            List<Map<String, Object>> highlights = jdbcTemplate.queryForList(highlightsSql, userId);
            allData.put("highlights", highlights);
            printQueryResult("高亮数据查询完成: " + highlights.size() + "条记录");

            // 3.8 阅读历史
            String historySql = "SELECT history_id, document_id, start_time, end_time, " +
                    "duration_seconds, pages_read, created_at " +
                    "FROM reading_history WHERE user_id = ? ORDER BY start_time DESC";
            List<Map<String, Object>> readingHistory = jdbcTemplate.queryForList(historySql, userId);
            allData.put("reading_history", readingHistory);
            printQueryResult("阅读历史查询完成: " + readingHistory.size() + "条记录");

            // 3.9 用户设置
            String settingsSql = "SELECT setting_key, setting_value FROM user_settings WHERE user_id = ?";
            List<Map<String, Object>> settings = jdbcTemplate.queryForList(settingsSql, userId);
            allData.put("settings", settings);
            printQueryResult("用户设置查询完成: " + settings.size() + "条记录");

            // 3.10 学习成就
            String achievementsSql = "SELECT a.achievement_id, a.name, a.description, a.icon_url, " +
                    "a.points, ua.unlocked_at FROM user_achievements ua " +
                    "JOIN learning_achievements a ON ua.achievement_id = a.achievement_id " +
                    "WHERE ua.user_id = ?";
            List<Map<String, Object>> achievements = jdbcTemplate.queryForList(achievementsSql, userId);
            allData.put("achievements", achievements);
            printQueryResult("学习成就查询完成: " + achievements.size() + "条记录");

            // 4. 添加元数据
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("exported_at", LocalDateTime.now().toString());
            metadata.put("user_id", userId);
            metadata.put("format", "json");
            metadata.put("version", "1.0");
            metadata.put("data_sections", Arrays.asList(
                    "user_info", "documents", "vocabulary", "reviews",
                    "learning_stats", "notes", "highlights", "reading_history",
                    "settings", "achievements"
            ));

            Map<String, Object> finalData = new HashMap<>();
            finalData.put("metadata", metadata);
            finalData.put("data", allData);

            // 5. 生成JSON内容
            String jsonContent = generateJsonContent(finalData);
            byte[] fileBytes = jsonContent.getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String filename = "all_data_" + timestamp + ".json";

            // 7. 记录导出历史
            String exportId = "export_all_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?)";

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("encrypt", request.isEncrypt());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);
            exportDetails.put("data_sections", metadata.get("data_sections"));

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "encrypt", request.isEncrypt(),
                    "filename", filename,
                    "file_size", fileBytes.length,
                    "data_sections", String.join(",", (List<String>) metadata.get("data_sections"))
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "ALL_DATA",
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("data_sections_count", ((List<?>) metadata.get("data_sections")).size());
            responseInfo.put("total_records",
                    documents.size() + vocabulary.size() + reviews.size() +
                            learningStats.size() + notes.size() + highlights.size() +
                            readingHistory.size() + settings.size() + achievements.size()
            );
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("所有数据导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("ALL_DATA_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成JSON内容
    private String generateJsonContent(Map<String, Object> data) {
        StringBuilder json = new StringBuilder();
        json.append("{\n");

        // 添加metadata
        json.append("  \"metadata\": {\n");
        Map<String, Object> metadata = (Map<String, Object>) data.get("metadata");

        int metaCount = 0;
        for (Map.Entry<String, Object> entry : metadata.entrySet()) {
            json.append("    \"").append(entry.getKey()).append("\": ");

            Object value = entry.getValue();
            if (value instanceof String) {
                json.append("\"").append(escapeJson(value.toString())).append("\"");
            } else if (value instanceof List) {
                json.append("[");
                List<?> list = (List<?>) value;
                for (int i = 0; i < list.size(); i++) {
                    json.append("\"").append(escapeJson(list.get(i).toString())).append("\"");
                    if (i < list.size() - 1) json.append(", ");
                }
                json.append("]");
            } else {
                json.append(value);
            }

            if (++metaCount < metadata.size()) json.append(",");
            json.append("\n");
        }
        json.append("  },\n");

        // 添加data
        json.append("  \"data\": {\n");
        Map<String, Object> allData = (Map<String, Object>) data.get("data");

        int dataCount = 0;
        for (Map.Entry<String, Object> entry : allData.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            json.append("    \"").append(key).append("\": ");

            if (value instanceof List) {
                List<Map<String, Object>> list = (List<Map<String, Object>>) value;
                json.append("[\n");

                for (int i = 0; i < list.size(); i++) {
                    Map<String, Object> item = list.get(i);
                    json.append("      {\n");

                    int itemCount = 0;
                    for (Map.Entry<String, Object> itemEntry : item.entrySet()) {
                        json.append("        \"").append(itemEntry.getKey()).append("\": ");

                        Object itemValue = itemEntry.getValue();
                        if (itemValue instanceof String) {
                            json.append("\"").append(escapeJson(itemValue.toString())).append("\"");
                        } else if (itemValue instanceof java.sql.Timestamp) {
                            json.append("\"").append(itemValue.toString()).append("\"");
                        } else {
                            json.append(itemValue);
                        }

                        if (++itemCount < item.size()) json.append(",");
                        json.append("\n");
                    }

                    json.append("      }");
                    if (i < list.size() - 1) json.append(",");
                    json.append("\n");
                }

                json.append("    ]");
            } else if (value instanceof Map) {
                Map<String, Object> map = (Map<String, Object>) value;
                json.append("{\n");

                int mapCount = 0;
                for (Map.Entry<String, Object> mapEntry : map.entrySet()) {
                    json.append("      \"").append(mapEntry.getKey()).append("\": ");

                    Object mapValue = mapEntry.getValue();
                    if (mapValue instanceof String) {
                        json.append("\"").append(escapeJson(mapValue.toString())).append("\"");
                    } else if (mapValue instanceof java.sql.Timestamp) {
                        json.append("\"").append(mapValue.toString()).append("\"");
                    } else {
                        json.append(mapValue);
                    }

                    if (++mapCount < map.size()) json.append(",");
                    json.append("\n");
                }

                json.append("    }");
            } else {
                json.append(value);
            }

            if (++dataCount < allData.size()) json.append(",");
            json.append("\n");
        }

        json.append("  }\n");
        json.append("}");

        return json.toString();
    }

    // 转义JSON字符串
    private String escapeJson(String str) {
        if (str == null) return "";
        return str
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}
--- 结束文件: ExportAllData.java ---

--- 开始文件: ExportDocuments.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportDocuments {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到文档导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportDocumentsRequest {
        private List<Integer> document_ids;
        private String format = "pdf";
        private Map<String, Object> template;
        private boolean include_notes = true;
        private boolean include_highlights = true;

        public List<Integer> getDocument_ids() { return document_ids; }
        public void setDocument_ids(List<Integer> document_ids) { this.document_ids = document_ids; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }

        public boolean isInclude_notes() { return include_notes; }
        public void setInclude_notes(boolean include_notes) { this.include_notes = include_notes; }

        public boolean isInclude_highlights() { return include_highlights; }
        public void setInclude_highlights(boolean include_highlights) { this.include_highlights = include_highlights; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 导出历史记录DTO
    public static class ExportHistory {
        private String id;
        private String type;
        private String format;
        private int itemCount;
        private String filename;
        private String fileSize;
        private boolean isBackup;
        private int userId;
        private LocalDateTime createdAt;
        private String status;

        // 构造函数、getter和setter
        public ExportHistory(String id, String type, String format, int itemCount, String filename,
                             String fileSize, boolean isBackup, int userId, LocalDateTime createdAt, String status) {
            this.id = id;
            this.type = type;
            this.format = format;
            this.itemCount = itemCount;
            this.filename = filename;
            this.fileSize = fileSize;
            this.isBackup = isBackup;
            this.userId = userId;
            this.createdAt = createdAt;
            this.status = status;
        }

        // getter和setter方法
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public int getItemCount() { return itemCount; }
        public void setItemCount(int itemCount) { this.itemCount = itemCount; }

        public String getFilename() { return filename; }
        public void setFilename(String filename) { this.filename = filename; }

        public String getFileSize() { return fileSize; }
        public void setFileSize(String fileSize) { this.fileSize = fileSize; }

        public boolean isBackup() { return isBackup; }
        public void setBackup(boolean backup) { isBackup = backup; }

        public int getUserId() { return userId; }
        public void setUserId(int userId) { this.userId = userId; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "pdf", "docx", "xlsx", "csv", "json", "html", "txt"
    ));

    @PostMapping("/documents/batch")
    public ResponseEntity<?> exportDocuments(@RequestBody ExportDocumentsRequest request,
                                             @RequestHeader(value = "Authorization", required = false) String authHeader) {
        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getDocument_ids() == null || request.getDocument_ids().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("document_ids", "文档ID列表不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getDocument_ids().size() > 100) {
                Map<String, Object> details = new HashMap<>();
                details.put("document_ids", "最多支持导出100个文档");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 验证文档是否存在且属于当前用户
            List<Integer> invalidDocIds = new ArrayList<>();
            List<Integer> validDocIds = new ArrayList<>();

            for (Integer docId : request.getDocument_ids()) {
                String docSql = "SELECT document_id FROM documents WHERE document_id = ? AND user_id = ?";
                List<Map<String, Object>> docs = jdbcTemplate.queryForList(docSql, docId, userId);

                if (docs.isEmpty()) {
                    invalidDocIds.add(docId);
                } else {
                    validDocIds.add(docId);
                }
            }

            if (!invalidDocIds.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("documentIds", invalidDocIds);
                ErrorResponse errorResponse = new ErrorResponse("DOCUMENT_NOT_FOUND", "部分文档不存在或无权限访问", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 查询文档详细信息
            String placeholders = String.join(",", Collections.nCopies(validDocIds.size(), "?"));
            String querySql = "SELECT d.document_id, d.title, d.author, d.description, d.file_path, " +
                    "d.file_size, d.page_count, d.reading_progress, d.created_at, d.updated_at " +
                    "FROM documents d WHERE d.document_id IN (" + placeholders + ") AND d.user_id = ?";

            List<Object> params = new ArrayList<>(validDocIds);
            params.add(userId);

            List<Map<String, Object>> documents = jdbcTemplate.queryForList(querySql, params.toArray());
            printQueryResult(documents);

            if (documents.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("documentIds", validDocIds);
                ErrorResponse errorResponse = new ErrorResponse("EXPORT_ERROR", "没有找到可导出的文档", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 5. 查询文档笔记（如果需要）
            List<Map<String, Object>> notes = new ArrayList<>();
            if (request.isInclude_notes()) {
                String notesSql = "SELECT n.note_id, n.document_id, n.page_number, n.content, " +
                        "n.highlight_id, n.created_at, n.updated_at " +
                        "FROM document_notes n WHERE n.document_id IN (" + placeholders + ") AND n.user_id = ?";
                notes = jdbcTemplate.queryForList(notesSql, params.toArray());
                printQueryResult("笔记查询结果: " + notes.size() + "条记录");
            }

            // 6. 查询文档高亮（如果需要）
            List<Map<String, Object>> highlights = new ArrayList<>();
            if (request.isInclude_highlights()) {
                String highlightsSql = "SELECT h.highlight_id, h.document_id, h.page_number, h.text_content, " +
                        "h.color, h.start_position, h.end_position, h.created_at " +
                        "FROM document_highlights h WHERE h.document_id IN (" + placeholders + ") AND h.user_id = ?";
                highlights = jdbcTemplate.queryForList(highlightsSql, params.toArray());
                printQueryResult("高亮查询结果: " + highlights.size() + "条记录");
            }

            // 7. 生成导出文件内容（模拟）
            String fileContent = generateExportContent(documents, notes, highlights, request.getFormat());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 8. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "documents_" + timestamp + "." + extension;

            // 9. 记录导出历史
            String exportId = "export_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", validDocIds.stream().map(String::valueOf).toArray(String[]::new))
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("item_count", documents.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);
            exportDetails.put("include_notes", request.isInclude_notes());
            exportDetails.put("include_highlights", request.isInclude_highlights());

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "item_count", documents.size(),
                    "filename", filename,
                    "file_size", fileBytes.length,
                    "include_notes", request.isInclude_notes(),
                    "include_highlights", request.isInclude_highlights()
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "DOCUMENTS",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 10. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("document_count", documents.size());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("文档导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成导出内容（模拟）
    private String generateExportContent(List<Map<String, Object>> documents,
                                         List<Map<String, Object>> notes,
                                         List<Map<String, Object>> highlights,
                                         String format) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("documents", documents);
            exportData.put("notes", notes);
            exportData.put("highlights", highlights);
            exportData.put("exported_at", LocalDateTime.now().toString());
            exportData.put("total_documents", documents.size());
            exportData.put("total_notes", notes.size());
            exportData.put("total_highlights", highlights.size());

            // 简单JSON序列化（实际项目中应使用Jackson等库）
            content.append("{\n");
            content.append("  \"exported_at\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("  \"total_documents\": ").append(documents.size()).append(",\n");
            content.append("  \"total_notes\": ").append(notes.size()).append(",\n");
            content.append("  \"total_highlights\": ").append(highlights.size()).append(",\n");
            content.append("  \"documents\": [\n");

            for (int i = 0; i < documents.size(); i++) {
                Map<String, Object> doc = documents.get(i);
                content.append("    {\n");
                content.append("      \"id\": ").append(doc.get("document_id")).append(",\n");
                content.append("      \"title\": \"").append(escapeJson(doc.get("title"))).append("\",\n");
                content.append("      \"author\": \"").append(escapeJson(doc.get("author"))).append("\",\n");
                content.append("      \"description\": \"").append(escapeJson(doc.get("description"))).append("\",\n");
                content.append("      \"page_count\": ").append(doc.get("page_count")).append(",\n");
                content.append("      \"created_at\": \"").append(doc.get("created_at")).append("\"\n");
                content.append("    }");
                if (i < documents.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式
            content.append("Document ID,Title,Author,Description,Page Count,Created At\n");
            for (Map<String, Object> doc : documents) {
                content.append(doc.get("document_id")).append(",");
                content.append("\"").append(escapeCsv(doc.get("title"))).append("\",");
                content.append("\"").append(escapeCsv(doc.get("author"))).append("\",");
                content.append("\"").append(escapeCsv(doc.get("description"))).append("\",");
                content.append(doc.get("page_count")).append(",");
                content.append("\"").append(doc.get("created_at")).append("\"\n");
            }

        } else if (format.equalsIgnoreCase("html")) {
            // HTML格式
            content.append("<!DOCTYPE html>\n");
            content.append("<html>\n");
            content.append("<head>\n");
            content.append("  <meta charset=\"UTF-8\">\n");
            content.append("  <title>文档导出报告</title>\n");
            content.append("  <style>\n");
            content.append("    body { font-family: Arial, sans-serif; margin: 20px; }\n");
            content.append("    h1 { color: #333; }\n");
            content.append("    table { border-collapse: collapse; width: 100%; }\n");
            content.append("    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
            content.append("    th { background-color: #f2f2f2; }\n");
            content.append("  </style>\n");
            content.append("</head>\n");
            content.append("<body>\n");
            content.append("  <h1>文档导出报告</h1>\n");
            content.append("  <p>导出时间: ").append(LocalDateTime.now()).append("</p>\n");
            content.append("  <p>文档数量: ").append(documents.size()).append("</p>\n");
            content.append("  <h2>文档列表</h2>\n");
            content.append("  <table>\n");
            content.append("    <tr>\n");
            content.append("      <th>ID</th>\n");
            content.append("      <th>标题</th>\n");
            content.append("      <th>作者</th>\n");
            content.append("      <th>描述</th>\n");
            content.append("      <th>页数</th>\n");
            content.append("      <th>创建时间</th>\n");
            content.append("    </tr>\n");

            for (Map<String, Object> doc : documents) {
                content.append("    <tr>\n");
                content.append("      <td>").append(doc.get("document_id")).append("</td>\n");
                content.append("      <td>").append(escapeHtml(doc.get("title"))).append("</td>\n");
                content.append("      <td>").append(escapeHtml(doc.get("author"))).append("</td>\n");
                content.append("      <td>").append(escapeHtml(doc.get("description"))).append("</td>\n");
                content.append("      <td>").append(doc.get("page_count")).append("</td>\n");
                content.append("      <td>").append(doc.get("created_at")).append("</td>\n");
                content.append("    </tr>\n");
            }

            content.append("  </table>\n");
            content.append("</body>\n");
            content.append("</html>\n");

        } else {
            // 默认文本格式
            content.append("文档导出报告\n");
            content.append("============\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("文档数量: ").append(documents.size()).append("\n\n");

            for (Map<String, Object> doc : documents) {
                content.append("文档ID: ").append(doc.get("document_id")).append("\n");
                content.append("标题: ").append(doc.get("title")).append("\n");
                content.append("作者: ").append(doc.get("author")).append("\n");
                content.append("描述: ").append(doc.get("description")).append("\n");
                content.append("页数: ").append(doc.get("page_count")).append("\n");
                content.append("创建时间: ").append(doc.get("created_at")).append("\n");
                content.append("------------------------\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return "pdf";
            case "docx": return "docx";
            case "xlsx": return "xlsx";
            case "csv": return "csv";
            case "json": return "json";
            case "html": return "html";
            case "txt": return "txt";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return MediaType.APPLICATION_PDF;
            case "docx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.wordprocessingml.document");
            case "xlsx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            case "csv": return MediaType.parseMediaType("text/csv");
            case "json": return MediaType.APPLICATION_JSON;
            case "html": return MediaType.TEXT_HTML;
            case "txt": return MediaType.TEXT_PLAIN;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return str.replace("\"", "\"\"");
        }
        return str;
    }

    // 转义HTML字符串
    private String escapeHtml(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
}
--- 结束文件: ExportDocuments.java ---

--- 开始文件: ExportHighlights.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportHighlights {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到高亮导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportHighlightsRequest {
        private int document_id;
        private String format = "json";

        public int getDocument_id() { return document_id; }
        public void setDocument_id(int document_id) { this.document_id = document_id; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "json", "csv", "pdf", "txt"
    ));

    @GetMapping("/documents/{documentId}/highlights")
    public ResponseEntity<?> exportHighlights(@PathVariable int documentId,
                                              @RequestParam(required = false, defaultValue = "json") String format,
                                              @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 构建请求对象
        ExportHighlightsRequest request = new ExportHighlightsRequest();
        request.setDocument_id(documentId);
        request.setFormat(format);

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 验证文档是否存在且属于当前用户
            String docSql = "SELECT document_id, title FROM documents WHERE document_id = ? AND user_id = ?";
            List<Map<String, Object>> documents = jdbcTemplate.queryForList(docSql, documentId, userId);

            if (documents.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("documentId", documentId);
                ErrorResponse errorResponse = new ErrorResponse("DOCUMENT_NOT_FOUND", "文档不存在或无权限访问", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            Map<String, Object> document = documents.get(0);
            String documentTitle = (String) document.get("title");

            // 4. 查询文档高亮
            String highlightsSql = "SELECT highlight_id, document_id, page_number, text_content, " +
                    "color, start_position, end_position, created_at " +
                    "FROM document_highlights " +
                    "WHERE document_id = ? AND user_id = ? " +
                    "ORDER BY page_number, start_position";

            List<Map<String, Object>> highlights = jdbcTemplate.queryForList(highlightsSql, documentId, userId);
            printQueryResult("高亮查询结果: " + highlights.size() + "条记录");

            // 5. 生成导出文件内容
            String fileContent = generateHighlightsContent(highlights, documentTitle, request.getFormat());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "highlights_" + documentId + "_" + timestamp + "." + extension;

            // 7. 记录导出历史
            String exportId = "export_highlights_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class, String.valueOf(documentId)
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("document_id", documentId);
            exportDetails.put("document_title", documentTitle);
            exportDetails.put("highlight_count", highlights.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "document_id", documentId,
                    "document_title", documentTitle,
                    "highlight_count", highlights.size(),
                    "filename", filename,
                    "file_size", fileBytes.length
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "HIGHLIGHTS",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("document_id", documentId);
            responseInfo.put("document_title", documentTitle);
            responseInfo.put("highlight_count", highlights.size());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("高亮导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            details.put("documentId", documentId);
            ErrorResponse errorResponse = new ErrorResponse("HIGHLIGHTS_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成高亮内容
    private String generateHighlightsContent(List<Map<String, Object>> highlights, String documentTitle, String format) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("type", "highlights");
                put("document_title", documentTitle);
                put("highlight_count", highlights.size());
                put("format", "json");
                put("version", "1.0");
            }});

            exportData.put("highlights", highlights);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"type\": \"highlights\",\n");
            content.append("    \"document_title\": \"").append(escapeJson(documentTitle)).append("\",\n");
            content.append("    \"highlight_count\": ").append(highlights.size()).append(",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\"\n");
            content.append("  },\n");
            content.append("  \"highlights\": [\n");

            for (int i = 0; i < highlights.size(); i++) {
                Map<String, Object> highlight = highlights.get(i);
                content.append("    {\n");
                content.append("      \"highlight_id\": ").append(highlight.get("highlight_id")).append(",\n");
                content.append("      \"document_id\": ").append(highlight.get("document_id")).append(",\n");
                content.append("      \"page_number\": ").append(highlight.get("page_number")).append(",\n");
                content.append("      \"text_content\": \"").append(escapeJson(highlight.get("text_content"))).append("\",\n");
                content.append("      \"color\": \"").append(escapeJson(highlight.get("color"))).append("\",\n");
                content.append("      \"start_position\": ").append(highlight.get("start_position")).append(",\n");
                content.append("      \"end_position\": ").append(highlight.get("end_position")).append(",\n");
                content.append("      \"created_at\": \"").append(highlight.get("created_at")).append("\"\n");
                content.append("    }");
                if (i < highlights.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式
            content.append("文档标题: ").append(documentTitle).append("\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("高亮数量: ").append(highlights.size()).append("\n\n");

            content.append("高亮ID,页码,文本内容,颜色,起始位置,结束位置,创建时间\n");

            for (Map<String, Object> highlight : highlights) {
                content.append(highlight.get("highlight_id")).append(",");
                content.append(highlight.get("page_number")).append(",");
                content.append(escapeCsv(highlight.get("text_content"))).append(",");
                content.append(escapeCsv(highlight.get("color"))).append(",");
                content.append(highlight.get("start_position")).append(",");
                content.append(highlight.get("end_position")).append(",");
                content.append(escapeCsv(highlight.get("created_at"))).append("\n");
            }

        } else {
            // 默认文本格式
            content.append("文档高亮导出报告\n");
            content.append("================\n\n");
            content.append("文档标题: ").append(documentTitle).append("\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("高亮数量: ").append(highlights.size()).append("\n");
            content.append("导出格式: ").append(format).append("\n\n");

            content.append("高亮列表:\n");
            content.append("--------\n");

            // 按页码分组
            Map<Integer, List<Map<String, Object>>> highlightsByPage = new HashMap<>();
            for (Map<String, Object> highlight : highlights) {
                int pageNumber = ((Number) highlight.get("page_number")).intValue();
                highlightsByPage.computeIfAbsent(pageNumber, k -> new ArrayList<>()).add(highlight);
            }

            // 按页码排序
            List<Integer> sortedPages = new ArrayList<>(highlightsByPage.keySet());
            Collections.sort(sortedPages);

            for (int pageNumber : sortedPages) {
                List<Map<String, Object>> pageHighlights = highlightsByPage.get(pageNumber);

                content.append("第 ").append(pageNumber).append(" 页 (").append(pageHighlights.size()).append(" 处高亮):\n");

                for (int i = 0; i < pageHighlights.size(); i++) {
                    Map<String, Object> highlight = pageHighlights.get(i);

                    content.append("  ").append(i + 1).append(". ");
                    content.append("[").append(highlight.get("color")).append("] ");
                    content.append(highlight.get("text_content")).append("\n");

                    if (highlight.get("created_at") != null) {
                        content.append("     创建时间: ").append(highlight.get("created_at")).append("\n");
                    }
                }

                content.append("\n");
            }

            // 添加颜色统计
            Map<String, Integer> colorStats = new HashMap<>();
            for (Map<String, Object> highlight : highlights) {
                String color = (String) highlight.get("color");
                colorStats.put(color, colorStats.getOrDefault(color, 0) + 1);
            }

            content.append("颜色统计:\n");
            content.append("--------\n");
            for (Map.Entry<String, Integer> entry : colorStats.entrySet()) {
                content.append(entry.getKey()).append(": ").append(entry.getValue()).append(" 处\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "json": return "json";
            case "csv": return "csv";
            case "pdf": return "pdf";
            case "txt": return "txt";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "json": return MediaType.APPLICATION_JSON;
            case "csv": return MediaType.parseMediaType("text/csv");
            case "pdf": return MediaType.APPLICATION_PDF;
            case "txt": return MediaType.TEXT_PLAIN;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }
}
--- 结束文件: ExportHighlights.java ---

--- 开始文件: ExportNotes.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportNotes {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到笔记导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportNotesRequest {
        private List<Integer> note_ids;
        private String format = "pdf";
        private Map<String, Object> template;

        public List<Integer> getNote_ids() { return note_ids; }
        public void setNote_ids(List<Integer> note_ids) { this.note_ids = note_ids; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "pdf", "html", "txt", "docx", "json"
    ));

    @PostMapping("/notes/batch")
    public ResponseEntity<?> exportNotes(@RequestBody ExportNotesRequest request,
                                         @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getNote_ids() == null || request.getNote_ids().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("note_ids", "笔记ID列表不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getNote_ids().size() > 200) {
                Map<String, Object> details = new HashMap<>();
                details.put("note_ids", "最多支持导出200个笔记");
                details.put("limit", 200);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 验证笔记是否存在且属于当前用户
            List<Integer> invalidNoteIds = new ArrayList<>();
            List<Integer> validNoteIds = new ArrayList<>();

            for (Integer noteId : request.getNote_ids()) {
                String noteSql = "SELECT note_id FROM document_notes WHERE note_id = ? AND user_id = ?";
                List<Map<String, Object>> notes = jdbcTemplate.queryForList(noteSql, noteId, userId);

                if (notes.isEmpty()) {
                    invalidNoteIds.add(noteId);
                } else {
                    validNoteIds.add(noteId);
                }
            }

            if (!invalidNoteIds.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("noteIds", invalidNoteIds);
                ErrorResponse errorResponse = new ErrorResponse("NOTES_NOT_FOUND", "部分笔记不存在或无权限访问", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 查询笔记详细信息
            String placeholders = String.join(",", Collections.nCopies(validNoteIds.size(), "?"));
            String notesSql = "SELECT n.note_id, n.document_id, d.title as document_title, " +
                    "n.page_number, n.content, n.highlight_id, " +
                    "n.created_at, n.updated_at " +
                    "FROM document_notes n " +
                    "LEFT JOIN documents d ON n.document_id = d.document_id " +
                    "WHERE n.note_id IN (" + placeholders + ") AND n.user_id = ? " +
                    "ORDER BY n.created_at DESC";

            List<Object> params = new ArrayList<>(validNoteIds);
            params.add(userId);

            List<Map<String, Object>> notes = jdbcTemplate.queryForList(notesSql, params.toArray());
            printQueryResult("笔记查询结果: " + notes.size() + "条记录");

            if (notes.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("noteIds", validNoteIds);
                ErrorResponse errorResponse = new ErrorResponse("NOTES_EXPORT_ERROR", "没有找到可导出的笔记", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 5. 生成导出文件内容
            String fileContent = generateNotesContent(notes, request.getFormat());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "notes_" + timestamp + "." + extension;

            // 7. 记录导出历史
            String exportId = "export_notes_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", validNoteIds.stream().map(String::valueOf).toArray(String[]::new))
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("item_count", notes.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "item_count", notes.size(),
                    "filename", filename,
                    "file_size", fileBytes.length
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "NOTES",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("note_count", notes.size());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("笔记导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("NOTES_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成笔记内容
    private String generateNotesContent(List<Map<String, Object>> notes, String format) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("type", "notes");
                put("count", notes.size());
                put("format", "json");
                put("version", "1.0");
            }});

            exportData.put("notes", notes);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"type\": \"notes\",\n");
            content.append("    \"count\": ").append(notes.size()).append(",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\"\n");
            content.append("  },\n");
            content.append("  \"notes\": [\n");

            for (int i = 0; i < notes.size(); i++) {
                Map<String, Object> note = notes.get(i);
                content.append("    {\n");
                content.append("      \"note_id\": ").append(note.get("note_id")).append(",\n");
                content.append("      \"document_id\": ").append(note.get("document_id")).append(",\n");
                content.append("      \"document_title\": \"").append(escapeJson(note.get("document_title"))).append("\",\n");
                content.append("      \"page_number\": ").append(note.get("page_number")).append(",\n");
                content.append("      \"content\": \"").append(escapeJson(note.get("content"))).append("\",\n");
                content.append("      \"created_at\": \"").append(note.get("created_at")).append("\",\n");
                content.append("      \"updated_at\": \"").append(note.get("updated_at")).append("\"\n");
                content.append("    }");
                if (i < notes.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("html")) {
            // HTML格式
            content.append("<!DOCTYPE html>\n");
            content.append("<html>\n");
            content.append("<head>\n");
            content.append("  <meta charset=\"UTF-8\">\n");
            content.append("  <title>笔记导出</title>\n");
            content.append("  <style>\n");
            content.append("    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }\n");
            content.append("    h1 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; }\n");
            content.append("    .note { border: 1px solid #ddd; margin: 15px 0; padding: 15px; border-radius: 5px; }\n");
            content.append("    .note-header { background-color: #f5f5f5; padding: 10px; margin: -15px -15px 15px -15px; border-radius: 5px 5px 0 0; }\n");
            content.append("    .note-title { font-weight: bold; color: #555; }\n");
            content.append("    .note-meta { color: #888; font-size: 0.9em; margin-top: 5px; }\n");
            content.append("    .note-content { margin-top: 15px; }\n");
            content.append("  </style>\n");
            content.append("</head>\n");
            content.append("<body>\n");
            content.append("  <h1>笔记导出</h1>\n");
            content.append("  <p>导出时间: ").append(LocalDateTime.now()).append("</p>\n");
            content.append("  <p>笔记数量: ").append(notes.size()).append("</p>\n");
            content.append("  <hr>\n");

            for (Map<String, Object> note : notes) {
                content.append("  <div class=\"note\">\n");
                content.append("    <div class=\"note-header\">\n");
                content.append("      <div class=\"note-title\">").append(escapeHtml(note.get("document_title"))).append("</div>\n");
                content.append("      <div class=\"note-meta\">\n");
                content.append("        第").append(note.get("page_number")).append("页 | ");
                content.append("        创建: ").append(note.get("created_at")).append(" | ");
                content.append("        更新: ").append(note.get("updated_at")).append("\n");
                content.append("      </div>\n");
                content.append("    </div>\n");
                content.append("    <div class=\"note-content\">\n");
                content.append("      ").append(escapeHtml(note.get("content"))).append("\n");
                content.append("    </div>\n");
                content.append("  </div>\n");
            }

            content.append("</body>\n");
            content.append("</html>\n");

        } else {
            // 默认文本格式
            content.append("笔记导出报告\n");
            content.append("============\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("笔记数量: ").append(notes.size()).append("\n");
            content.append("导出格式: ").append(format).append("\n\n");

            content.append("笔记列表:\n");
            content.append("--------\n");

            for (int i = 0; i < notes.size(); i++) {
                Map<String, Object> note = notes.get(i);
                content.append(i + 1).append(". ").append(note.get("document_title")).append("\n");
                content.append("   页码: 第").append(note.get("page_number")).append("页\n");
                content.append("   内容: ").append(note.get("content")).append("\n");
                content.append("   创建时间: ").append(note.get("created_at")).append("\n");
                content.append("   更新时间: ").append(note.get("updated_at")).append("\n");
                content.append("   -------------------------\n\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return "pdf";
            case "html": return "html";
            case "txt": return "txt";
            case "docx": return "docx";
            case "json": return "json";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return MediaType.APPLICATION_PDF;
            case "html": return MediaType.TEXT_HTML;
            case "txt": return MediaType.TEXT_PLAIN;
            case "docx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.wordprocessingml.document");
            case "json": return MediaType.APPLICATION_JSON;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义HTML字符串
    private String escapeHtml(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
}
--- 结束文件: ExportNotes.java ---

--- 开始文件: ExportReadingHistory.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportReadingHistory {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到阅读历史导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    @GetMapping("/reading-history")
    public ResponseEntity<?> exportReadingHistory(@RequestParam(required = false, defaultValue = "csv") String format,
                                                  @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest("format=" + format);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (!"csv".equalsIgnoreCase(format) && !"json".equalsIgnoreCase(format) && !"txt".equalsIgnoreCase(format)) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + format);
                details.put("supported_formats", Arrays.asList("csv", "json", "txt"));
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询阅读历史
            String historySql = "SELECT rh.history_id, rh.document_id, d.title as document_title, " +
                    "rh.start_time, rh.end_time, rh.duration_seconds, rh.pages_read, " +
                    "rh.created_at " +
                    "FROM reading_history rh " +
                    "JOIN documents d ON rh.document_id = d.document_id " +
                    "WHERE rh.user_id = ? " +
                    "ORDER BY rh.start_time DESC";

            List<Map<String, Object>> readingHistory = jdbcTemplate.queryForList(historySql, userId);
            printQueryResult("阅读历史查询结果: " + readingHistory.size() + "条记录");

            if (readingHistory.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("userId", userId);
                ErrorResponse errorResponse = new ErrorResponse("READING_HISTORY_NOT_FOUND", "没有找到阅读历史记录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 生成导出文件内容
            String fileContent = generateReadingHistoryContent(readingHistory, format);
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 5. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(format);
            String filename = "reading_history_" + timestamp + "." + extension;

            // 6. 记录导出历史
            String exportId = "export_reading_history_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?)";

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", format);
            exportDetails.put("item_count", readingHistory.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", format,
                    "item_count", readingHistory.size(),
                    "filename", filename,
                    "file_size", fileBytes.length
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "READING_HISTORY",
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 7. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(format));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", format);
            responseInfo.put("history_count", readingHistory.size());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("阅读历史导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("READING_HISTORY_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成阅读历史内容
    private String generateReadingHistoryContent(List<Map<String, Object>> readingHistory, String format) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("type", "reading_history");
                put("count", readingHistory.size());
                put("format", "json");
                put("version", "1.0");
            }});

            exportData.put("reading_history", readingHistory);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"type\": \"reading_history\",\n");
            content.append("    \"count\": ").append(readingHistory.size()).append(",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\"\n");
            content.append("  },\n");
            content.append("  \"reading_history\": [\n");

            for (int i = 0; i < readingHistory.size(); i++) {
                Map<String, Object> history = readingHistory.get(i);
                content.append("    {\n");
                content.append("      \"history_id\": ").append(history.get("history_id")).append(",\n");
                content.append("      \"document_id\": ").append(history.get("document_id")).append(",\n");
                content.append("      \"document_title\": \"").append(escapeJson(history.get("document_title"))).append("\",\n");
                content.append("      \"start_time\": \"").append(history.get("start_time")).append("\",\n");
                content.append("      \"end_time\": \"").append(history.get("end_time")).append("\",\n");
                content.append("      \"duration_seconds\": ").append(history.get("duration_seconds")).append(",\n");
                content.append("      \"pages_read\": ").append(history.get("pages_read")).append(",\n");
                content.append("      \"created_at\": \"").append(history.get("created_at")).append("\"\n");
                content.append("    }");
                if (i < readingHistory.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式
            content.append("阅读历史导出报告\n");
            content.append("================\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("记录数量: ").append(readingHistory.size()).append("\n\n");

            content.append("历史ID,文档ID,文档标题,开始时间,结束时间,持续时间(秒),阅读页数,创建时间\n");

            for (Map<String, Object> history : readingHistory) {
                content.append(history.get("history_id")).append(",");
                content.append(history.get("document_id")).append(",");
                content.append(escapeCsv(history.get("document_title"))).append(",");
                content.append(escapeCsv(history.get("start_time"))).append(",");
                content.append(escapeCsv(history.get("end_time"))).append(",");
                content.append(history.get("duration_seconds")).append(",");
                content.append(history.get("pages_read")).append(",");
                content.append(escapeCsv(history.get("created_at"))).append("\n");
            }

        } else {
            // 默认文本格式
            content.append("阅读历史导出报告\n");
            content.append("================\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("记录数量: ").append(readingHistory.size()).append("\n");
            content.append("导出格式: ").append(format).append("\n\n");

            content.append("阅读历史列表:\n");
            content.append("------------\n");

            for (int i = 0; i < readingHistory.size(); i++) {
                Map<String, Object> history = readingHistory.get(i);

                content.append(i + 1).append(". ").append(history.get("document_title")).append("\n");
                content.append("   开始时间: ").append(history.get("start_time")).append("\n");
                content.append("   结束时间: ").append(history.get("end_time")).append("\n");
                content.append("   持续时间: ").append(history.get("duration_seconds")).append(" 秒\n");
                content.append("   阅读页数: ").append(history.get("pages_read")).append(" 页\n");
                content.append("   记录时间: ").append(history.get("created_at")).append("\n");
                content.append("   -------------------------\n\n");
            }

            // 添加统计信息
            int totalPagesRead = readingHistory.stream()
                    .mapToInt(h -> ((Number) h.get("pages_read")).intValue())
                    .sum();

            int totalDuration = readingHistory.stream()
                    .mapToInt(h -> ((Number) h.get("duration_seconds")).intValue())
                    .sum();

            content.append("统计摘要:\n");
            content.append("--------\n");
            content.append("总阅读次数: ").append(readingHistory.size()).append(" 次\n");
            content.append("总阅读页数: ").append(totalPagesRead).append(" 页\n");
            content.append("总阅读时间: ").append(totalDuration).append(" 秒 (约 ");
            content.append(String.format("%.1f", totalDuration / 3600.0)).append(" 小时)\n");

            // 按文档统计
            Map<String, Integer> pagesByDocument = new HashMap<>();
            Map<String, Integer> durationByDocument = new HashMap<>();

            for (Map<String, Object> history : readingHistory) {
                String docTitle = (String) history.get("document_title");
                int pages = ((Number) history.get("pages_read")).intValue();
                int duration = ((Number) history.get("duration_seconds")).intValue();

                pagesByDocument.put(docTitle, pagesByDocument.getOrDefault(docTitle, 0) + pages);
                durationByDocument.put(docTitle, durationByDocument.getOrDefault(docTitle, 0) + duration);
            }

            content.append("\n按文档统计:\n");
            content.append("----------\n");
            for (Map.Entry<String, Integer> entry : pagesByDocument.entrySet()) {
                String docTitle = entry.getKey();
                int pages = entry.getValue();
                int duration = durationByDocument.getOrDefault(docTitle, 0);

                content.append(docTitle).append(": ");
                content.append(pages).append(" 页, ");
                content.append(duration).append(" 秒\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "csv": return "csv";
            case "json": return "json";
            case "txt": return "txt";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "csv": return MediaType.parseMediaType("text/csv");
            case "json": return MediaType.APPLICATION_JSON;
            case "txt": return MediaType.TEXT_PLAIN;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }
}
--- 结束文件: ExportReadingHistory.java ---

--- 开始文件: ExportReviews.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportReviews {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到复习记录导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportReviewsRequest {
        private List<Integer> review_ids;
        private String format = "csv";
        private Map<String, Object> template;
        private String date_range;

        public List<Integer> getReview_ids() { return review_ids; }
        public void setReview_ids(List<Integer> review_ids) { this.review_ids = review_ids; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }

        public String getDate_range() { return date_range; }
        public void setDate_range(String date_range) { this.date_range = date_range; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 复习会话信息DTO
    public static class ReviewSessionInfo {
        private int review_session_id;
        private int user_id;
        private LocalDateTime start_time;
        private LocalDateTime end_time;
        private int total_items;
        private int correct_count;
        private int wrong_count;
        private double accuracy;
        private String session_type;
        private LocalDateTime created_at;
        private List<ReviewItemInfo> review_items;

        // 构造函数
        public ReviewSessionInfo(int review_session_id, int user_id, LocalDateTime start_time,
                                 LocalDateTime end_time, int total_items, int correct_count,
                                 int wrong_count, double accuracy, String session_type, LocalDateTime created_at) {
            this.review_session_id = review_session_id;
            this.user_id = user_id;
            this.start_time = start_time;
            this.end_time = end_time;
            this.total_items = total_items;
            this.correct_count = correct_count;
            this.wrong_count = wrong_count;
            this.accuracy = accuracy;
            this.session_type = session_type;
            this.created_at = created_at;
            this.review_items = new ArrayList<>();
        }

        // getter和setter方法
        public int getReview_session_id() { return review_session_id; }
        public void setReview_session_id(int review_session_id) { this.review_session_id = review_session_id; }

        public int getUser_id() { return user_id; }
        public void setUser_id(int user_id) { this.user_id = user_id; }

        public LocalDateTime getStart_time() { return start_time; }
        public void setStart_time(LocalDateTime start_time) { this.start_time = start_time; }

        public LocalDateTime getEnd_time() { return end_time; }
        public void setEnd_time(LocalDateTime end_time) { this.end_time = end_time; }

        public int getTotal_items() { return total_items; }
        public void setTotal_items(int total_items) { this.total_items = total_items; }

        public int getCorrect_count() { return correct_count; }
        public void setCorrect_count(int correct_count) { this.correct_count = correct_count; }

        public int getWrong_count() { return wrong_count; }
        public void setWrong_count(int wrong_count) { this.wrong_count = wrong_count; }

        public double getAccuracy() { return accuracy; }
        public void setAccuracy(double accuracy) { this.accuracy = accuracy; }

        public String getSession_type() { return session_type; }
        public void setSession_type(String session_type) { this.session_type = session_type; }

        public LocalDateTime getCreated_at() { return created_at; }
        public void setCreated_at(LocalDateTime created_at) { this.created_at = created_at; }

        public List<ReviewItemInfo> getReview_items() { return review_items; }
        public void setReview_items(List<ReviewItemInfo> review_items) { this.review_items = review_items; }
    }

    // 复习项目信息DTO
    public static class ReviewItemInfo {
        private int review_item_id;
        private int review_session_id;
        private int user_vocabulary_id;
        private String word;
        private String answer;
        private boolean is_correct;
        private int response_time;
        private LocalDateTime created_at;

        public ReviewItemInfo(int review_item_id, int review_session_id, int user_vocabulary_id,
                              String word, String answer, boolean is_correct, int response_time, LocalDateTime created_at) {
            this.review_item_id = review_item_id;
            this.review_session_id = review_session_id;
            this.user_vocabulary_id = user_vocabulary_id;
            this.word = word;
            this.answer = answer;
            this.is_correct = is_correct;
            this.response_time = response_time;
            this.created_at = created_at;
        }

        // getter和setter方法
        public int getReview_item_id() { return review_item_id; }
        public void setReview_item_id(int review_item_id) { this.review_item_id = review_item_id; }

        public int getReview_session_id() { return review_session_id; }
        public void setReview_session_id(int review_session_id) { this.review_session_id = review_session_id; }

        public int getUser_vocabulary_id() { return user_vocabulary_id; }
        public void setUser_vocabulary_id(int user_vocabulary_id) { this.user_vocabulary_id = user_vocabulary_id; }

        public String getWord() { return word; }
        public void setWord(String word) { this.word = word; }

        public String getAnswer() { return answer; }
        public void setAnswer(String answer) { this.answer = answer; }

        public boolean isIs_correct() { return is_correct; }
        public void setIs_correct(boolean is_correct) { this.is_correct = is_correct; }

        public int getResponse_time() { return response_time; }
        public void setResponse_time(int response_time) { this.response_time = response_time; }

        public LocalDateTime getCreated_at() { return created_at; }
        public void setCreated_at(LocalDateTime created_at) { this.created_at = created_at; }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "csv", "json", "pdf", "xlsx"
    ));

    @PostMapping("/reviews/batch")
    public ResponseEntity<?> exportReviews(@RequestBody ExportReviewsRequest request,
                                           @RequestHeader(value = "Authorization", required = false) String authHeader) {
        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getReview_ids() == null || request.getReview_ids().isEmpty()) {
                // 如果没有提供review_ids，则根据date_range查询
                if (request.getDate_range() == null || request.getDate_range().isEmpty()) {
                    Map<String, Object> details = new HashMap<>();
                    details.put("review_ids", "复习记录ID列表不能为空");
                    details.put("date_range", "日期范围不能为空");
                    ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                    printResponse(errorResponse);
                    return ResponseEntity.badRequest().body(errorResponse);
                }
            }

            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询复习记录
            List<ReviewSessionInfo> reviewSessions = new ArrayList<>();

            if (request.getReview_ids() != null && !request.getReview_ids().isEmpty()) {
                // 根据提供的review_ids查询
                String placeholders = String.join(",", Collections.nCopies(request.getReview_ids().size(), "?"));

                // 查询复习会话基本信息
                String sessionSql = "SELECT rs.review_session_id, rs.user_id, rs.start_time, rs.end_time, " +
                        "rs.total_items, rs.correct_count, rs.wrong_count, rs.accuracy, " +
                        "rs.session_type, rs.created_at " +
                        "FROM review_sessions rs " +
                        "WHERE rs.review_session_id IN (" + placeholders + ") AND rs.user_id = ?";

                List<Object> params = new ArrayList<>(request.getReview_ids());
                params.add(userId);

                List<Map<String, Object>> sessionResults = jdbcTemplate.queryForList(sessionSql, params.toArray());
                printQueryResult("复习会话查询结果: " + sessionResults.size() + "条记录");

                // 处理每个复习会话
                for (Map<String, Object> session : sessionResults) {
                    int sessionId = (int) session.get("review_session_id");
                    int sessionUserId = (int) session.get("user_id");
                    LocalDateTime startTime = ((java.sql.Timestamp) session.get("start_time")).toLocalDateTime();
                    LocalDateTime endTime = session.get("end_time") != null ?
                            ((java.sql.Timestamp) session.get("end_time")).toLocalDateTime() : null;
                    int totalItems = (int) session.get("total_items");
                    int correctCount = (int) session.get("correct_count");
                    int wrongCount = (int) session.get("wrong_count");
                    double accuracy = (double) session.get("accuracy");
                    String sessionType = (String) session.get("session_type");
                    LocalDateTime createdAt = ((java.sql.Timestamp) session.get("created_at")).toLocalDateTime();

                    ReviewSessionInfo sessionInfo = new ReviewSessionInfo(
                            sessionId, sessionUserId, startTime, endTime, totalItems,
                            correctCount, wrongCount, accuracy, sessionType, createdAt
                    );

                    // 查询复习项目详情
                    String itemsSql = "SELECT ri.review_item_id, ri.review_session_id, ri.user_vocabulary_id, " +
                            "w.word, ri.user_answer as answer, ri.is_correct, " +
                            "ri.response_time, ri.created_at " +
                            "FROM review_items ri " +
                            "JOIN user_vocabulary uv ON ri.user_vocabulary_id = uv.user_vocabulary_id " +
                            "JOIN words w ON uv.word_id = w.word_id " +
                            "WHERE ri.review_session_id = ?";

                    List<Map<String, Object>> itemResults = jdbcTemplate.queryForList(itemsSql, sessionId);

                    for (Map<String, Object> item : itemResults) {
                        int itemId = (int) item.get("review_item_id");
                        int itemSessionId = (int) item.get("review_session_id");
                        int userVocabId = (int) item.get("user_vocabulary_id");
                        String word = (String) item.get("word");
                        String answer = (String) item.get("answer");
                        boolean isCorrect = (boolean) item.get("is_correct");
                        int responseTime = (int) item.get("response_time");
                        LocalDateTime itemCreatedAt = ((java.sql.Timestamp) item.get("created_at")).toLocalDateTime();

                        ReviewItemInfo itemInfo = new ReviewItemInfo(
                                itemId, itemSessionId, userVocabId, word, answer,
                                isCorrect, responseTime, itemCreatedAt
                        );

                        sessionInfo.getReview_items().add(itemInfo);
                    }

                    reviewSessions.add(sessionInfo);
                }
            } else {
                // 根据date_range查询
                String[] dateRange = request.getDate_range().split(",");
                if (dateRange.length != 2) {
                    Map<String, Object> details = new HashMap<>();
                    details.put("date_range", "日期范围格式错误，应为'开始日期,结束日期'");
                    ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                    printResponse(errorResponse);
                    return ResponseEntity.badRequest().body(errorResponse);
                }

                String startDate = dateRange[0].trim();
                String endDate = dateRange[1].trim();

                // 查询指定日期范围内的复习会话
                String sessionSql = "SELECT rs.review_session_id, rs.user_id, rs.start_time, rs.end_time, " +
                        "rs.total_items, rs.correct_count, rs.wrong_count, rs.accuracy, " +
                        "rs.session_type, rs.created_at " +
                        "FROM review_sessions rs " +
                        "WHERE rs.user_id = ? AND DATE(rs.created_at) BETWEEN ? AND ? " +
                        "ORDER BY rs.created_at DESC";

                List<Map<String, Object>> sessionResults = jdbcTemplate.queryForList(
                        sessionSql, userId, startDate, endDate
                );

                printQueryResult("日期范围复习会话查询结果: " + sessionResults.size() + "条记录");

                // 处理每个复习会话
                for (Map<String, Object> session : sessionResults) {
                    int sessionId = (int) session.get("review_session_id");
                    int sessionUserId = (int) session.get("user_id");
                    LocalDateTime startTime = ((java.sql.Timestamp) session.get("start_time")).toLocalDateTime();
                    LocalDateTime endTime = session.get("end_time") != null ?
                            ((java.sql.Timestamp) session.get("end_time")).toLocalDateTime() : null;
                    int totalItems = (int) session.get("total_items");
                    int correctCount = (int) session.get("correct_count");
                    int wrongCount = (int) session.get("wrong_count");
                    double accuracy = (double) session.get("accuracy");
                    String sessionType = (String) session.get("session_type");
                    LocalDateTime createdAt = ((java.sql.Timestamp) session.get("created_at")).toLocalDateTime();

                    ReviewSessionInfo sessionInfo = new ReviewSessionInfo(
                            sessionId, sessionUserId, startTime, endTime, totalItems,
                            correctCount, wrongCount, accuracy, sessionType, createdAt
                    );

                    // 查询复习项目详情
                    String itemsSql = "SELECT ri.review_item_id, ri.review_session_id, ri.user_vocabulary_id, " +
                            "w.word, ri.user_answer as answer, ri.is_correct, " +
                            "ri.response_time, ri.created_at " +
                            "FROM review_items ri " +
                            "JOIN user_vocabulary uv ON ri.user_vocabulary_id = uv.user_vocabulary_id " +
                            "JOIN words w ON uv.word_id = w.word_id " +
                            "WHERE ri.review_session_id = ?";

                    List<Map<String, Object>> itemResults = jdbcTemplate.queryForList(itemsSql, sessionId);

                    for (Map<String, Object> item : itemResults) {
                        int itemId = (int) item.get("review_item_id");
                        int itemSessionId = (int) item.get("review_session_id");
                        int userVocabId = (int) item.get("user_vocabulary_id");
                        String word = (String) item.get("word");
                        String answer = (String) item.get("answer");
                        boolean isCorrect = (boolean) item.get("is_correct");
                        int responseTime = (int) item.get("response_time");
                        LocalDateTime itemCreatedAt = ((java.sql.Timestamp) item.get("created_at")).toLocalDateTime();

                        ReviewItemInfo itemInfo = new ReviewItemInfo(
                                itemId, itemSessionId, userVocabId, word, answer,
                                isCorrect, responseTime, itemCreatedAt
                        );

                        sessionInfo.getReview_items().add(itemInfo);
                    }

                    reviewSessions.add(sessionInfo);
                }
            }

            if (reviewSessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("review_ids", request.getReview_ids());
                details.put("date_range", request.getDate_range());
                ErrorResponse errorResponse = new ErrorResponse("REVIEWS_NOT_FOUND", "没有找到可导出的复习记录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 生成导出文件内容
            String fileContent = generateExportContent(reviewSessions, request.getFormat());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 5. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "reviews_" + timestamp + "." + extension;

            // 6. 记录导出历史
            String exportId = "export_reviews_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            // 构建实体ID数组
            List<Integer> sessionIds = reviewSessions.stream()
                    .map(ReviewSessionInfo::getReview_session_id)
                    .collect(java.util.stream.Collectors.toList());

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", sessionIds.stream().map(String::valueOf).toArray(String[]::new))
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("session_count", reviewSessions.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);
            exportDetails.put("date_range", request.getDate_range());

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "session_count", reviewSessions.size(),
                    "filename", filename,
                    "file_size", fileBytes.length,
                    "date_range", request.getDate_range() != null ? request.getDate_range() : ""
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "REVIEWS",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 7. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("session_count", reviewSessions.size());
            responseInfo.put("total_items", reviewSessions.stream().mapToInt(ReviewSessionInfo::getTotal_items).sum());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("复习记录导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("REVIEWS_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成导出内容
    private String generateExportContent(List<ReviewSessionInfo> reviewSessions, String format) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("totalSessions", reviewSessions.size());
                put("totalItems", reviewSessions.stream().mapToInt(ReviewSessionInfo::getTotal_items).sum());
                put("format", "json");
                put("version", "1.0");
            }});

            List<Map<String, Object>> sessionsJsonList = new ArrayList<>();
            for (ReviewSessionInfo session : reviewSessions) {
                Map<String, Object> sessionMap = new HashMap<>();
                sessionMap.put("review_session_id", session.getReview_session_id());
                sessionMap.put("user_id", session.getUser_id());
                sessionMap.put("start_time", session.getStart_time().toString());
                sessionMap.put("end_time", session.getEnd_time() != null ? session.getEnd_time().toString() : null);
                sessionMap.put("total_items", session.getTotal_items());
                sessionMap.put("correct_count", session.getCorrect_count());
                sessionMap.put("wrong_count", session.getWrong_count());
                sessionMap.put("accuracy", session.getAccuracy());
                sessionMap.put("session_type", session.getSession_type());
                sessionMap.put("created_at", session.getCreated_at().toString());

                // 添加复习项目
                List<Map<String, Object>> itemsJsonList = new ArrayList<>();
                for (ReviewItemInfo item : session.getReview_items()) {
                    Map<String, Object> itemMap = new HashMap<>();
                    itemMap.put("review_item_id", item.getReview_item_id());
                    itemMap.put("review_session_id", item.getReview_session_id());
                    itemMap.put("user_vocabulary_id", item.getUser_vocabulary_id());
                    itemMap.put("word", item.getWord());
                    itemMap.put("answer", item.getAnswer());
                    itemMap.put("is_correct", item.isIs_correct());
                    itemMap.put("response_time", item.getResponse_time());
                    itemMap.put("created_at", item.getCreated_at().toString());
                    itemsJsonList.add(itemMap);
                }
                sessionMap.put("review_items", itemsJsonList);

                sessionsJsonList.add(sessionMap);
            }

            exportData.put("review_sessions", sessionsJsonList);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"totalSessions\": ").append(reviewSessions.size()).append(",\n");
            content.append("    \"totalItems\": ").append(reviewSessions.stream().mapToInt(ReviewSessionInfo::getTotal_items).sum()).append(",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\"\n");
            content.append("  },\n");
            content.append("  \"review_sessions\": [\n");

            for (int i = 0; i < reviewSessions.size(); i++) {
                ReviewSessionInfo session = reviewSessions.get(i);
                content.append("    {\n");
                content.append("      \"review_session_id\": ").append(session.getReview_session_id()).append(",\n");
                content.append("      \"user_id\": ").append(session.getUser_id()).append(",\n");
                content.append("      \"start_time\": \"").append(session.getStart_time()).append("\",\n");
                content.append("      \"end_time\": \"").append(session.getEnd_time() != null ? session.getEnd_time() : "").append("\",\n");
                content.append("      \"total_items\": ").append(session.getTotal_items()).append(",\n");
                content.append("      \"correct_count\": ").append(session.getCorrect_count()).append(",\n");
                content.append("      \"wrong_count\": ").append(session.getWrong_count()).append(",\n");
                content.append("      \"accuracy\": ").append(session.getAccuracy()).append(",\n");
                content.append("      \"session_type\": \"").append(escapeJson(session.getSession_type())).append("\",\n");
                content.append("      \"created_at\": \"").append(session.getCreated_at()).append("\"\n");
                content.append("    }");
                if (i < reviewSessions.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式 - 会话概要
            content.append("复习会话ID,用户ID,开始时间,结束时间,总项目数,正确数,错误数,正确率,会话类型,创建时间\n");
            for (ReviewSessionInfo session : reviewSessions) {
                content.append(session.getReview_session_id()).append(",");
                content.append(session.getUser_id()).append(",");
                content.append(escapeCsv(session.getStart_time().toString())).append(",");
                content.append(escapeCsv(session.getEnd_time() != null ? session.getEnd_time().toString() : "")).append(",");
                content.append(session.getTotal_items()).append(",");
                content.append(session.getCorrect_count()).append(",");
                content.append(session.getWrong_count()).append(",");
                content.append(String.format("%.2f", session.getAccuracy())).append(",");
                content.append(escapeCsv(session.getSession_type())).append(",");
                content.append(escapeCsv(session.getCreated_at().toString())).append("\n");
            }

            // 添加复习项目详情
            content.append("\n\n=== 复习项目详情 ===\n");
            content.append("复习项目ID,复习会话ID,用户词汇ID,单词,用户答案,是否正确,响应时间(秒),创建时间\n");
            for (ReviewSessionInfo session : reviewSessions) {
                for (ReviewItemInfo item : session.getReview_items()) {
                    content.append(item.getReview_item_id()).append(",");
                    content.append(item.getReview_session_id()).append(",");
                    content.append(item.getUser_vocabulary_id()).append(",");
                    content.append(escapeCsv(item.getWord())).append(",");
                    content.append(escapeCsv(item.getAnswer())).append(",");
                    content.append(item.isIs_correct() ? "是" : "否").append(",");
                    content.append(item.getResponse_time()).append(",");
                    content.append(escapeCsv(item.getCreated_at().toString())).append("\n");
                }
            }

            // 添加统计摘要
            content.append("\n\n=== 统计摘要 ===\n");
            content.append("统计项,数值\n");
            content.append("总复习会话数,").append(reviewSessions.size()).append("\n");

            int totalItems = reviewSessions.stream().mapToInt(ReviewSessionInfo::getTotal_items).sum();
            int totalCorrect = reviewSessions.stream().mapToInt(ReviewSessionInfo::getCorrect_count).sum();
            int totalWrong = reviewSessions.stream().mapToInt(ReviewSessionInfo::getWrong_count).sum();
            double overallAccuracy = totalItems > 0 ? (totalCorrect * 100.0 / totalItems) : 0.0;

            content.append("总复习项目数,").append(totalItems).append("\n");
            content.append("总正确数,").append(totalCorrect).append("\n");
            content.append("总错误数,").append(totalWrong).append("\n");
            content.append("整体正确率,").append(String.format("%.2f", overallAccuracy)).append("%\n");

            // 按会话类型统计
            Map<String, Integer> typeCount = new HashMap<>();
            Map<String, Integer> typeItems = new HashMap<>();
            Map<String, Integer> typeCorrect = new HashMap<>();

            for (ReviewSessionInfo session : reviewSessions) {
                String type = session.getSession_type();
                typeCount.put(type, typeCount.getOrDefault(type, 0) + 1);
                typeItems.put(type, typeItems.getOrDefault(type, 0) + session.getTotal_items());
                typeCorrect.put(type, typeCorrect.getOrDefault(type, 0) + session.getCorrect_count());
            }

            content.append("\n按会话类型统计:\n");
            content.append("会话类型,会话数,项目数,正确数,正确率\n");
            for (Map.Entry<String, Integer> entry : typeCount.entrySet()) {
                String type = entry.getKey();
                int sessionsCount = entry.getValue();
                int itemsCount = typeItems.getOrDefault(type, 0);
                int correctCount = typeCorrect.getOrDefault(type, 0);
                double typeAccuracy = itemsCount > 0 ? (correctCount * 100.0 / itemsCount) : 0.0;

                content.append(escapeCsv(type)).append(",");
                content.append(sessionsCount).append(",");
                content.append(itemsCount).append(",");
                content.append(correctCount).append(",");
                content.append(String.format("%.2f", typeAccuracy)).append("%\n");
            }

        } else {
            // 默认文本格式（用于pdf和txt）
            content.append("复习记录导出报告\n");
            content.append("================\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("复习会话数: ").append(reviewSessions.size()).append("\n");
            content.append("导出格式: ").append(format).append("\n\n");

            // 总体统计
            int totalItems = reviewSessions.stream().mapToInt(ReviewSessionInfo::getTotal_items).sum();
            int totalCorrect = reviewSessions.stream().mapToInt(ReviewSessionInfo::getCorrect_count).sum();
            int totalWrong = reviewSessions.stream().mapToInt(ReviewSessionInfo::getWrong_count).sum();
            double overallAccuracy = totalItems > 0 ? (totalCorrect * 100.0 / totalItems) : 0.0;

            content.append("总体统计:\n");
            content.append("--------\n");
            content.append("总复习项目数: ").append(totalItems).append("\n");
            content.append("总正确数: ").append(totalCorrect).append("\n");
            content.append("总错误数: ").append(totalWrong).append("\n");
            content.append("整体正确率: ").append(String.format("%.2f", overallAccuracy)).append("%\n\n");

            content.append("复习会话列表:\n");
            content.append("------------\n");

            for (int i = 0; i < reviewSessions.size(); i++) {
                ReviewSessionInfo session = reviewSessions.get(i);
                content.append(i + 1).append(". 会话ID: ").append(session.getReview_session_id()).append("\n");
                content.append("   开始时间: ").append(session.getStart_time()).append("\n");
                content.append("   结束时间: ").append(session.getEnd_time() != null ? session.getEnd_time() : "进行中").append("\n");
                content.append("   会话类型: ").append(session.getSession_type()).append("\n");
                content.append("   项目总数: ").append(session.getTotal_items()).append("\n");
                content.append("   正确数: ").append(session.getCorrect_count()).append(" | ");
                content.append("错误数: ").append(session.getWrong_count()).append("\n");
                content.append("   正确率: ").append(String.format("%.2f", session.getAccuracy())).append("%\n");
                content.append("   创建时间: ").append(session.getCreated_at()).append("\n");

                // 显示前3个复习项目
                if (!session.getReview_items().isEmpty()) {
                    content.append("   复习项目:\n");
                    int limit = Math.min(3, session.getReview_items().size());
                    for (int j = 0; j < limit; j++) {
                        ReviewItemInfo item = session.getReview_items().get(j);
                        content.append("     - ").append(item.getWord()).append(": ");
                        content.append(item.getAnswer()).append(" (");
                        content.append(item.isIs_correct() ? "正确" : "错误").append(")\n");
                    }
                    if (session.getReview_items().size() > 3) {
                        content.append("     ... 还有").append(session.getReview_items().size() - 3).append("个项目\n");
                    }
                }

                content.append("\n");
            }

            // 按会话类型统计
            Map<String, Integer> typeCount = new HashMap<>();
            Map<String, Integer> typeItems = new HashMap<>();
            Map<String, Integer> typeCorrect = new HashMap<>();

            for (ReviewSessionInfo session : reviewSessions) {
                String type = session.getSession_type();
                typeCount.put(type, typeCount.getOrDefault(type, 0) + 1);
                typeItems.put(type, typeItems.getOrDefault(type, 0) + session.getTotal_items());
                typeCorrect.put(type, typeCorrect.getOrDefault(type, 0) + session.getCorrect_count());
            }

            content.append("\n按会话类型统计:\n");
            content.append("------------\n");
            for (Map.Entry<String, Integer> entry : typeCount.entrySet()) {
                String type = entry.getKey();
                int sessionsCount = entry.getValue();
                int itemsCount = typeItems.getOrDefault(type, 0);
                int correctCount = typeCorrect.getOrDefault(type, 0);
                double typeAccuracy = itemsCount > 0 ? (correctCount * 100.0 / itemsCount) : 0.0;

                content.append("类型: ").append(type).append("\n");
                content.append("  会话数: ").append(sessionsCount).append("\n");
                content.append("  项目数: ").append(itemsCount).append("\n");
                content.append("  正确率: ").append(String.format("%.2f", typeAccuracy)).append("%\n\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "csv": return "csv";
            case "json": return "json";
            case "pdf": return "pdf";
            case "xlsx": return "xlsx";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "csv": return MediaType.parseMediaType("text/csv");
            case "json": return MediaType.APPLICATION_JSON;
            case "pdf": return MediaType.APPLICATION_PDF;
            case "xlsx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }
}
--- 结束文件: ExportReviews.java ---

--- 开始文件: ExportStatistics.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportStatistics {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到学习统计导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportStatisticsRequest {
        private String format = "pdf";
        private Map<String, Object> template;
        private String date_range = "all";
        private boolean include_charts = true;

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }

        public String getDate_range() { return date_range; }
        public void setDate_range(String date_range) { this.date_range = date_range; }

        public boolean isInclude_charts() { return include_charts; }
        public void setInclude_charts(boolean include_charts) { this.include_charts = include_charts; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "pdf", "xlsx", "csv", "json"
    ));

    @GetMapping("/statistics")
    public ResponseEntity<?> exportStatistics(@RequestParam(required = false) String format,
                                              @RequestParam(required = false) String date_range,
                                              @RequestParam(required = false, defaultValue = "true") boolean include_charts,
                                              @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 构建请求对象
        ExportStatisticsRequest request = new ExportStatisticsRequest();
        if (format != null) request.setFormat(format);
        if (date_range != null) request.setDate_range(date_range);
        request.setInclude_charts(include_charts);

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询学习统计数据
            Map<String, Object> statistics = new HashMap<>();

            // 3.1 查询每日学习统计
            String dailyStatsSql = "SELECT date, total_study_time, words_studied, documents_read, " +
                    "notes_created, highlights_created FROM daily_learning_stats " +
                    "WHERE user_id = ? ";

            List<Object> params = new ArrayList<>();
            params.add(userId);

            // 根据日期范围过滤
            if (!"all".equals(request.getDate_range())) {
                String[] dateRange = request.getDate_range().split(",");
                if (dateRange.length == 2) {
                    dailyStatsSql += "AND date BETWEEN ? AND ? ";
                    params.add(dateRange[0].trim());
                    params.add(dateRange[1].trim());
                }
            }

            dailyStatsSql += "ORDER BY date DESC LIMIT 30";

            List<Map<String, Object>> dailyStats = jdbcTemplate.queryForList(dailyStatsSql, params.toArray());
            statistics.put("daily_stats", dailyStats);
            printQueryResult("每日学习统计: " + dailyStats.size() + "条记录");

            // 3.2 查询词汇掌握统计
            String vocabStatsSql = "SELECT mastery_level, COUNT(*) as count FROM user_vocabulary " +
                    "WHERE user_id = ? GROUP BY mastery_level ORDER BY mastery_level";
            List<Map<String, Object>> vocabStats = jdbcTemplate.queryForList(vocabStatsSql, userId);
            statistics.put("vocabulary_stats", vocabStats);

            // 3.3 查询学习成就
            String achievementsSql = "SELECT a.achievement_id, a.name, a.description, a.icon_url, " +
                    "a.points, ua.unlocked_at FROM user_achievements ua " +
                    "JOIN learning_achievements a ON ua.achievement_id = a.achievement_id " +
                    "WHERE ua.user_id = ? ORDER BY ua.unlocked_at DESC";
            List<Map<String, Object>> achievements = jdbcTemplate.queryForList(achievementsSql, userId);
            statistics.put("achievements", achievements);

            // 3.4 查询复习统计
            String reviewStatsSql = "SELECT COUNT(*) as total_sessions, SUM(total_items) as total_items, " +
                    "SUM(correct_count) as total_correct, AVG(accuracy) as avg_accuracy " +
                    "FROM review_sessions WHERE user_id = ?";
            List<Map<String, Object>> reviewStats = jdbcTemplate.queryForList(reviewStatsSql, userId);
            statistics.put("review_stats", reviewStats);

            // 3.5 查询阅读统计
            String readingStatsSql = "SELECT COUNT(*) as total_documents, SUM(page_count) as total_pages, " +
                    "AVG(reading_progress) as avg_progress FROM documents " +
                    "WHERE user_id = ?";
            List<Map<String, Object>> readingStats = jdbcTemplate.queryForList(readingStatsSql, userId);
            statistics.put("reading_stats", readingStats);

            // 3.6 查询学习趋势（最近7天）
            String trendSql = "SELECT date, words_studied FROM daily_learning_stats " +
                    "WHERE user_id = ? AND date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY) " +
                    "ORDER BY date";
            List<Map<String, Object>> learningTrend = jdbcTemplate.queryForList(trendSql, userId);
            statistics.put("learning_trend", learningTrend);

            // 4. 生成导出文件内容
            String fileContent = generateExportContent(statistics, request.getFormat(), request.isInclude_charts());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 5. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "learning_statistics_" + timestamp + "." + extension;

            // 6. 记录导出历史
            String exportId = "export_stats_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?)";

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("date_range", request.getDate_range());
            exportDetails.put("include_charts", request.isInclude_charts());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "date_range", request.getDate_range(),
                    "include_charts", request.isInclude_charts(),
                    "filename", filename,
                    "file_size", fileBytes.length
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "STATISTICS",
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 7. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("date_range", request.getDate_range());
            responseInfo.put("include_charts", request.isInclude_charts());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("学习统计导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("STATISTICS_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成导出内容
    private String generateExportContent(Map<String, Object> statistics, String format, boolean includeCharts) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("format", "json");
                put("version", "1.0");
                put("includeCharts", includeCharts);
            }});

            exportData.put("statistics", statistics);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\",\n");
            content.append("    \"includeCharts\": ").append(includeCharts).append("\n");
            content.append("  },\n");
            content.append("  \"statistics\": {\n");

            // 添加每日统计
            List<Map<String, Object>> dailyStats = (List<Map<String, Object>>) statistics.get("daily_stats");
            content.append("    \"daily_stats\": [\n");
            for (int i = 0; i < dailyStats.size(); i++) {
                Map<String, Object> stat = dailyStats.get(i);
                content.append("      {\n");
                content.append("        \"date\": \"").append(stat.get("date")).append("\",\n");
                content.append("        \"total_study_time\": ").append(stat.get("total_study_time")).append(",\n");
                content.append("        \"words_studied\": ").append(stat.get("words_studied")).append(",\n");
                content.append("        \"documents_read\": ").append(stat.get("documents_read")).append(",\n");
                content.append("        \"notes_created\": ").append(stat.get("notes_created")).append(",\n");
                content.append("        \"highlights_created\": ").append(stat.get("highlights_created")).append("\n");
                content.append("      }");
                if (i < dailyStats.size() - 1) content.append(",");
                content.append("\n");
            }
            content.append("    ]\n");

            content.append("  }\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式
            content.append("学习统计报告\n");
            content.append("============\n\n");

            // 每日学习统计
            content.append("每日学习统计:\n");
            content.append("日期,学习时长(分钟),学习单词数,阅读文档数,创建笔记数,创建高亮数\n");

            List<Map<String, Object>> dailyStats = (List<Map<String, Object>>) statistics.get("daily_stats");
            for (Map<String, Object> stat : dailyStats) {
                content.append(escapeCsv(stat.get("date"))).append(",");
                content.append(stat.get("total_study_time")).append(",");
                content.append(stat.get("words_studied")).append(",");
                content.append(stat.get("documents_read")).append(",");
                content.append(stat.get("notes_created")).append(",");
                content.append(stat.get("highlights_created")).append("\n");
            }

            content.append("\n词汇掌握统计:\n");
            content.append("掌握等级,词汇数量\n");

            List<Map<String, Object>> vocabStats = (List<Map<String, Object>>) statistics.get("vocabulary_stats");
            for (Map<String, Object> stat : vocabStats) {
                content.append(stat.get("mastery_level")).append(",");
                content.append(stat.get("count")).append("\n");
            }

        } else {
            // 默认文本格式
            content.append("学习统计报告\n");
            content.append("============\n\n");
            content.append("生成时间: ").append(LocalDateTime.now()).append("\n");
            content.append("报告格式: ").append(format).append("\n");
            content.append("包含图表: ").append(includeCharts ? "是" : "否").append("\n\n");

            // 总体统计
            content.append("总体学习概况:\n");
            content.append("------------\n");

            List<Map<String, Object>> dailyStats = (List<Map<String, Object>>) statistics.get("daily_stats");
            List<Map<String, Object>> vocabStats = (List<Map<String, Object>>) statistics.get("vocabulary_stats");
            List<Map<String, Object>> reviewStats = (List<Map<String, Object>>) statistics.get("review_stats");
            List<Map<String, Object>> readingStats = (List<Map<String, Object>>) statistics.get("reading_stats");

            // 计算总学习时长
            int totalStudyTime = dailyStats.stream()
                    .mapToInt(stat -> stat.get("total_study_time") != null ? ((Number) stat.get("total_study_time")).intValue() : 0)
                    .sum();

            // 计算总学习单词数
            int totalWordsStudied = dailyStats.stream()
                    .mapToInt(stat -> stat.get("words_studied") != null ? ((Number) stat.get("words_studied")).intValue() : 0)
                    .sum();

            content.append("统计天数: ").append(dailyStats.size()).append("天\n");
            content.append("总学习时长: ").append(totalStudyTime).append("分钟\n");
            content.append("总学习单词数: ").append(totalWordsStudied).append("个\n");

            if (!reviewStats.isEmpty()) {
                Map<String, Object> review = reviewStats.get(0);
                content.append("总复习会话: ").append(review.get("total_sessions")).append("次\n");
                content.append("总复习项目: ").append(review.get("total_items")).append("个\n");
                content.append("平均正确率: ").append(String.format("%.2f", review.get("avg_accuracy"))).append("%\n");
            }

            if (!readingStats.isEmpty()) {
                Map<String, Object> reading = readingStats.get(0);
                content.append("总阅读文档: ").append(reading.get("total_documents")).append("个\n");
                content.append("总阅读页数: ").append(reading.get("total_pages")).append("页\n");
                content.append("平均阅读进度: ").append(String.format("%.2f", reading.get("avg_progress"))).append("%\n");
            }

            content.append("\n词汇掌握分布:\n");
            content.append("------------\n");

            for (Map<String, Object> vocab : vocabStats) {
                int level = ((Number) vocab.get("mastery_level")).intValue();
                int count = ((Number) vocab.get("count")).intValue();
                content.append("掌握度").append(level).append("%: ").append(count).append("个词汇\n");
            }

            // 最近学习趋势
            content.append("\n最近学习趋势（最近7天）:\n");
            content.append("--------------------\n");

            List<Map<String, Object>> learningTrend = (List<Map<String, Object>>) statistics.get("learning_trend");
            for (Map<String, Object> trend : learningTrend) {
                content.append(trend.get("date")).append(": ").append(trend.get("words_studied")).append("个单词\n");
            }

            // 学习成就
            List<Map<String, Object>> achievements = (List<Map<String, Object>>) statistics.get("achievements");
            if (!achievements.isEmpty()) {
                content.append("\n已获得的学习成就:\n");
                content.append("----------------\n");

                for (Map<String, Object> achievement : achievements) {
                    content.append("• ").append(achievement.get("name")).append("\n");
                    content.append("  ").append(achievement.get("description")).append("\n");
                    content.append("  获得时间: ").append(achievement.get("unlocked_at")).append("\n\n");
                }
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return "pdf";
            case "xlsx": return "xlsx";
            case "csv": return "csv";
            case "json": return "json";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "pdf": return MediaType.APPLICATION_PDF;
            case "xlsx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            case "csv": return MediaType.parseMediaType("text/csv");
            case "json": return MediaType.APPLICATION_JSON;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }
}
--- 结束文件: ExportStatistics.java ---

--- 开始文件: ExportStudyPlan.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportStudyPlan {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到学习计划导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportStudyPlanRequest {
        private String start_date;
        private String end_date;
        private int daily_goal = 20;
        private boolean include_progress = true;

        public String getStart_date() { return start_date; }
        public void setStart_date(String start_date) { this.start_date = start_date; }

        public String getEnd_date() { return end_date; }
        public void setEnd_date(String end_date) { this.end_date = end_date; }

        public int getDaily_goal() { return daily_goal; }
        public void setDaily_goal(int daily_goal) { this.daily_goal = daily_goal; }

        public boolean isInclude_progress() { return include_progress; }
        public void setInclude_progress(boolean include_progress) { this.include_progress = include_progress; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @PostMapping("/study-plan")
    public ResponseEntity<?> exportStudyPlan(@RequestBody ExportStudyPlanRequest request,
                                             @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getStart_date() == null || request.getStart_date().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("start_date", "开始日期不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getEnd_date() == null || request.getEnd_date().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("end_date", "结束日期不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getDaily_goal() <= 0 || request.getDaily_goal() > 100) {
                Map<String, Object> details = new HashMap<>();
                details.put("daily_goal", "每日目标应在1-100之间");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 查询需要复习的词汇
            LocalDateTime startDate = LocalDateTime.parse(request.getStart_date() + "T00:00:00");
            LocalDateTime endDate = LocalDateTime.parse(request.getEnd_date() + "T23:59:59");

            // 查询所有需要复习的词汇
            String dueWordsSql = "SELECT uv.user_vocabulary_id, w.word, w.phonetic, wd.definition as meaning, " +
                    "uv.mastery_level, uv.next_review_date " +
                    "FROM user_vocabulary uv " +
                    "JOIN words w ON uv.word_id = w.word_id " +
                    "LEFT JOIN word_definitions wd ON w.word_id = wd.word_id AND wd.is_primary = 1 " +
                    "WHERE uv.user_id = ? AND uv.next_review_date IS NOT NULL " +
                    "AND uv.next_review_date BETWEEN ? AND ? " +
                    "ORDER BY uv.next_review_date";

            List<Map<String, Object>> dueWords = jdbcTemplate.queryForList(
                    dueWordsSql, userId, startDate, endDate
            );

            printQueryResult("需要复习的词汇: " + dueWords.size() + "条记录");

            // 4. 生成学习计划
            Map<String, List<Map<String, Object>>> dailyPlan = generateDailyPlan(dueWords, request.getDaily_goal(), startDate, endDate);

            // 5. 生成导出文件内容
            String fileContent = generateStudyPlanContent(dailyPlan, request);
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String filename = "study_plan_" + timestamp + ".txt";

            // 7. 记录导出历史
            String exportId = "export_study_plan_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?)";

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", "text");
            exportDetails.put("start_date", request.getStart_date());
            exportDetails.put("end_date", request.getEnd_date());
            exportDetails.put("daily_goal", request.getDaily_goal());
            exportDetails.put("total_words", dueWords.size());
            exportDetails.put("plan_days", dailyPlan.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", "text",
                    "start_date", request.getStart_date(),
                    "end_date", request.getEnd_date(),
                    "daily_goal", request.getDaily_goal(),
                    "total_words", dueWords.size(),
                    "plan_days", dailyPlan.size(),
                    "filename", filename,
                    "file_size", fileBytes.length
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "STUDY_PLAN",
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.TEXT_PLAIN);
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("start_date", request.getStart_date());
            responseInfo.put("end_date", request.getEnd_date());
            responseInfo.put("daily_goal", request.getDaily_goal());
            responseInfo.put("total_words", dueWords.size());
            responseInfo.put("plan_days", dailyPlan.size());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("学习计划导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("STUDY_PLAN_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成每日学习计划
    private Map<String, List<Map<String, Object>>> generateDailyPlan(List<Map<String, Object>> dueWords, int dailyGoal,
                                                                     LocalDateTime startDate, LocalDateTime endDate) {
        Map<String, List<Map<String, Object>>> dailyPlan = new LinkedHashMap<>();

        // 按复习日期分组
        Map<String, List<Map<String, Object>>> wordsByDate = new HashMap<>();

        for (Map<String, Object> word : dueWords) {
            LocalDateTime reviewDate = ((java.sql.Timestamp) word.get("next_review_date")).toLocalDateTime();
            String dateKey = reviewDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));

            if (!wordsByDate.containsKey(dateKey)) {
                wordsByDate.put(dateKey, new ArrayList<>());
            }
            wordsByDate.get(dateKey).add(word);
        }

        // 生成日期范围内的计划
        LocalDateTime currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            String dateKey = currentDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));

            List<Map<String, Object>> dayWords = new ArrayList<>();

            // 添加当天需要复习的词汇
            if (wordsByDate.containsKey(dateKey)) {
                List<Map<String, Object>> dueToday = wordsByDate.get(dateKey);

                // 如果当天词汇超过每日目标，按优先级排序
                if (dueToday.size() > dailyGoal) {
                    // 按掌握程度排序（掌握度低的优先）
                    dueToday.sort((a, b) -> {
                        int masteryA = ((Number) a.get("mastery_level")).intValue();
                        int masteryB = ((Number) b.get("mastery_level")).intValue();
                        return Integer.compare(masteryA, masteryB);
                    });

                    // 取前dailyGoal个
                    dayWords.addAll(dueToday.subList(0, Math.min(dailyGoal, dueToday.size())));
                } else {
                    dayWords.addAll(dueToday);
                }
            }

            dailyPlan.put(dateKey, dayWords);
            currentDate = currentDate.plusDays(1);
        }

        return dailyPlan;
    }

    // 生成学习计划内容
    private String generateStudyPlanContent(Map<String, List<Map<String, Object>>> dailyPlan, ExportStudyPlanRequest request) {
        StringBuilder content = new StringBuilder();

        content.append("学习计划\n");
        content.append("========\n\n");
        content.append("计划周期: ").append(request.getStart_date()).append(" 至 ").append(request.getEnd_date()).append("\n");
        content.append("每日目标: ").append(request.getDaily_goal()).append(" 个词汇\n");
        content.append("生成时间: ").append(LocalDateTime.now()).append("\n\n");

        int totalWords = 0;
        int planDays = dailyPlan.size();

        content.append("每日学习安排:\n");
        content.append("------------\n\n");

        for (Map.Entry<String, List<Map<String, Object>>> entry : dailyPlan.entrySet()) {
            String date = entry.getKey();
            List<Map<String, Object>> words = entry.getValue();

            content.append(date).append(" (").append(words.size()).append(" 个词汇):\n");

            if (words.isEmpty()) {
                content.append("  无需要复习的词汇\n\n");
                continue;
            }

            for (int i = 0; i < words.size(); i++) {
                Map<String, Object> word = words.get(i);
                content.append("  ").append(i + 1).append(". ").append(word.get("word")).append(" ");

                if (word.get("phonetic") != null && !((String) word.get("phonetic")).isEmpty()) {
                    content.append("[").append(word.get("phonetic")).append("] ");
                }

                if (word.get("part_of_speech") != null && !((String) word.get("part_of_speech")).isEmpty()) {
                    content.append("(").append(word.get("part_of_speech")).append(") ");
                }

                content.append("\n");

                if (word.get("meaning") != null) {
                    content.append("     释义: ").append(word.get("meaning")).append("\n");
                }

                if (word.get("mastery_level") != null) {
                    content.append("     掌握度: ").append(word.get("mastery_level")).append("%\n");
                }
            }

            content.append("\n");
            totalWords += words.size();
        }

        content.append("计划总结:\n");
        content.append("--------\n");
        content.append("总计划天数: ").append(planDays).append(" 天\n");
        content.append("总复习词汇: ").append(totalWords).append(" 个\n");
        content.append("平均每日: ").append(String.format("%.1f", (double) totalWords / planDays)).append(" 个词汇\n");

        if (request.isInclude_progress()) {
            content.append("\n进度建议:\n");
            content.append("--------\n");

            if (totalWords == 0) {
                content.append("当前没有需要复习的词汇，可以学习新词汇。\n");
            } else if (totalWords <= request.getDaily_goal() * planDays / 2) {
                content.append("复习任务较轻，建议每天额外学习 ").append(request.getDaily_goal() - (totalWords / planDays)).append(" 个新词汇。\n");
            } else if (totalWords <= request.getDaily_goal() * planDays) {
                content.append("复习任务适中，按计划完成即可。\n");
            } else {
                content.append("复习任务较重，建议适当增加每日学习时间。\n");
            }
        }

        return content.toString();
    }
}
--- 结束文件: ExportStudyPlan.java ---

--- 开始文件: ExportToAnki.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportToAnki {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到Anki导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportToAnkiRequest {
        private List<Integer> vocabulary_ids;
        private String deck_name = "语言学习";
        private boolean include_audio = true;
        private boolean include_images = true;

        public List<Integer> getVocabulary_ids() { return vocabulary_ids; }
        public void setVocabulary_ids(List<Integer> vocabulary_ids) { this.vocabulary_ids = vocabulary_ids; }

        public String getDeck_name() { return deck_name; }
        public void setDeck_name(String deck_name) { this.deck_name = deck_name; }

        public boolean isInclude_audio() { return include_audio; }
        public void setInclude_audio(boolean include_audio) { this.include_audio = include_audio; }

        public boolean isInclude_images() { return include_images; }
        public void setInclude_images(boolean include_images) { this.include_images = include_images; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @PostMapping("/anki")
    public ResponseEntity<?> exportToAnki(@RequestBody ExportToAnkiRequest request,
                                          @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getVocabulary_ids() == null || request.getVocabulary_ids().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabulary_ids", "词汇ID列表不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getVocabulary_ids().size() > 500) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabulary_ids", "最多支持导出500个词汇");
                details.put("limit", 500);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 验证词汇是否存在且属于当前用户
            List<Integer> invalidVocabIds = new ArrayList<>();
            List<Integer> validVocabIds = new ArrayList<>();

            for (Integer vocabId : request.getVocabulary_ids()) {
                String vocabSql = "SELECT user_vocabulary_id FROM user_vocabulary WHERE user_vocabulary_id = ? AND user_id = ?";
                List<Map<String, Object>> vocabs = jdbcTemplate.queryForList(vocabSql, vocabId, userId);

                if (vocabs.isEmpty()) {
                    invalidVocabIds.add(vocabId);
                } else {
                    validVocabIds.add(vocabId);
                }
            }

            if (!invalidVocabIds.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabularyIds", invalidVocabIds);
                ErrorResponse errorResponse = new ErrorResponse("VOCABULARY_NOT_FOUND", "部分词汇不存在或无权限访问", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 查询词汇信息
            String placeholders = String.join(",", Collections.nCopies(validVocabIds.size(), "?"));
            String vocabSql = "SELECT uv.user_vocabulary_id, w.word, w.phonetic, wd.definition as meaning, " +
                    "w.part_of_speech, we.example_sentence, we.translation " +
                    "FROM user_vocabulary uv " +
                    "JOIN words w ON uv.word_id = w.word_id " +
                    "LEFT JOIN word_definitions wd ON w.word_id = wd.word_id AND wd.is_primary = 1 " +
                    "LEFT JOIN word_examples we ON w.word_id = we.word_id " +
                    "WHERE uv.user_vocabulary_id IN (" + placeholders + ") AND uv.user_id = ? " +
                    "ORDER BY w.word";

            List<Object> params = new ArrayList<>(validVocabIds);
            params.add(userId);

            List<Map<String, Object>> vocabulary = jdbcTemplate.queryForList(vocabSql, params.toArray());
            printQueryResult("Anki导出词汇查询结果: " + vocabulary.size() + "条记录");

            if (vocabulary.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabularyIds", validVocabIds);
                ErrorResponse errorResponse = new ErrorResponse("ANKI_EXPORT_ERROR", "没有找到可导出的词汇", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 5. 生成Anki导入文件（CSV格式）
            StringBuilder csvContent = new StringBuilder();

            // Anki CSV格式：单词,音标,释义,词性,例句,例句翻译
            csvContent.append("单词,音标,释义,词性,例句,例句翻译\n");

            for (Map<String, Object> vocab : vocabulary) {
                String word = escapeCsv(vocab.get("word"));
                String phonetic = escapeCsv(vocab.get("phonetic"));
                String meaning = escapeCsv(vocab.get("meaning"));
                String partOfSpeech = escapeCsv(vocab.get("part_of_speech"));
                String example = escapeCsv(vocab.get("example_sentence"));
                String translation = escapeCsv(vocab.get("translation"));

                csvContent.append(word).append(",");
                csvContent.append(phonetic).append(",");
                csvContent.append(meaning).append(",");
                csvContent.append(partOfSpeech).append(",");
                csvContent.append(example).append(",");
                csvContent.append(translation).append("\n");
            }

            byte[] fileBytes = csvContent.toString().getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String filename = "anki_export_" + timestamp + ".csv";

            // 7. 记录导出历史
            String exportId = "export_anki_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", validVocabIds.stream().map(String::valueOf).toArray(String[]::new))
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", "anki_csv");
            exportDetails.put("deck_name", request.getDeck_name());
            exportDetails.put("item_count", vocabulary.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);
            exportDetails.put("include_audio", request.isInclude_audio());
            exportDetails.put("include_images", request.isInclude_images());

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", "anki_csv",
                    "deck_name", request.getDeck_name(),
                    "item_count", vocabulary.size(),
                    "filename", filename,
                    "file_size", fileBytes.length,
                    "include_audio", request.isInclude_audio(),
                    "include_images", request.isInclude_images()
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "ANKI",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.parseMediaType("text/csv"));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("deck_name", request.getDeck_name());
            responseInfo.put("vocabulary_count", vocabulary.size());
            responseInfo.put("include_audio", request.isInclude_audio());
            responseInfo.put("include_images", request.isInclude_images());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("Anki导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("ANKI_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }
}
--- 结束文件: ExportToAnki.java ---

--- 开始文件: ExportVocabulary.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

@RestController
@RequestMapping("/api/v1/export")
public class ExportVocabulary {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到词汇导出请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class ExportVocabularyRequest {
        private List<Integer> vocabulary_ids;
        private String format = "xlsx";
        private Map<String, Object> template;
        private boolean include_examples = true;
        private boolean include_statistics = true;

        public List<Integer> getVocabulary_ids() { return vocabulary_ids; }
        public void setVocabulary_ids(List<Integer> vocabulary_ids) { this.vocabulary_ids = vocabulary_ids; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public Map<String, Object> getTemplate() { return template; }
        public void setTemplate(Map<String, Object> template) { this.template = template; }

        public boolean isInclude_examples() { return include_examples; }
        public void setInclude_examples(boolean include_examples) { this.include_examples = include_examples; }

        public boolean isInclude_statistics() { return include_statistics; }
        public void setInclude_statistics(boolean include_statistics) { this.include_statistics = include_statistics; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    // 词汇信息DTO
    public static class VocabularyInfo {
        private int user_vocabulary_id;
        private int word_id;
        private String word;
        private String phonetic;
        private String meaning;
        private String part_of_speech;
        private int difficulty;
        private int mastery;
        private int study_count;
        private double accuracy;
        private LocalDateTime last_studied;
        private List<ExampleInfo> examples;
        private StatisticsInfo statistics;

        // 构造函数、getter和setter
        public VocabularyInfo(int user_vocabulary_id, int word_id, String word, String phonetic,
                              String meaning, String part_of_speech, int difficulty, int mastery,
                              int study_count, double accuracy, LocalDateTime last_studied) {
            this.user_vocabulary_id = user_vocabulary_id;
            this.word_id = word_id;
            this.word = word;
            this.phonetic = phonetic;
            this.meaning = meaning;
            this.part_of_speech = part_of_speech;
            this.difficulty = difficulty;
            this.mastery = mastery;
            this.study_count = study_count;
            this.accuracy = accuracy;
            this.last_studied = last_studied;
            this.examples = new ArrayList<>();
            this.statistics = new StatisticsInfo();
        }

        // getter和setter方法
        public int getUser_vocabulary_id() { return user_vocabulary_id; }
        public void setUser_vocabulary_id(int user_vocabulary_id) { this.user_vocabulary_id = user_vocabulary_id; }

        public int getWord_id() { return word_id; }
        public void setWord_id(int word_id) { this.word_id = word_id; }

        public String getWord() { return word; }
        public void setWord(String word) { this.word = word; }

        public String getPhonetic() { return phonetic; }
        public void setPhonetic(String phonetic) { this.phonetic = phonetic; }

        public String getMeaning() { return meaning; }
        public void setMeaning(String meaning) { this.meaning = meaning; }

        public String getPart_of_speech() { return part_of_speech; }
        public void setPart_of_speech(String part_of_speech) { this.part_of_speech = part_of_speech; }

        public int getDifficulty() { return difficulty; }
        public void setDifficulty(int difficulty) { this.difficulty = difficulty; }

        public int getMastery() { return mastery; }
        public void setMastery(int mastery) { this.mastery = mastery; }

        public int getStudy_count() { return study_count; }
        public void setStudy_count(int study_count) { this.study_count = study_count; }

        public double getAccuracy() { return accuracy; }
        public void setAccuracy(double accuracy) { this.accuracy = accuracy; }

        public LocalDateTime getLast_studied() { return last_studied; }
        public void setLast_studied(LocalDateTime last_studied) { this.last_studied = last_studied; }

        public List<ExampleInfo> getExamples() { return examples; }
        public void setExamples(List<ExampleInfo> examples) { this.examples = examples; }

        public StatisticsInfo getStatistics() { return statistics; }
        public void setStatistics(StatisticsInfo statistics) { this.statistics = statistics; }
    }

    // 例句信息DTO
    public static class ExampleInfo {
        private String sentence;
        private String translation;
        private String source;

        public ExampleInfo(String sentence, String translation, String source) {
            this.sentence = sentence;
            this.translation = translation;
            this.source = source;
        }

        public String getSentence() { return sentence; }
        public void setSentence(String sentence) { this.sentence = sentence; }

        public String getTranslation() { return translation; }
        public void setTranslation(String translation) { this.translation = translation; }

        public String getSource() { return source; }
        public void setSource(String source) { this.source = source; }
    }

    // 统计信息DTO
    public static class StatisticsInfo {
        private LocalDateTime first_learned;
        private int study_sessions;
        private int correct_answers;
        private int wrong_answers;

        public StatisticsInfo() {
            this.first_learned = LocalDateTime.now();
            this.study_sessions = 0;
            this.correct_answers = 0;
            this.wrong_answers = 0;
        }

        public LocalDateTime getFirst_learned() { return first_learned; }
        public void setFirst_learned(LocalDateTime first_learned) { this.first_learned = first_learned; }

        public int getStudy_sessions() { return study_sessions; }
        public void setStudy_sessions(int study_sessions) { this.study_sessions = study_sessions; }

        public int getCorrect_answers() { return correct_answers; }
        public void setCorrect_answers(int correct_answers) { this.correct_answers = correct_answers; }

        public int getWrong_answers() { return wrong_answers; }
        public void setWrong_answers(int wrong_answers) { this.wrong_answers = wrong_answers; }
    }

    // 支持的格式
    private static final Set<String> SUPPORTED_FORMATS = new HashSet<>(Arrays.asList(
            "xlsx", "csv", "json", "pdf"
    ));

    @PostMapping("/vocabulary/batch")
    public ResponseEntity<?> exportVocabulary(@RequestBody ExportVocabularyRequest request,
                                              @RequestHeader(value = "Authorization", required = false) String authHeader) {
        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (request.getVocabulary_ids() == null || request.getVocabulary_ids().isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabulary_ids", "词汇ID列表不能为空");
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (request.getVocabulary_ids().size() > 500) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabulary_ids", "最多支持导出500个词汇");
                details.put("limit", 500);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            if (!SUPPORTED_FORMATS.contains(request.getFormat().toLowerCase())) {
                Map<String, Object> details = new HashMap<>();
                details.put("format", "不支持的导出格式: " + request.getFormat());
                details.put("supported_formats", SUPPORTED_FORMATS);
                ErrorResponse errorResponse = new ErrorResponse("VALIDATION_ERROR", "参数错误", details);
                printResponse(errorResponse);
                return ResponseEntity.badRequest().body(errorResponse);
            }

            // 3. 验证词汇是否存在且属于当前用户
            List<Integer> invalidVocabIds = new ArrayList<>();
            List<Integer> validVocabIds = new ArrayList<>();

            for (Integer vocabId : request.getVocabulary_ids()) {
                String vocabSql = "SELECT user_vocabulary_id FROM user_vocabulary WHERE user_vocabulary_id = ? AND user_id = ?";
                List<Map<String, Object>> vocabs = jdbcTemplate.queryForList(vocabSql, vocabId, userId);

                if (vocabs.isEmpty()) {
                    invalidVocabIds.add(vocabId);
                } else {
                    validVocabIds.add(vocabId);
                }
            }

            if (!invalidVocabIds.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabularyIds", invalidVocabIds);
                ErrorResponse errorResponse = new ErrorResponse("VOCABULARY_NOT_FOUND", "部分词汇不存在或无权限访问", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 4. 查询词汇详细信息
            List<VocabularyInfo> vocabularyList = new ArrayList<>();

            if (!validVocabIds.isEmpty()) {
                String placeholders = String.join(",", Collections.nCopies(validVocabIds.size(), "?"));

                // 查询用户词汇基本信息
                String vocabSql = "SELECT uv.user_vocabulary_id, uv.word_id, uv.mastery_level as mastery, " +
                        "uv.study_count, uv.correct_count, uv.wrong_count, uv.last_studied_at, " +
                        "w.word, w.phonetic, w.part_of_speech, w.difficulty_level as difficulty, " +
                        "wd.definition as meaning " +
                        "FROM user_vocabulary uv " +
                        "JOIN words w ON uv.word_id = w.word_id " +
                        "LEFT JOIN word_definitions wd ON w.word_id = wd.word_id AND wd.is_primary = 1 " +
                        "WHERE uv.user_vocabulary_id IN (" + placeholders + ") AND uv.user_id = ?";

                List<Object> params = new ArrayList<>(validVocabIds);
                params.add(userId);

                List<Map<String, Object>> vocabResults = jdbcTemplate.queryForList(vocabSql, params.toArray());
                printQueryResult("词汇基本信息查询结果: " + vocabResults.size() + "条记录");

                // 处理每个词汇
                for (Map<String, Object> vocab : vocabResults) {
                    int userVocabId = (int) vocab.get("user_vocabulary_id");
                    int wordId = (int) vocab.get("word_id");
                    String word = (String) vocab.get("word");
                    String phonetic = (String) vocab.get("phonetic");
                    String meaning = (String) vocab.get("meaning");
                    String partOfSpeech = (String) vocab.get("part_of_speech");
                    int difficulty = vocab.get("difficulty") != null ? (int) vocab.get("difficulty") : 1;
                    int mastery = vocab.get("mastery") != null ? (int) vocab.get("mastery") : 0;
                    int studyCount = vocab.get("study_count") != null ? (int) vocab.get("study_count") : 0;

                    // 计算正确率
                    int correctCount = vocab.get("correct_count") != null ? (int) vocab.get("correct_count") : 0;
                    int wrongCount = vocab.get("wrong_count") != null ? (int) vocab.get("wrong_count") : 0;
                    double accuracy = (studyCount > 0) ? (correctCount * 100.0 / studyCount) : 0.0;

                    LocalDateTime lastStudied = vocab.get("last_studied_at") != null ?
                            ((java.sql.Timestamp) vocab.get("last_studied_at")).toLocalDateTime() : null;

                    VocabularyInfo vocabInfo = new VocabularyInfo(
                            userVocabId, wordId, word, phonetic, meaning, partOfSpeech,
                            difficulty, mastery, studyCount, accuracy, lastStudied
                    );

                    // 查询例句（如果需要）
                    if (request.isInclude_examples()) {
                        String examplesSql = "SELECT example_sentence, translation, source " +
                                "FROM word_examples WHERE word_id = ? LIMIT 5";
                        List<Map<String, Object>> examples = jdbcTemplate.queryForList(examplesSql, wordId);

                        for (Map<String, Object> example : examples) {
                            String sentence = (String) example.get("example_sentence");
                            String translation = (String) example.get("translation");
                            String source = (String) example.get("source");

                            vocabInfo.getExamples().add(new ExampleInfo(sentence, translation, source));
                        }
                    }

                    // 查询统计信息（如果需要）
                    if (request.isInclude_statistics()) {
                        // 查询第一次学习时间
                        String firstLearnedSql = "SELECT MIN(created_at) as first_learned " +
                                "FROM review_items WHERE user_vocabulary_id = ?";
                        List<Map<String, Object>> firstLearnedResult = jdbcTemplate.queryForList(firstLearnedSql, userVocabId);

                        if (!firstLearnedResult.isEmpty() && firstLearnedResult.get(0).get("first_learned") != null) {
                            LocalDateTime firstLearned = ((java.sql.Timestamp) firstLearnedResult.get(0).get("first_learned")).toLocalDateTime();
                            vocabInfo.getStatistics().setFirst_learned(firstLearned);
                        }

                        // 查询学习会话次数
                        String sessionsSql = "SELECT COUNT(DISTINCT review_session_id) as session_count " +
                                "FROM review_items WHERE user_vocabulary_id = ?";
                        List<Map<String, Object>> sessionsResult = jdbcTemplate.queryForList(sessionsSql, userVocabId);

                        if (!sessionsResult.isEmpty()) {
                            int sessionCount = ((Number) sessionsResult.get(0).get("session_count")).intValue();
                            vocabInfo.getStatistics().setStudy_sessions(sessionCount);
                        }

                        // 设置正确和错误答案数
                        vocabInfo.getStatistics().setCorrect_answers(correctCount);
                        vocabInfo.getStatistics().setWrong_answers(wrongCount);
                    }

                    vocabularyList.add(vocabInfo);
                }
            }

            if (vocabularyList.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("vocabularyIds", validVocabIds);
                ErrorResponse errorResponse = new ErrorResponse("VOCABULARY_EXPORT_ERROR", "没有找到可导出的词汇", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
            }

            // 5. 生成导出文件内容
            String fileContent = generateExportContent(vocabularyList, request.getFormat(),
                    request.isInclude_examples(), request.isInclude_statistics());
            byte[] fileBytes = fileContent.getBytes(StandardCharsets.UTF_8);

            // 6. 生成文件名
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String extension = getFileExtension(request.getFormat());
            String filename = "vocabulary_" + timestamp + "." + extension;

            // 7. 记录导出历史
            String exportId = "export_vocab_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
            String insertHistorySql = "INSERT INTO sync_logs (user_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)";

            String entityIdsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_ARRAY(?)", String.class,
                    String.join(",", validVocabIds.stream().map(String::valueOf).toArray(String[]::new))
            );

            Map<String, Object> exportDetails = new HashMap<>();
            exportDetails.put("export_id", exportId);
            exportDetails.put("format", request.getFormat());
            exportDetails.put("item_count", vocabularyList.size());
            exportDetails.put("filename", filename);
            exportDetails.put("file_size", fileBytes.length);
            exportDetails.put("include_examples", request.isInclude_examples());
            exportDetails.put("include_statistics", request.isInclude_statistics());

            String detailsJson = jdbcTemplate.queryForObject(
                    "SELECT JSON_OBJECT(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", String.class,
                    "export_id", exportId,
                    "format", request.getFormat(),
                    "item_count", vocabularyList.size(),
                    "filename", filename,
                    "file_size", fileBytes.length,
                    "include_examples", request.isInclude_examples(),
                    "include_statistics", request.isInclude_statistics()
            );

            jdbcTemplate.update(insertHistorySql,
                    userId,
                    "EXPORT",
                    "VOCABULARY",
                    entityIdsJson,
                    "COMPLETED",
                    detailsJson,
                    LocalDateTime.now()
            );

            // 8. 准备文件响应
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(getMediaType(request.getFormat()));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(fileBytes.length);

            // 打印返回信息
            Map<String, Object> responseInfo = new HashMap<>();
            responseInfo.put("filename", filename);
            responseInfo.put("file_size", fileBytes.length);
            responseInfo.put("format", request.getFormat());
            responseInfo.put("vocabulary_count", vocabularyList.size());
            responseInfo.put("include_examples", request.isInclude_examples());
            responseInfo.put("include_statistics", request.isInclude_statistics());
            printResponse(responseInfo);

            return new ResponseEntity<>(fileBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            System.err.println("词汇导出过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("VOCABULARY_EXPORT_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 生成导出内容
    private String generateExportContent(List<VocabularyInfo> vocabularyList, String format,
                                         boolean includeExamples, boolean includeStatistics) {
        StringBuilder content = new StringBuilder();

        if (format.equalsIgnoreCase("json")) {
            // JSON格式
            Map<String, Object> exportData = new HashMap<>();
            exportData.put("metadata", new HashMap<String, Object>() {{
                put("exportedAt", LocalDateTime.now().toString());
                put("totalItems", vocabularyList.size());
                put("format", "json");
                put("version", "1.0");
            }});

            List<Map<String, Object>> vocabJsonList = new ArrayList<>();
            for (VocabularyInfo vocab : vocabularyList) {
                Map<String, Object> vocabMap = new HashMap<>();
                vocabMap.put("id", "vocab_" + vocab.getUser_vocabulary_id());
                vocabMap.put("word", vocab.getWord());
                vocabMap.put("phonetic", vocab.getPhonetic());
                vocabMap.put("meaning", vocab.getMeaning());
                vocabMap.put("partOfSpeech", vocab.getPart_of_speech());
                vocabMap.put("difficulty", vocab.getDifficulty());
                vocabMap.put("mastery", vocab.getMastery());
                vocabMap.put("studyCount", vocab.getStudy_count());
                vocabMap.put("accuracy", vocab.getAccuracy());
                vocabMap.put("lastStudied", vocab.getLast_studied() != null ? vocab.getLast_studied().toString() : null);

                if (includeExamples && !vocab.getExamples().isEmpty()) {
                    List<Map<String, Object>> examplesList = new ArrayList<>();
                    for (ExampleInfo example : vocab.getExamples()) {
                        Map<String, Object> exampleMap = new HashMap<>();
                        exampleMap.put("sentence", example.getSentence());
                        exampleMap.put("translation", example.getTranslation());
                        exampleMap.put("source", example.getSource());
                        examplesList.add(exampleMap);
                    }
                    vocabMap.put("examples", examplesList);
                }

                if (includeStatistics) {
                    Map<String, Object> statsMap = new HashMap<>();
                    statsMap.put("firstLearned", vocab.getStatistics().getFirst_learned().toString());
                    statsMap.put("studySessions", vocab.getStatistics().getStudy_sessions());
                    statsMap.put("correctAnswers", vocab.getStatistics().getCorrect_answers());
                    statsMap.put("wrongAnswers", vocab.getStatistics().getWrong_answers());
                    vocabMap.put("statistics", statsMap);
                }

                vocabJsonList.add(vocabMap);
            }

            exportData.put("vocabulary", vocabJsonList);

            // 简单JSON序列化
            content.append("{\n");
            content.append("  \"metadata\": {\n");
            content.append("    \"exportedAt\": \"").append(LocalDateTime.now()).append("\",\n");
            content.append("    \"totalItems\": ").append(vocabularyList.size()).append(",\n");
            content.append("    \"format\": \"json\",\n");
            content.append("    \"version\": \"1.0\"\n");
            content.append("  },\n");
            content.append("  \"vocabulary\": [\n");

            for (int i = 0; i < vocabularyList.size(); i++) {
                VocabularyInfo vocab = vocabularyList.get(i);
                content.append("    {\n");
                content.append("      \"id\": \"vocab_").append(vocab.getUser_vocabulary_id()).append("\",\n");
                content.append("      \"word\": \"").append(escapeJson(vocab.getWord())).append("\",\n");
                content.append("      \"phonetic\": \"").append(escapeJson(vocab.getPhonetic())).append("\",\n");
                content.append("      \"meaning\": \"").append(escapeJson(vocab.getMeaning())).append("\",\n");
                content.append("      \"partOfSpeech\": \"").append(escapeJson(vocab.getPart_of_speech())).append("\",\n");
                content.append("      \"difficulty\": ").append(vocab.getDifficulty()).append(",\n");
                content.append("      \"mastery\": ").append(vocab.getMastery()).append(",\n");
                content.append("      \"studyCount\": ").append(vocab.getStudy_count()).append(",\n");
                content.append("      \"accuracy\": ").append(vocab.getAccuracy()).append(",\n");
                content.append("      \"lastStudied\": \"").append(vocab.getLast_studied() != null ? vocab.getLast_studied() : "").append("\"\n");
                content.append("    }");
                if (i < vocabularyList.size() - 1) content.append(",");
                content.append("\n");
            }

            content.append("  ]\n");
            content.append("}");

        } else if (format.equalsIgnoreCase("csv")) {
            // CSV格式
            content.append("单词,音标,释义,词性,难度等级,掌握程度,学习次数,正确率,最后学习时间\n");
            for (VocabularyInfo vocab : vocabularyList) {
                content.append(escapeCsv(vocab.getWord())).append(",");
                content.append(escapeCsv(vocab.getPhonetic())).append(",");
                content.append(escapeCsv(vocab.getMeaning())).append(",");
                content.append(escapeCsv(vocab.getPart_of_speech())).append(",");
                content.append(vocab.getDifficulty()).append(",");
                content.append(vocab.getMastery()).append(",");
                content.append(vocab.getStudy_count()).append(",");
                content.append(String.format("%.2f", vocab.getAccuracy())).append(",");
                content.append(escapeCsv(vocab.getLast_studied() != null ? vocab.getLast_studied().toString() : "")).append("\n");
            }

            // 如果包含例句，添加例句工作表
            if (includeExamples) {
                content.append("\n\n=== 例句 ===\n");
                content.append("单词,例句,翻译,来源\n");
                for (VocabularyInfo vocab : vocabularyList) {
                    for (ExampleInfo example : vocab.getExamples()) {
                        content.append(escapeCsv(vocab.getWord())).append(",");
                        content.append(escapeCsv(example.getSentence())).append(",");
                        content.append(escapeCsv(example.getTranslation())).append(",");
                        content.append(escapeCsv(example.getSource())).append("\n");
                    }
                }
            }

            // 如果包含统计信息，添加统计工作表
            if (includeStatistics) {
                content.append("\n\n=== 统计信息 ===\n");
                content.append("统计项,数值,说明\n");
                content.append("总词汇数,").append(vocabularyList.size()).append(",词汇总数\n");

                // 计算已掌握词汇数（掌握度80%以上）
                long masteredCount = vocabularyList.stream()
                        .filter(v -> v.getMastery() >= 80)
                        .count();
                content.append("已掌握词汇,").append(masteredCount).append(",掌握度80%以上的词汇数\n");

                // 计算学习天数（模拟）
                int studyDays = (int) (Math.random() * 30) + 1;
                content.append("学习天数,").append(studyDays).append(",累计学习天数\n");

                // 计算平均正确率
                double avgAccuracy = vocabularyList.stream()
                        .mapToDouble(VocabularyInfo::getAccuracy)
                        .average()
                        .orElse(0.0);
                content.append("平均正确率,").append(String.format("%.2f", avgAccuracy)).append(",整体答题正确率\n");

                // 最长连续学习（模拟）
                int longestStreak = (int) (Math.random() * 15) + 1;
                content.append("最长连续学习,").append(longestStreak).append(",连续学习天数\n");
            }

        } else {
            // 默认文本格式（用于pdf和txt）
            content.append("词汇导出报告\n");
            content.append("============\n\n");
            content.append("导出时间: ").append(LocalDateTime.now()).append("\n");
            content.append("词汇数量: ").append(vocabularyList.size()).append("\n");
            content.append("导出格式: ").append(format).append("\n\n");

            content.append("词汇列表:\n");
            content.append("--------\n");

            for (int i = 0; i < vocabularyList.size(); i++) {
                VocabularyInfo vocab = vocabularyList.get(i);
                content.append(i + 1).append(". ").append(vocab.getWord()).append(" ");

                if (vocab.getPhonetic() != null && !vocab.getPhonetic().isEmpty()) {
                    content.append("[").append(vocab.getPhonetic()).append("] ");
                }

                if (vocab.getPart_of_speech() != null && !vocab.getPart_of_speech().isEmpty()) {
                    content.append("(").append(vocab.getPart_of_speech()).append(") ");
                }

                content.append("\n");
                content.append("   释义: ").append(vocab.getMeaning()).append("\n");
                content.append("   难度: ").append(vocab.getDifficulty()).append("级 | ");
                content.append("掌握度: ").append(vocab.getMastery()).append("% | ");
                content.append("学习次数: ").append(vocab.getStudy_count()).append(" | ");
                content.append("正确率: ").append(String.format("%.2f", vocab.getAccuracy())).append("%\n");

                if (vocab.getLast_studied() != null) {
                    content.append("   最后学习: ").append(vocab.getLast_studied()).append("\n");
                }

                // 添加例句
                if (includeExamples && !vocab.getExamples().isEmpty()) {
                    content.append("   例句:\n");
                    for (ExampleInfo example : vocab.getExamples()) {
                        content.append("     - ").append(example.getSentence()).append("\n");
                        content.append("       ").append(example.getTranslation()).append("\n");
                    }
                }

                content.append("\n");
            }

            // 添加统计信息
            if (includeStatistics) {
                content.append("\n统计摘要:\n");
                content.append("--------\n");

                // 计算已掌握词汇数
                long masteredCount = vocabularyList.stream()
                        .filter(v -> v.getMastery() >= 80)
                        .count();

                // 计算平均正确率
                double avgAccuracy = vocabularyList.stream()
                        .mapToDouble(VocabularyInfo::getAccuracy)
                        .average()
                        .orElse(0.0);

                content.append("总词汇数: ").append(vocabularyList.size()).append("\n");
                content.append("已掌握词汇: ").append(masteredCount).append(" (").append(String.format("%.1f", masteredCount * 100.0 / vocabularyList.size())).append("%)\n");
                content.append("平均掌握度: ").append(String.format("%.1f", vocabularyList.stream().mapToInt(VocabularyInfo::getMastery).average().orElse(0.0))).append("%\n");
                content.append("平均正确率: ").append(String.format("%.2f", avgAccuracy)).append("%\n");
            }
        }

        return content.toString();
    }

    // 获取文件扩展名
    private String getFileExtension(String format) {
        switch (format.toLowerCase()) {
            case "xlsx": return "xlsx";
            case "csv": return "csv";
            case "json": return "json";
            case "pdf": return "pdf";
            default: return "txt";
        }
    }

    // 获取媒体类型
    private MediaType getMediaType(String format) {
        switch (format.toLowerCase()) {
            case "xlsx": return MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            case "csv": return MediaType.parseMediaType("text/csv");
            case "json": return MediaType.APPLICATION_JSON;
            case "pdf": return MediaType.APPLICATION_PDF;
            default: return MediaType.TEXT_PLAIN;
        }
    }

    // 转义JSON字符串
    private String escapeJson(Object value) {
        if (value == null) return "";
        return value.toString()
                .replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    // 转义CSV字符串
    private String escapeCsv(Object value) {
        if (value == null) return "";
        String str = value.toString();
        if (str.contains(",") || str.contains("\"") || str.contains("\n")) {
            return "\"" + str.replace("\"", "\"\"") + "\"";
        }
        return str;
    }
}
--- 结束文件: ExportVocabulary.java ---

--- 开始文件: GetExportHistory.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.time.format.DateTimeFormatter;

@RestController
@RequestMapping("/api/v1/export")
public class GetExportHistory {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到导出历史查询请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class GetExportHistoryRequest {
        private int page = 1;
        private int page_size = 20;
        private String sort_by = "createdAt";
        private String sort_order = "desc";

        public int getPage() { return page; }
        public void setPage(int page) { this.page = page; }

        public int getPage_size() { return page_size; }
        public void setPage_size(int page_size) { this.page_size = page_size; }

        public String getSort_by() { return sort_by; }
        public void setSort_by(String sort_by) { this.sort_by = sort_by; }

        public String getSort_order() { return sort_order; }
        public void setSort_order(String sort_order) { this.sort_order = sort_order; }
    }

    // 响应DTO
    public static class GetExportHistoryResponse {
        private boolean success = true;
        private String message = "查询成功";
        private ExportHistoryData data;

        public GetExportHistoryResponse(ExportHistoryData data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public ExportHistoryData getData() { return data; }
        public void setData(ExportHistoryData data) { this.data = data; }
    }

    public static class ExportHistoryData {
        private List<ExportHistoryItem> items;
        private PaginationInfo pagination;

        public ExportHistoryData(List<ExportHistoryItem> items, PaginationInfo pagination) {
            this.items = items;
            this.pagination = pagination;
        }

        public List<ExportHistoryItem> getItems() { return items; }
        public void setItems(List<ExportHistoryItem> items) { this.items = items; }

        public PaginationInfo getPagination() { return pagination; }
        public void setPagination(PaginationInfo pagination) { this.pagination = pagination; }
    }

    public static class ExportHistoryItem {
        private String id;
        private String type;
        private String format;
        private int itemCount;
        private String filename;
        private String fileSize;
        private boolean isBackup;
        private int userId;
        private LocalDateTime createdAt;
        private String status;
        private Map<String, Object> metadata;

        // 构造函数
        public ExportHistoryItem(String id, String type, String format, int itemCount,
                                 String filename, String fileSize, boolean isBackup,
                                 int userId, LocalDateTime createdAt, String status) {
            this.id = id;
            this.type = type;
            this.format = format;
            this.itemCount = itemCount;
            this.filename = filename;
            this.fileSize = fileSize;
            this.isBackup = isBackup;
            this.userId = userId;
            this.createdAt = createdAt;
            this.status = status;
            this.metadata = new HashMap<>();
        }

        // getter和setter方法
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public int getItemCount() { return itemCount; }
        public void setItemCount(int itemCount) { this.itemCount = itemCount; }

        public String getFilename() { return filename; }
        public void setFilename(String filename) { this.filename = filename; }

        public String getFileSize() { return fileSize; }
        public void setFileSize(String fileSize) { this.fileSize = fileSize; }

        public boolean isBackup() { return isBackup; }
        public void setBackup(boolean backup) { isBackup = backup; }

        public int getUserId() { return userId; }
        public void setUserId(int userId) { this.userId = userId; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }

        public Map<String, Object> getMetadata() { return metadata; }
        public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    }

    public static class PaginationInfo {
        private int page;
        private int pageSize;
        private int totalItems;
        private int totalPages;
        private boolean hasNext;
        private boolean hasPrevious;

        public PaginationInfo(int page, int pageSize, int totalItems) {
            this.page = page;
            this.pageSize = pageSize;
            this.totalItems = totalItems;
            this.totalPages = (int) Math.ceil((double) totalItems / pageSize);
            this.hasNext = page < totalPages;
            this.hasPrevious = page > 1;
        }

        public int getPage() { return page; }
        public void setPage(int page) { this.page = page; }

        public int getPageSize() { return pageSize; }
        public void setPageSize(int pageSize) { this.pageSize = pageSize; }

        public int getTotalItems() { return totalItems; }
        public void setTotalItems(int totalItems) { this.totalItems = totalItems; }

        public int getTotalPages() { return totalPages; }
        public void setTotalPages(int totalPages) { this.totalPages = totalPages; }

        public boolean isHasNext() { return hasNext; }
        public void setHasNext(boolean hasNext) { this.hasNext = hasNext; }

        public boolean isHasPrevious() { return hasPrevious; }
        public void setHasPrevious(boolean hasPrevious) { this.hasPrevious = hasPrevious; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @GetMapping("/history")
    public ResponseEntity<?> getExportHistory(@RequestParam(required = false, defaultValue = "1") int page,
                                              @RequestParam(required = false, defaultValue = "20") int page_size,
                                              @RequestParam(required = false, defaultValue = "createdAt") String sort_by,
                                              @RequestParam(required = false, defaultValue = "desc") String sort_order,
                                              @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 构建请求对象
        GetExportHistoryRequest request = new GetExportHistoryRequest();
        request.setPage(page);
        request.setPage_size(page_size);
        request.setSort_by(sort_by);
        request.setSort_order(sort_order);

        // 打印接收到的请求
        printRequest(request);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 验证请求参数
            if (page < 1) {
                page = 1;
            }

            if (page_size < 1 || page_size > 100) {
                page_size = 20;
            }

            // 验证排序字段
            Set<String> validSortFields = new HashSet<>(Arrays.asList(
                    "createdAt", "type", "format", "status", "itemCount"
            ));

            if (!validSortFields.contains(sort_by)) {
                sort_by = "createdAt";
            }

            if (!"asc".equalsIgnoreCase(sort_order) && !"desc".equalsIgnoreCase(sort_order)) {
                sort_order = "desc";
            }

            // 3. 计算分页参数
            int offset = (page - 1) * page_size;

            // 4. 查询总记录数
            String countSql = "SELECT COUNT(*) as total FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT'";
            int totalItems = jdbcTemplate.queryForObject(countSql, Integer.class, userId);

            // 5. 查询导出历史记录
            String historySql = "SELECT log_id, operation_type, entity_type, entity_ids, " +
                    "status, details, created_at FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "ORDER BY " + sort_by + " " + sort_order + " " +
                    "LIMIT ? OFFSET ?";

            List<Map<String, Object>> historyResults = jdbcTemplate.queryForList(
                    historySql, userId, page_size, offset
            );

            printQueryResult("导出历史查询结果: " + historyResults.size() + "条记录");

            // 6. 转换结果
            List<ExportHistoryItem> historyItems = new ArrayList<>();

            for (Map<String, Object> record : historyResults) {
                int logId = (int) record.get("log_id");
                String entityType = (String) record.get("entity_type");
                String status = (String) record.get("status");
                LocalDateTime createdAt = ((java.sql.Timestamp) record.get("created_at")).toLocalDateTime();

                // 解析details字段
                Map<String, Object> details = new HashMap<>();
                String detailsJson = (String) record.get("details");

                // 简单解析details JSON（实际项目中应使用JSON库）
                if (detailsJson != null && detailsJson.startsWith("{")) {
                    // 移除花括号并分割键值对
                    String content = detailsJson.substring(1, detailsJson.length() - 1);
                    String[] pairs = content.split(",");

                    for (String pair : pairs) {
                        String[] keyValue = pair.split(":");
                        if (keyValue.length == 2) {
                            String key = keyValue[0].trim().replace("\"", "");
                            String value = keyValue[1].trim().replace("\"", "");
                            details.put(key, value);
                        }
                    }
                }

                // 从details中提取信息
                String exportId = (String) details.getOrDefault("export_id", "export_" + logId);
                String format = (String) details.getOrDefault("format", "unknown");
                int itemCount = Integer.parseInt(details.getOrDefault("item_count", "0").toString());
                String filename = (String) details.getOrDefault("filename", "unknown");
                String fileSize = (String) details.getOrDefault("file_size", "0");
                boolean isBackup = Boolean.parseBoolean(details.getOrDefault("is_backup", "false").toString());

                ExportHistoryItem item = new ExportHistoryItem(
                        exportId, entityType, format, itemCount, filename,
                        fileSize, isBackup, userId, createdAt, status
                );

                // 添加metadata
                item.setMetadata(details);

                historyItems.add(item);
            }

            // 7. 构建分页信息
            PaginationInfo pagination = new PaginationInfo(page, page_size, totalItems);

            // 8. 构建响应数据
            ExportHistoryData historyData = new ExportHistoryData(historyItems, pagination);
            GetExportHistoryResponse response = new GetExportHistoryResponse(historyData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("查询导出历史过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("HISTORY_QUERY_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}
--- 结束文件: GetExportHistory.java ---

--- 开始文件: GetExportStats.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.util.*;

@RestController
@RequestMapping("/api/v1/export")
public class GetExportStats {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到导出统计请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("====================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class GetExportStatsResponse {
        private boolean success = true;
        private String message = "查询成功";
        private ExportStatsData data;

        public GetExportStatsResponse(ExportStatsData data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public ExportStatsData getData() { return data; }
        public void setData(ExportStatsData data) { this.data = data; }
    }

    public static class ExportStatsData {
        private Map<String, Object> overall;
        private Map<String, Object> byType;
        private Map<String, Object> byFormat;
        private Map<String, Object> recentActivity;

        public ExportStatsData(Map<String, Object> overall, Map<String, Object> byType,
                               Map<String, Object> byFormat, Map<String, Object> recentActivity) {
            this.overall = overall;
            this.byType = byType;
            this.byFormat = byFormat;
            this.recentActivity = recentActivity;
        }

        public Map<String, Object> getOverall() { return overall; }
        public void setOverall(Map<String, Object> overall) { this.overall = overall; }

        public Map<String, Object> getByType() { return byType; }
        public void setByType(Map<String, Object> byType) { this.byType = byType; }

        public Map<String, Object> getByFormat() { return byFormat; }
        public void setByFormat(Map<String, Object> byFormat) { this.byFormat = byFormat; }

        public Map<String, Object> getRecentActivity() { return recentActivity; }
        public void setRecentActivity(Map<String, Object> recentActivity) { this.recentActivity = recentActivity; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @GetMapping("/stats")
    public ResponseEntity<?> getExportStats(@RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest("查询导出统计");

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 查询总体统计
            Map<String, Object> overallStats = new HashMap<>();

            // 总导出次数
            String totalExportsSql = "SELECT COUNT(*) as total FROM sync_logs WHERE user_id = ? AND operation_type = 'EXPORT'";
            int totalExports = jdbcTemplate.queryForObject(totalExportsSql, Integer.class, userId);
            overallStats.put("total_exports", totalExports);

            // 最近30天导出次数
            String recentExportsSql = "SELECT COUNT(*) as recent FROM sync_logs WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)";
            int recentExports = jdbcTemplate.queryForObject(recentExportsSql, Integer.class, userId);
            overallStats.put("recent_exports_30d", recentExports);

            // 总导出文件大小
            String totalSizeSql = "SELECT SUM(JSON_EXTRACT(details, '$.file_size')) as total_size FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT'";
            Long totalSize = jdbcTemplate.queryForObject(totalSizeSql, Long.class, userId);
            overallStats.put("total_file_size", totalSize != null ? totalSize : 0);

            // 平均导出文件大小
            if (totalExports > 0 && totalSize != null) {
                overallStats.put("avg_file_size", totalSize / totalExports);
            } else {
                overallStats.put("avg_file_size", 0);
            }

            // 3. 按类型统计
            Map<String, Object> typeStats = new HashMap<>();

            String typeCountSql = "SELECT entity_type, COUNT(*) as count FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "GROUP BY entity_type ORDER BY count DESC";

            List<Map<String, Object>> typeCounts = jdbcTemplate.queryForList(typeCountSql, userId);

            for (Map<String, Object> typeCount : typeCounts) {
                String entityType = (String) typeCount.get("entity_type");
                long count = ((Number) typeCount.get("count")).longValue();
                typeStats.put(entityType, count);
            }

            // 4. 按格式统计
            Map<String, Object> formatStats = new HashMap<>();

            String formatCountSql = "SELECT JSON_EXTRACT(details, '$.format') as format, COUNT(*) as count FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "GROUP BY JSON_EXTRACT(details, '$.format') ORDER BY count DESC";

            List<Map<String, Object>> formatCounts = jdbcTemplate.queryForList(formatCountSql, userId);

            for (Map<String, Object> formatCount : formatCounts) {
                String format = (String) formatCount.get("format");
                if (format != null) {
                    long count = ((Number) formatCount.get("count")).longValue();
                    formatStats.put(format.replace("\"", ""), count);
                }
            }

            // 5. 最近活动统计
            Map<String, Object> recentActivity = new HashMap<>();

            // 最近7天导出趋势
            String weeklyTrendSql = "SELECT DATE(created_at) as date, COUNT(*) as count FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "AND created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) " +
                    "GROUP BY DATE(created_at) ORDER BY date";

            List<Map<String, Object>> weeklyTrend = jdbcTemplate.queryForList(weeklyTrendSql, userId);
            recentActivity.put("weekly_trend", weeklyTrend);

            // 最常导出的类型
            String topTypesSql = "SELECT entity_type, COUNT(*) as count FROM sync_logs " +
                    "WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "GROUP BY entity_type ORDER BY count DESC LIMIT 5";

            List<Map<String, Object>> topTypes = jdbcTemplate.queryForList(topTypesSql, userId);
            recentActivity.put("top_types", topTypes);

            // 最近10次导出
            String recentExportsSql2 = "SELECT log_id, operation_type, entity_type, status, details, created_at " +
                    "FROM sync_logs WHERE user_id = ? AND operation_type = 'EXPORT' " +
                    "ORDER BY created_at DESC LIMIT 10";

            List<Map<String, Object>> recentExportsList = jdbcTemplate.queryForList(recentExportsSql2, userId);
            recentActivity.put("recent_exports", recentExportsList);

            // 6. 构建响应数据
            ExportStatsData statsData = new ExportStatsData(overallStats, typeStats, formatStats, recentActivity);
            GetExportStatsResponse response = new GetExportStatsResponse(statsData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("查询导出统计过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("STATS_QUERY_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}
--- 结束文件: GetExportStats.java ---

--- 开始文件: GetExportTemplates.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.time.format.DateTimeFormatter;

@RestController
@RequestMapping("/api/v1/export")
public class GetExportTemplates {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到导出模板查询请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class GetExportTemplatesResponse {
        private boolean success = true;
        private String message = "查询成功";
        private List<ExportTemplate> data;

        public GetExportTemplatesResponse(List<ExportTemplate> data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public List<ExportTemplate> getData() { return data; }
        public void setData(List<ExportTemplate> data) { this.data = data; }
    }

    public static class ExportTemplate {
        private String id;
        private String name;
        private String type;
        private String format;
        private String description;
        private Map<String, Object> config;
        private boolean isDefault;
        private boolean isPublic;
        private LocalDateTime createdAt;
        private LocalDateTime updatedAt;

        // 构造函数
        public ExportTemplate(String id, String name, String type, String format,
                              String description, Map<String, Object> config,
                              boolean isDefault, boolean isPublic,
                              LocalDateTime createdAt, LocalDateTime updatedAt) {
            this.id = id;
            this.name = name;
            this.type = type;
            this.format = format;
            this.description = description;
            this.config = config;
            this.isDefault = isDefault;
            this.isPublic = isPublic;
            this.createdAt = createdAt;
            this.updatedAt = updatedAt;
        }

        // getter和setter方法
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getFormat() { return format; }
        public void setFormat(String format) { this.format = format; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public Map<String, Object> getConfig() { return config; }
        public void setConfig(Map<String, Object> config) { this.config = config; }

        public boolean isDefault() { return isDefault; }
        public void setDefault(boolean aDefault) { isDefault = aDefault; }

        public boolean isPublic() { return isPublic; }
        public void setPublic(boolean aPublic) { isPublic = aPublic; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public LocalDateTime getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @GetMapping("/templates")
    public ResponseEntity<?> getExportTemplates(@RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest("查询所有导出模板");

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 查询导出模板
            // 首先查询系统默认模板和公共模板
            List<ExportTemplate> templates = new ArrayList<>();

            // 2.1 添加系统默认模板
            templates.addAll(getSystemDefaultTemplates());

            // 2.2 查询用户自定义模板（如果有对应的表）
            try {
                String userTemplatesSql = "SELECT template_id, template_name, template_type, " +
                        "export_format, description, config, is_default, " +
                        "is_public, created_at, updated_at FROM export_templates " +
                        "WHERE (user_id = ? OR is_public = true) " +
                        "ORDER BY is_default DESC, created_at DESC";

                List<Map<String, Object>> userTemplateResults = jdbcTemplate.queryForList(
                        userTemplatesSql, userId
                );

                for (Map<String, Object> templateRecord : userTemplateResults) {
                    String id = "template_" + templateRecord.get("template_id");
                    String name = (String) templateRecord.get("template_name");
                    String type = (String) templateRecord.get("template_type");
                    String format = (String) templateRecord.get("export_format");
                    String description = (String) templateRecord.get("description");

                    // 解析config字段
                    Map<String, Object> config = new HashMap<>();
                    String configJson = (String) templateRecord.get("config");
                    if (configJson != null && configJson.startsWith("{")) {
                        // 简单解析JSON
                        String content = configJson.substring(1, configJson.length() - 1);
                        String[] pairs = content.split(",");

                        for (String pair : pairs) {
                            String[] keyValue = pair.split(":");
                            if (keyValue.length == 2) {
                                String key = keyValue[0].trim().replace("\"", "");
                                String value = keyValue[1].trim().replace("\"", "");
                                config.put(key, value);
                            }
                        }
                    }

                    boolean isDefault = Boolean.parseBoolean(templateRecord.getOrDefault("is_default", "false").toString());
                    boolean isPublic = Boolean.parseBoolean(templateRecord.getOrDefault("is_public", "false").toString());
                    LocalDateTime createdAt = ((java.sql.Timestamp) templateRecord.get("created_at")).toLocalDateTime();
                    LocalDateTime updatedAt = templateRecord.get("updated_at") != null ?
                            ((java.sql.Timestamp) templateRecord.get("updated_at")).toLocalDateTime() : createdAt;

                    ExportTemplate template = new ExportTemplate(
                            id, name, type, format, description, config,
                            isDefault, isPublic, createdAt, updatedAt
                    );

                    templates.add(template);
                }

                printQueryResult("用户自定义模板查询结果: " + userTemplateResults.size() + "条记录");

            } catch (Exception e) {
                System.out.println("导出模板表不存在，仅返回系统默认模板");
            }

            // 3. 构建响应
            GetExportTemplatesResponse response = new GetExportTemplatesResponse(templates);

            // 打印返回数据
            printResponse("返回模板数量: " + templates.size());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("查询导出模板过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("TEMPLATES_QUERY_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 获取系统默认模板
    private List<ExportTemplate> getSystemDefaultTemplates() {
        List<ExportTemplate> systemTemplates = new ArrayList<>();

        // 1. 文档导出PDF模板
        Map<String, Object> docPdfConfig = new HashMap<>();
        docPdfConfig.put("pageSize", "A4");
        docPdfConfig.put("margin", "2cm");
        docPdfConfig.put("fontSize", "12pt");
        docPdfConfig.put("includeHeader", true);
        docPdfConfig.put("includeFooter", true);
        docPdfConfig.put("watermark", false);
        docPdfConfig.put("pageNumbers", true);

        systemTemplates.add(new ExportTemplate(
                "system_doc_pdf_default",
                "PDF标准模板",
                "documents",
                "pdf",
                "标准PDF文档导出模板，适合打印和阅读",
                docPdfConfig,
                true,
                true,
                LocalDateTime.now().minusDays(30),
                LocalDateTime.now().minusDays(10)
        ));

        // 2. 文档导出Word模板
        Map<String, Object> docDocxConfig = new HashMap<>();
        docDocxConfig.put("fontFamily", "Calibri");
        docDocxConfig.put("fontSize", "11pt");
        docDocxConfig.put("lineSpacing", "1.5");
        docDocxConfig.put("includeToc", true);
        docDocxConfig.put("headerLevels", 3);

        systemTemplates.add(new ExportTemplate(
                "system_doc_docx_default",
                "Word标准模板",
                "documents",
                "docx",
                "标准Word文档导出模板，适合编辑和修改",
                docDocxConfig,
                false,
                true,
                LocalDateTime.now().minusDays(25),
                LocalDateTime.now().minusDays(8)
        ));

        // 3. 词汇导出Excel模板
        Map<String, Object> vocabXlsxConfig = new HashMap<>();
        vocabXlsxConfig.put("includePhonetic", true);
        vocabXlsxConfig.put("includeExamples", true);
        vocabXlsxConfig.put("includeTags", true);
        vocabXlsxConfig.put("includeStatistics", false);
        vocabXlsxConfig.put("autoFilter", true);
        vocabXlsxConfig.put("freezeHeader", true);
        vocabXlsxConfig.put("columnWidth", new HashMap<String, Object>() {{
            put("word", 15);
            put("phonetic", 12);
            put("meaning", 25);
            put("partOfSpeech", 10);
        }});

        systemTemplates.add(new ExportTemplate(
                "system_vocab_xlsx_default",
                "Excel词汇表模板",
                "vocabulary",
                "xlsx",
                "标准Excel词汇导出模板，包含单词、音标、释义等信息",
                vocabXlsxConfig,
                true,
                true,
                LocalDateTime.now().minusDays(20),
                LocalDateTime.now().minusDays(5)
        ));

        // 4. 复习记录导出CSV模板
        Map<String, Object> reviewCsvConfig = new HashMap<>();
        reviewCsvConfig.put("delimiter", ",");
        reviewCsvConfig.put("includeHeader", true);
        reviewCsvConfig.put("dateFormat", "yyyy-MM-dd HH:mm:ss");
        reviewCsvConfig.put("encoding", "UTF-8");

        systemTemplates.add(new ExportTemplate(
                "system_review_csv_default",
                "CSV复习记录模板",
                "reviews",
                "csv",
                "标准CSV复习记录导出模板，适合数据分析和导入",
                reviewCsvConfig,
                true,
                true,
                LocalDateTime.now().minusDays(15),
                LocalDateTime.now().minusDays(3)
        ));

        // 5. 学习统计导出PDF模板
        Map<String, Object> statsPdfConfig = new HashMap<>();
        statsPdfConfig.put("pageSize", "A4");
        statsPdfConfig.put("orientation", "portrait");
        statsPdfConfig.put("includeCharts", true);
        statsPdfConfig.put("chartType", "line");
        statsPdfConfig.put("colorScheme", "blue");

        systemTemplates.add(new ExportTemplate(
                "system_stats_pdf_default",
                "PDF学习报告模板",
                "statistics",
                "pdf",
                "标准PDF学习统计报告模板，包含图表和趋势分析",
                statsPdfConfig,
                true,
                true,
                LocalDateTime.now().minusDays(10),
                LocalDateTime.now().minusDays(1)
        ));

        // 6. 笔记导出HTML模板
        Map<String, Object> notesHtmlConfig = new HashMap<>();
        notesHtmlConfig.put("theme", "light");
        notesHtmlConfig.put("fontSize", "14px");
        notesHtmlConfig.put("lineHeight", "1.6");
        notesHtmlConfig.put("includeCss", true);
        notesHtmlConfig.put("responsive", true);

        systemTemplates.add(new ExportTemplate(
                "system_notes_html_default",
                "HTML笔记模板",
                "notes",
                "html",
                "标准HTML笔记导出模板，适合网页浏览和分享",
                notesHtmlConfig,
                true,
                true,
                LocalDateTime.now().minusDays(5),
                LocalDateTime.now()
        ));

        return systemTemplates;
    }
}
--- 结束文件: GetExportTemplates.java ---

--- 开始文件: GetSupportedFormats.java ---
package com.vue.readingapp.export;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.*;

@RestController
@RequestMapping("/api/v1/export")
public class GetSupportedFormats {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取支持格式请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=======================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class GetSupportedFormatsResponse {
        private boolean success = true;
        private String message = "查询成功";
        private Map<String, Object> data;

        public GetSupportedFormatsResponse(Map<String, Object> data) {
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public Map<String, Object> getData() { return data; }
        public void setData(Map<String, Object> data) { this.data = data; }
    }

    // 错误响应DTO
    public static class ErrorResponse {
        private boolean success = false;
        private ErrorDetail error;

        public ErrorResponse(String code, String message, Map<String, Object> details) {
            this.error = new ErrorDetail(code, message, details);
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public ErrorDetail getError() { return error; }
        public void setError(ErrorDetail error) { this.error = error; }

        public static class ErrorDetail {
            private String code;
            private String message;
            private Map<String, Object> details;

            public ErrorDetail(String code, String message, Map<String, Object> details) {
                this.code = code;
                this.message = message;
                this.details = details;
            }

            public String getCode() { return code; }
            public void setCode(String code) { this.code = code; }

            public String getMessage() { return message; }
            public void setMessage(String message) { this.message = message; }

            public Map<String, Object> getDetails() { return details; }
            public void setDetails(Map<String, Object> details) { this.details = details; }
        }
    }

    @GetMapping("/formats")
    public ResponseEntity<?> getSupportedFormats(@RequestParam(required = false) String type,
                                                 @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        printRequest("type=" + type);

        try {
            // 1. 验证认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                Map<String, Object> details = new HashMap<>();
                details.put("auth", "缺少有效的认证令牌");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            String token = authHeader.substring(7);

            // 验证token并获取用户ID
            String userSql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(userSql, token);

            if (sessions.isEmpty()) {
                Map<String, Object> details = new HashMap<>();
                details.put("token", "令牌无效或已过期");
                ErrorResponse errorResponse = new ErrorResponse("UNAUTHORIZED", "未授权，需要重新登录", details);
                printResponse(errorResponse);
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
            }

            int userId = (int) sessions.get(0).get("user_id");

            // 2. 定义所有支持的格式
            Map<String, Object> formatsData = new HashMap<>();

            // 2.1 文档导出支持的格式
            Map<String, Object> documentsFormats = new HashMap<>();
            documentsFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", true, "适合打印和阅读"));
            documentsFormats.put("docx", createFormatInfo("Word", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "Microsoft Word文档", false, "适合编辑和修改"));
            documentsFormats.put("xlsx", createFormatInfo("Excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "Microsoft Excel表格", false, "适合数据分析和统计"));
            documentsFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", false, "适合导入其他系统"));
            documentsFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", false, "适合程序处理和数据交换"));
            documentsFormats.put("html", createFormatInfo("HTML", "text/html", "超文本标记语言", false, "适合网页浏览"));
            documentsFormats.put("txt", createFormatInfo("文本", "text/plain", "纯文本文件", false, "适合简单查看"));

            // 2.2 词汇导出支持的格式
            Map<String, Object> vocabularyFormats = new HashMap<>();
            vocabularyFormats.put("xlsx", createFormatInfo("Excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "Microsoft Excel表格", true, "推荐格式，包含完整信息"));
            vocabularyFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", false, "适合导入Anki等软件"));
            vocabularyFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", false, "适合程序处理"));
            vocabularyFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", false, "适合打印和阅读"));

            // 2.3 复习记录导出支持的格式
            Map<String, Object> reviewsFormats = new HashMap<>();
            reviewsFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", true, "推荐格式，适合数据分析"));
            reviewsFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", false, "适合程序处理"));
            reviewsFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", false, "适合打印报告"));
            reviewsFormats.put("xlsx", createFormatInfo("Excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "Microsoft Excel表格", false, "适合统计和图表"));

            // 2.4 学习统计导出支持的格式
            Map<String, Object> statisticsFormats = new HashMap<>();
            statisticsFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", true, "推荐格式，包含图表"));
            statisticsFormats.put("xlsx", createFormatInfo("Excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "Microsoft Excel表格", false, "适合进一步分析"));
            statisticsFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", false, "适合导入其他系统"));
            statisticsFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", false, "适合程序处理"));

            // 2.5 笔记导出支持的格式
            Map<String, Object> notesFormats = new HashMap<>();
            notesFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", true, "适合打印和阅读"));
            notesFormats.put("html", createFormatInfo("HTML", "text/html", "超文本标记语言", false, "适合网页浏览"));
            notesFormats.put("txt", createFormatInfo("文本", "text/plain", "纯文本文件", false, "适合简单查看"));
            notesFormats.put("docx", createFormatInfo("Word", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "Microsoft Word文档", false, "适合编辑"));

            // 2.6 高亮导出支持的格式
            Map<String, Object> highlightsFormats = new HashMap<>();
            highlightsFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", true, "推荐格式，保持数据结构"));
            highlightsFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", false, "适合导入其他系统"));
            highlightsFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", false, "适合打印"));

            // 2.7 阅读历史导出支持的格式
            Map<String, Object> readingHistoryFormats = new HashMap<>();
            readingHistoryFormats.put("csv", createFormatInfo("CSV", "text/csv", "逗号分隔值文件", true, "推荐格式，适合数据分析"));
            readingHistoryFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", false, "适合程序处理"));
            readingHistoryFormats.put("pdf", createFormatInfo("PDF", "application/pdf", "便携式文档格式", false, "适合打印报告"));

            // 2.8 批量导出支持的格式
            Map<String, Object> batchFormats = new HashMap<>();
            batchFormats.put("zip", createFormatInfo("ZIP", "application/zip", "压缩文件格式", true, "推荐格式，包含多个文件"));

            // 2.9 所有数据导出支持的格式
            Map<String, Object> allDataFormats = new HashMap<>();
            allDataFormats.put("json", createFormatInfo("JSON", "application/json", "JavaScript对象表示法", true, "推荐格式，保持完整数据结构"));

            // 3. 根据请求类型返回相应的格式
            if (type == null || type.isEmpty()) {
                // 返回所有类型的格式
                Map<String, Object> allFormats = new HashMap<>();
                allFormats.put("documents", documentsFormats);
                allFormats.put("vocabulary", vocabularyFormats);
                allFormats.put("reviews", reviewsFormats);
                allFormats.put("statistics", statisticsFormats);
                allFormats.put("notes", notesFormats);
                allFormats.put("highlights", highlightsFormats);
                allFormats.put("reading_history", readingHistoryFormats);
                allFormats.put("batch", batchFormats);
                allFormats.put("all_data", allDataFormats);

                formatsData.put("all_formats", allFormats);
                formatsData.put("total_types", 9);
            } else {
                // 返回特定类型的格式
                switch (type.toLowerCase()) {
                    case "documents":
                        formatsData.put("type", "documents");
                        formatsData.put("formats", documentsFormats);
                        formatsData.put("count", documentsFormats.size());
                        break;
                    case "vocabulary":
                        formatsData.put("type", "vocabulary");
                        formatsData.put("formats", vocabularyFormats);
                        formatsData.put("count", vocabularyFormats.size());
                        break;
                    case "reviews":
                        formatsData.put("type", "reviews");
                        formatsData.put("formats", reviewsFormats);
                        formatsData.put("count", reviewsFormats.size());
                        break;
                    case "statistics":
                        formatsData.put("type", "statistics");
                        formatsData.put("formats", statisticsFormats);
                        formatsData.put("count", statisticsFormats.size());
                        break;
                    case "notes":
                        formatsData.put("type", "notes");
                        formatsData.put("formats", notesFormats);
                        formatsData.put("count", notesFormats.size());
                        break;
                    case "highlights":
                        formatsData.put("type", "highlights");
                        formatsData.put("formats", highlightsFormats);
                        formatsData.put("count", highlightsFormats.size());
                        break;
                    case "reading_history":
                        formatsData.put("type", "reading_history");
                        formatsData.put("formats", readingHistoryFormats);
                        formatsData.put("count", readingHistoryFormats.size());
                        break;
                    case "batch":
                        formatsData.put("type", "batch");
                        formatsData.put("formats", batchFormats);
                        formatsData.put("count", batchFormats.size());
                        break;
                    case "all_data":
                        formatsData.put("type", "all_data");
                        formatsData.put("formats", allDataFormats);
                        formatsData.put("count", allDataFormats.size());
                        break;
                    default:
                        Map<String, Object> details = new HashMap<>();
                        details.put("type", type);
                        details.put("supported_types", Arrays.asList(
                                "documents", "vocabulary", "reviews", "statistics",
                                "notes", "highlights", "reading_history", "batch", "all_data"
                        ));
                        ErrorResponse errorResponse = new ErrorResponse("INVALID_TYPE", "不支持的导出类型", details);
                        printResponse(errorResponse);
                        return ResponseEntity.badRequest().body(errorResponse);
                }
            }

            // 4. 构建响应
            GetSupportedFormatsResponse response = new GetSupportedFormatsResponse(formatsData);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取支持格式过程中发生错误: " + e.getMessage());
            e.printStackTrace();

            Map<String, Object> details = new HashMap<>();
            details.put("exception", e.getMessage());
            ErrorResponse errorResponse = new ErrorResponse("FORMATS_QUERY_ERROR", "服务器内部错误: " + e.getMessage(), details);
            printResponse(errorResponse);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    // 创建格式信息
    private Map<String, Object> createFormatInfo(String displayName, String mimeType,
                                                 String description, boolean isRecommended,
                                                 String recommendationReason) {
        Map<String, Object> formatInfo = new HashMap<>();
        formatInfo.put("display_name", displayName);
        formatInfo.put("mime_type", mimeType);
        formatInfo.put("description", description);
        formatInfo.put("is_recommended", isRecommended);
        formatInfo.put("recommendation_reason", recommendationReason);
        formatInfo.put("file_extension", getExtensionFromMimeType(mimeType));

        return formatInfo;
    }

    // 从MIME类型获取文件扩展名
    private String getExtensionFromMimeType(String mimeType) {
        switch (mimeType) {
            case "application/pdf": return "pdf";
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.document": return "docx";
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": return "xlsx";
            case "text/csv": return "csv";
            case "application/json": return "json";
            case "text/html": return "html";
            case "text/plain": return "txt";
            case "application/zip": return "zip";
            default: return "bin";
        }
    }
}
--- 结束文件: GetSupportedFormats.java ---

