--- 开始文件: OfflineBatchDelete.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineBatchDelete {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到批量删除离线文档请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class BatchDeleteRequest {
        private String[] offline_doc_ids;

        public String[] getOffline_doc_ids() { return offline_doc_ids; }
        public void setOffline_doc_ids(String[] offline_doc_ids) { this.offline_doc_ids = offline_doc_ids; }
    }

    // 响应DTO
    public static class BatchDeleteResponse {
        private boolean success;
        private String message;
        private BatchDeleteData data;

        public BatchDeleteResponse(boolean success, String message, BatchDeleteData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public BatchDeleteData getData() { return data; }
        public void setData(BatchDeleteData data) { this.data = data; }
    }

    public static class BatchDeleteData {
        private int total;
        private int successCount;
        private int failCount;
        private List<DeleteResult> results;

        public BatchDeleteData(int total, int successCount, int failCount, List<DeleteResult> results) {
            this.total = total;
            this.successCount = successCount;
            this.failCount = failCount;
            this.results = results;
        }

        public int getTotal() { return total; }
        public void setTotal(int total) { this.total = total; }

        public int getSuccessCount() { return successCount; }
        public void setSuccessCount(int successCount) { this.successCount = successCount; }

        public int getFailCount() { return failCount; }
        public void setFailCount(int failCount) { this.failCount = failCount; }

        public List<DeleteResult> getResults() { return results; }
        public void setResults(List<DeleteResult> results) { this.results = results; }
    }

    public static class DeleteResult {
        private String offlineDocId;
        private boolean success;
        private String message;

        public DeleteResult(String offlineDocId, boolean success, String message) {
            this.offlineDocId = offlineDocId;
            this.success = success;
            this.message = message;
        }

        public String getOfflineDocId() { return offlineDocId; }
        public void setOfflineDocId(String offlineDocId) { this.offlineDocId = offlineDocId; }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @DeleteMapping("/documents/batch")
    public ResponseEntity<BatchDeleteResponse> batchDeleteOffline(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody BatchDeleteRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new BatchDeleteResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new BatchDeleteResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getOffline_doc_ids() == null || request.getOffline_doc_ids().length == 0) {
                return ResponseEntity.badRequest().body(
                        new BatchDeleteResponse(false, "请选择要删除的离线文档", null)
                );
            }

            String[] offlineDocIds = request.getOffline_doc_ids();
            if (offlineDocIds.length > 100) {
                return ResponseEntity.badRequest().body(
                        new BatchDeleteResponse(false, "一次最多删除100个离线文档", null)
                );
            }

            // 3. 处理每个离线文档的删除
            List<DeleteResult> results = new ArrayList<>();
            int successCount = 0;
            int failCount = 0;

            for (String offlineDocId : offlineDocIds) {
                try {
                    // 检查离线文档是否存在且属于该用户
                    String checkSql = "SELECT offline_doc_id FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
                    List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(checkSql, offlineDocId, userId);

                    if (offlineDocs.isEmpty()) {
                        results.add(new DeleteResult(offlineDocId, false, "离线文档不存在或无权删除"));
                        failCount++;
                        continue;
                    }

                    // 删除离线文档
                    String deleteSql = "DELETE FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
                    int rowsAffected = jdbcTemplate.update(deleteSql, offlineDocId, userId);

                    if (rowsAffected > 0) {
                        // 同时删除相关的下载记录
                        String deleteDownloadsSql = "DELETE FROM offline_downloads WHERE offline_doc_id = ? AND user_id = ?";
                        jdbcTemplate.update(deleteDownloadsSql, offlineDocId, userId);

                        results.add(new DeleteResult(offlineDocId, true, "删除成功"));
                        successCount++;
                    } else {
                        results.add(new DeleteResult(offlineDocId, false, "删除失败"));
                        failCount++;
                    }

                } catch (Exception e) {
                    results.add(new DeleteResult(offlineDocId, false, "处理失败: " + e.getMessage()));
                    failCount++;
                }
            }

            // 4. 准备响应数据
            BatchDeleteData data = new BatchDeleteData(offlineDocIds.length, successCount, failCount, results);
            BatchDeleteResponse response = new BatchDeleteResponse(true,
                    String.format("批量删除完成，成功%d个，失败%d个", successCount, failCount), data);

            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("批量删除离线文档过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new BatchDeleteResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineBatchDelete.java ---

--- 开始文件: OfflineBatchDownload.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineBatchDownload {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到批量下载文档到离线请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("===============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class BatchDownloadRequest {
        private String[] document_ids;

        public String[] getDocument_ids() { return document_ids; }
        public void setDocument_ids(String[] document_ids) { this.document_ids = document_ids; }
    }

    // 响应DTO
    public static class BatchDownloadResponse {
        private boolean success;
        private String message;
        private BatchDownloadData data;

        public BatchDownloadResponse(boolean success, String message, BatchDownloadData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public BatchDownloadData getData() { return data; }
        public void setData(BatchDownloadData data) { this.data = data; }
    }

    public static class BatchDownloadData {
        private String batchId;
        private int total;
        private int successCount;
        private int failCount;
        private List<DownloadResult> results;

        public BatchDownloadData(String batchId, int total, int successCount, int failCount, List<DownloadResult> results) {
            this.batchId = batchId;
            this.total = total;
            this.successCount = successCount;
            this.failCount = failCount;
            this.results = results;
        }

        public String getBatchId() { return batchId; }
        public void setBatchId(String batchId) { this.batchId = batchId; }

        public int getTotal() { return total; }
        public void setTotal(int total) { this.total = total; }

        public int getSuccessCount() { return successCount; }
        public void setSuccessCount(int successCount) { this.successCount = successCount; }

        public int getFailCount() { return failCount; }
        public void setFailCount(int failCount) { this.failCount = failCount; }

        public List<DownloadResult> getResults() { return results; }
        public void setResults(List<DownloadResult> results) { this.results = results; }
    }

    public static class DownloadResult {
        private String documentId;
        private boolean success;
        private String message;
        private String offlineDocId;
        private String downloadId;

        public DownloadResult(String documentId, boolean success, String message,
                              String offlineDocId, String downloadId) {
            this.documentId = documentId;
            this.success = success;
            this.message = message;
            this.offlineDocId = offlineDocId;
            this.downloadId = downloadId;
        }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public String getOfflineDocId() { return offlineDocId; }
        public void setOfflineDocId(String offlineDocId) { this.offlineDocId = offlineDocId; }

        public String getDownloadId() { return downloadId; }
        public void setDownloadId(String downloadId) { this.downloadId = downloadId; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/documents/batch-download")
    public ResponseEntity<BatchDownloadResponse> batchDownloadOffline(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody BatchDownloadRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new BatchDownloadResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new BatchDownloadResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getDocument_ids() == null || request.getDocument_ids().length == 0) {
                return ResponseEntity.badRequest().body(
                        new BatchDownloadResponse(false, "请选择要下载的文档", null)
                );
            }

            String[] documentIds = request.getDocument_ids();
            if (documentIds.length > 100) {
                return ResponseEntity.badRequest().body(
                        new BatchDownloadResponse(false, "一次最多下载100个文档", null)
                );
            }

            // 3. 生成批量ID
            String batchId = "batch_" + UUID.randomUUID().toString();

            // 4. 处理每个文档的下载
            List<DownloadResult> results = new ArrayList<>();
            int successCount = 0;
            int failCount = 0;

            for (String documentId : documentIds) {
                try {
                    // 检查文档是否存在
                    String checkDocSql = "SELECT document_id, title FROM documents WHERE document_id = ?";
                    List<Map<String, Object>> documents = jdbcTemplate.queryForList(checkDocSql, documentId);

                    if (documents.isEmpty()) {
                        results.add(new DownloadResult(documentId, false, "文档不存在", null, null));
                        failCount++;
                        continue;
                    }

                    Map<String, Object> document = documents.get(0);
                    String title = (String) document.get("title");

                    // 检查是否已经离线下载过
                    String checkOfflineSql = "SELECT offline_doc_id FROM offline_documents WHERE document_id = ? AND user_id = ?";
                    List<Map<String, Object>> existingOffline = jdbcTemplate.queryForList(checkOfflineSql, documentId, userId);

                    String offlineDocId;
                    if (!existingOffline.isEmpty()) {
                        // 已经存在，更新版本
                        offlineDocId = (String) existingOffline.get(0).get("offline_doc_id");
                        String updateSql = "UPDATE offline_documents SET offline_version = offline_version + 1, " +
                                "updated_at = NOW() WHERE offline_doc_id = ?";
                        jdbcTemplate.update(updateSql, offlineDocId);
                    } else {
                        // 创建新的离线文档记录
                        offlineDocId = "offline_doc_" + UUID.randomUUID().toString();
                        String insertSql = "INSERT INTO offline_documents (offline_doc_id, document_id, user_id, title, " +
                                "download_url, created_at) VALUES (?, ?, ?, ?, ?, NOW())";
                        jdbcTemplate.update(insertSql, offlineDocId, documentId, userId, title,
                                "/api/offline/documents/" + offlineDocId + "/download");
                    }

                    // 创建下载任务
                    String downloadId = "dl_" + UUID.randomUUID().toString();
                    String insertDownloadSql = "INSERT INTO offline_downloads (download_id, user_id, document_id, " +
                            "offline_doc_id, status, progress, start_time, batch_id) " +
                            "VALUES (?, ?, ?, ?, 'pending', 0, NOW(), ?)";
                    jdbcTemplate.update(insertDownloadSql, downloadId, userId, documentId, offlineDocId, batchId);

                    results.add(new DownloadResult(documentId, true, "下载任务已创建", offlineDocId, downloadId));
                    successCount++;

                    // 启动异步下载任务（简化处理）
                    new Thread(() -> {
                        try {
                            Thread.sleep(1000);
                            String updateSql = "UPDATE offline_downloads SET status = 'completed', progress = 100, " +
                                    "end_time = NOW() WHERE download_id = ?";
                            jdbcTemplate.update(updateSql, downloadId);

                            String updateOfflineSql = "UPDATE offline_documents SET is_synced = TRUE, updated_at = NOW() " +
                                    "WHERE offline_doc_id = ?";
                            jdbcTemplate.update(updateOfflineSql, offlineDocId);

                        } catch (Exception e) {
                            System.err.println("下载任务执行失败: " + e.getMessage());
                        }
                    }).start();

                } catch (Exception e) {
                    results.add(new DownloadResult(documentId, false, "处理失败: " + e.getMessage(), null, null));
                    failCount++;
                }
            }

            // 5. 准备响应数据
            BatchDownloadData data = new BatchDownloadData(batchId, documentIds.length, successCount, failCount, results);
            BatchDownloadResponse response = new BatchDownloadResponse(true,
                    String.format("批量下载任务已提交，成功%d个，失败%d个", successCount, failCount), data);

            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("批量下载文档到离线过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new BatchDownloadResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineBatchDownload.java ---

--- 开始文件: OfflineCancelDownload.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineCancelDownload {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到取消离线下载请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class CancelDownloadResponse {
        private boolean success;
        private String message;

        public CancelDownloadResponse(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @DeleteMapping("/downloads/{downloadId}")
    public ResponseEntity<CancelDownloadResponse> cancelOfflineDownload(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String downloadId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("downloadId", downloadId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new CancelDownloadResponse(false, "请先登录")
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new CancelDownloadResponse(false, "登录已过期，请重新登录")
                );
            }

            // 2. 检查下载任务是否存在且属于该用户
            String checkSql = "SELECT download_id, status FROM offline_downloads WHERE download_id = ? AND user_id = ?";
            List<Map<String, Object>> downloads = jdbcTemplate.queryForList(checkSql, downloadId, userId);

            if (downloads.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new CancelDownloadResponse(false, "下载任务不存在或无权取消")
                );
            }

            Map<String, Object> download = downloads.get(0);
            String status = (String) download.get("status");

            // 3. 检查是否可以取消（只有pending或downloading状态可以取消）
            if ("completed".equals(status) || "failed".equals(status) || "cancelled".equals(status)) {
                return ResponseEntity.badRequest().body(
                        new CancelDownloadResponse(false, "下载任务已结束，无法取消")
                );
            }

            // 4. 取消下载任务
            String updateSql = "UPDATE offline_downloads SET status = 'cancelled', error = '用户取消', " +
                    "end_time = NOW() WHERE download_id = ? AND user_id = ?";
            int rowsAffected = jdbcTemplate.update(updateSql, downloadId, userId);

            printQueryResult("取消行数: " + rowsAffected);

            if (rowsAffected > 0) {
                CancelDownloadResponse response = new CancelDownloadResponse(true, "下载任务已取消");
                printResponse(response);

                return ResponseEntity.ok(response);
            } else {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                        new CancelDownloadResponse(false, "取消失败")
                );
            }

        } catch (Exception e) {
            System.err.println("取消离线下载过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new CancelDownloadResponse(false, "服务器内部错误: " + e.getMessage())
            );
        }
    }
}
--- 结束文件: OfflineCancelDownload.java ---

--- 开始文件: OfflineCancelSyncTask.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineCancelSyncTask {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到取消同步任务请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class CancelSyncTaskResponse {
        private boolean success;
        private String message;

        public CancelSyncTaskResponse(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @DeleteMapping("/sync/task/{taskId}")
    public ResponseEntity<CancelSyncTaskResponse> cancelSyncTask(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String taskId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("taskId", taskId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new CancelSyncTaskResponse(false, "请先登录")
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new CancelSyncTaskResponse(false, "登录已过期，请重新登录")
                );
            }

            // 2. 检查同步任务是否存在且属于该用户
            String checkSql = "SELECT task_id, status FROM offline_sync_tasks WHERE task_id = ? AND user_id = ?";
            List<Map<String, Object>> tasks = jdbcTemplate.queryForList(checkSql, taskId, userId);

            if (tasks.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new CancelSyncTaskResponse(false, "同步任务不存在或无权取消")
                );
            }

            Map<String, Object> task = tasks.get(0);
            String status = (String) task.get("status");

            // 3. 检查是否可以取消（只有running状态可以取消）
            if ("completed".equals(status) || "failed".equals(status) || "cancelled".equals(status)) {
                return ResponseEntity.badRequest().body(
                        new CancelSyncTaskResponse(false, "同步任务已结束，无法取消")
                );
            }

            // 4. 取消同步任务
            String updateSql = "UPDATE offline_sync_tasks SET status = 'cancelled', end_time = NOW(), " +
                    "error = '用户取消' WHERE task_id = ? AND user_id = ?";
            int rowsAffected = jdbcTemplate.update(updateSql, taskId, userId);

            printQueryResult("取消行数: " + rowsAffected);

            if (rowsAffected > 0) {
                // 5. 添加取消记录到历史表
                addSyncHistory(userId, taskId, "cancelled", "用户取消");

                CancelSyncTaskResponse response = new CancelSyncTaskResponse(true, "同步任务已取消");
                printResponse(response);

                return ResponseEntity.ok(response);
            } else {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                        new CancelSyncTaskResponse(false, "取消失败")
                );
            }

        } catch (Exception e) {
            System.err.println("取消同步任务过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new CancelSyncTaskResponse(false, "服务器内部错误: " + e.getMessage())
            );
        }
    }

    // 添加同步历史记录
    private void addSyncHistory(Integer userId, String taskId, String status, String error) {
        try {
            // 创建 offline_sync_history 表（如果不存在）
            String createTableSql = "CREATE TABLE IF NOT EXISTS offline_sync_history (" +
                    "sync_hist_id VARCHAR(50) PRIMARY KEY, " +
                    "user_id INT NOT NULL, " +
                    "task_id VARCHAR(50) NOT NULL, " +
                    "task_type VARCHAR(50), " +
                    "status VARCHAR(20) NOT NULL, " +
                    "synced_items INT DEFAULT 0, " +
                    "failed_items INT DEFAULT 0, " +
                    "duration DOUBLE DEFAULT 0, " +
                    "error TEXT, " +
                    "start_time TIMESTAMP, " +
                    "end_time TIMESTAMP, " +
                    "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                    "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                    ")";
            jdbcTemplate.execute(createTableSql);

            // 查询任务信息
            String querySql = "SELECT task_type, start_time FROM offline_sync_tasks WHERE task_id = ? AND user_id = ?";
            List<Map<String, Object>> taskInfo = jdbcTemplate.queryForList(querySql, taskId, userId);

            if (!taskInfo.isEmpty()) {
                Map<String, Object> row = taskInfo.get(0);
                String taskType = (String) row.get("task_type");
                String startTime = row.get("start_time").toString();

                // 计算持续时间（秒）
                long duration = (System.currentTimeMillis() - java.sql.Timestamp.valueOf(startTime).getTime()) / 1000;

                // 插入历史记录
                String syncHistId = "sync_hist_" + System.currentTimeMillis() + "_" + userId;
                String insertSql = "INSERT INTO offline_sync_history (sync_hist_id, user_id, task_id, task_type, " +
                        "status, synced_items, failed_items, duration, error, start_time, end_time, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, 0, 0, ?, ?, ?, NOW(), NOW())";
                jdbcTemplate.update(insertSql, syncHistId, userId, taskId, taskType, status,
                        duration, error, startTime);
            }

        } catch (Exception e) {
            System.err.println("添加同步历史记录失败: " + e.getMessage());
        }
    }
}
--- 结束文件: OfflineCancelSyncTask.java ---

--- 开始文件: OfflineCheckDocumentStatus.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineCheckDocumentStatus {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到检查文档是否已离线请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("================================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class DocumentStatusResponse {
        private boolean success;
        private String message;
        private DocumentStatusData data;

        public DocumentStatusResponse(boolean success, String message, DocumentStatusData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public DocumentStatusData getData() { return data; }
        public void setData(DocumentStatusData data) { this.data = data; }
    }

    public static class DocumentStatusData {
        private String documentId;
        private boolean isOffline;
        private String offlineDocId;
        private String downloadUrl;
        private boolean isSynced;
        private int offlineVersion;
        private String updatedAt;
        private String createdAt;

        public DocumentStatusData(String documentId, boolean isOffline, String offlineDocId,
                                  String downloadUrl, boolean isSynced, int offlineVersion,
                                  String updatedAt, String createdAt) {
            this.documentId = documentId;
            this.isOffline = isOffline;
            this.offlineDocId = offlineDocId;
            this.downloadUrl = downloadUrl;
            this.isSynced = isSynced;
            this.offlineVersion = offlineVersion;
            this.updatedAt = updatedAt;
            this.createdAt = createdAt;
        }

        // Getters and Setters
        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public boolean isOffline() { return isOffline; }
        public void setOffline(boolean offline) { isOffline = offline; }

        public String getOfflineDocId() { return offlineDocId; }
        public void setOfflineDocId(String offlineDocId) { this.offlineDocId = offlineDocId; }

        public String getDownloadUrl() { return downloadUrl; }
        public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }

        public boolean isSynced() { return isSynced; }
        public void setSynced(boolean synced) { isSynced = synced; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/documents/{documentId}/status")
    public ResponseEntity<DocumentStatusResponse> checkDocumentOfflineStatus(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String documentId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("documentId", documentId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DocumentStatusResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DocumentStatusResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 检查文档是否存在
            String checkDocSql = "SELECT document_id, title FROM documents WHERE document_id = ?";
            List<Map<String, Object>> documents = jdbcTemplate.queryForList(checkDocSql, documentId);

            if (documents.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new DocumentStatusResponse(false, "文档不存在", null)
                );
            }

            Map<String, Object> document = documents.get(0);
            String title = (String) document.get("title");

            // 3. 检查是否已离线下载
            String checkOfflineSql = "SELECT * FROM offline_documents WHERE document_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(checkOfflineSql, documentId, userId);
            printQueryResult(offlineDocs);

            if (offlineDocs.isEmpty()) {
                // 文档未离线下载
                DocumentStatusData data = new DocumentStatusData(
                        documentId,
                        false,
                        null,
                        null,
                        false,
                        0,
                        null,
                        null
                );

                DocumentStatusResponse response = new DocumentStatusResponse(true, "文档未离线下载", data);
                printResponse(response);

                return ResponseEntity.ok(response);
            } else {
                // 文档已离线下载
                Map<String, Object> offlineDoc = offlineDocs.get(0);

                DocumentStatusData data = new DocumentStatusData(
                        documentId,
                        true,
                        (String) offlineDoc.get("offline_doc_id"),
                        (String) offlineDoc.get("download_url"),
                        offlineDoc.get("is_synced") != null && (Boolean) offlineDoc.get("is_synced"),
                        offlineDoc.get("offline_version") != null ? ((Number) offlineDoc.get("offline_version")).intValue() : 1,
                        offlineDoc.get("updated_at") != null ? offlineDoc.get("updated_at").toString() : null,
                        offlineDoc.get("created_at") != null ? offlineDoc.get("created_at").toString() : null
                );

                DocumentStatusResponse response = new DocumentStatusResponse(true, "文档已离线下载", data);
                printResponse(response);

                return ResponseEntity.ok(response);
            }

        } catch (Exception e) {
            System.err.println("检查文档是否已离线过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new DocumentStatusResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineCheckDocumentStatus.java ---

--- 开始文件: OfflineClearCache.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineClearCache {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到清理离线缓存请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class ClearCacheResponse {
        private boolean success;
        private String message;
        private ClearCacheData data;

        public ClearCacheResponse(boolean success, String message, ClearCacheData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public ClearCacheData getData() { return data; }
        public void setData(ClearCacheData data) { this.data = data; }
    }

    public static class ClearCacheData {
        private int deletedDocuments;
        private int deletedDownloads;
        private long freedSpace;

        public ClearCacheData(int deletedDocuments, int deletedDownloads, long freedSpace) {
            this.deletedDocuments = deletedDocuments;
            this.deletedDownloads = deletedDownloads;
            this.freedSpace = freedSpace;
        }

        // Getters and Setters
        public int getDeletedDocuments() { return deletedDocuments; }
        public void setDeletedDocuments(int deletedDocuments) { this.deletedDocuments = deletedDocuments; }

        public int getDeletedDownloads() { return deletedDownloads; }
        public void setDeletedDownloads(int deletedDownloads) { this.deletedDownloads = deletedDownloads; }

        public long getFreedSpace() { return freedSpace; }
        public void setFreedSpace(long freedSpace) { this.freedSpace = freedSpace; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @DeleteMapping("/cache")
    public ResponseEntity<ClearCacheResponse> clearOfflineCache(
            @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new ClearCacheResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new ClearCacheResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 统计清理前的数据
            String countDocsSql = "SELECT COUNT(*) as count, SUM(file_size) as total_size " +
                    "FROM offline_documents WHERE user_id = ?";
            List<Map<String, Object>> docStats = jdbcTemplate.queryForList(countDocsSql, userId);

            int deletedDocuments = 0;
            long freedSpace = 0;

            if (!docStats.isEmpty()) {
                Map<String, Object> row = docStats.get(0);
                deletedDocuments = row.get("count") != null ? ((Number) row.get("count")).intValue() : 0;
                freedSpace = row.get("total_size") != null ? ((Number) row.get("total_size")).longValue() : 0;
            }

            // 3. 删除离线文档
            String deleteDocsSql = "DELETE FROM offline_documents WHERE user_id = ?";
            int docsDeleted = jdbcTemplate.update(deleteDocsSql, userId);

            // 4. 删除下载记录
            String deleteDownloadsSql = "DELETE FROM offline_downloads WHERE user_id = ?";
            int downloadsDeleted = jdbcTemplate.update(deleteDownloadsSql, userId);

            printQueryResult("删除文档: " + docsDeleted + ", 删除下载记录: " + downloadsDeleted);

            // 5. 准备响应数据
            ClearCacheData data = new ClearCacheData(docsDeleted, downloadsDeleted, freedSpace);
            ClearCacheResponse response = new ClearCacheResponse(true,
                    String.format("离线缓存清理成功，释放了 %.2f MB 空间", freedSpace / (1024.0 * 1024.0)), data);

            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("清理离线缓存过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new ClearCacheResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineClearCache.java ---

--- 开始文件: OfflineDeleteDocument.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineDeleteDocument {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到删除离线文档请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class DeleteDocumentResponse {
        private boolean success;
        private String message;

        public DeleteDocumentResponse(boolean success, String message) {
            this.success = success;
            this.message = message;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @DeleteMapping("/documents/{offlineDocId}")
    public ResponseEntity<DeleteDocumentResponse> deleteOfflineDocument(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String offlineDocId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("offlineDocId", offlineDocId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DeleteDocumentResponse(false, "请先登录")
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DeleteDocumentResponse(false, "登录已过期，请重新登录")
                );
            }

            // 2. 检查离线文档是否存在且属于该用户
            String checkSql = "SELECT offline_doc_id FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(checkSql, offlineDocId, userId);

            if (offlineDocs.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new DeleteDocumentResponse(false, "离线文档不存在或无权删除")
                );
            }

            // 3. 删除离线文档
            String deleteSql = "DELETE FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
            int rowsAffected = jdbcTemplate.update(deleteSql, offlineDocId, userId);

            printQueryResult("删除行数: " + rowsAffected);

            if (rowsAffected > 0) {
                // 4. 同时删除相关的下载记录
                String deleteDownloadsSql = "DELETE FROM offline_downloads WHERE offline_doc_id = ? AND user_id = ?";
                jdbcTemplate.update(deleteDownloadsSql, offlineDocId, userId);

                DeleteDocumentResponse response = new DeleteDocumentResponse(true, "离线文档删除成功");
                printResponse(response);

                return ResponseEntity.ok(response);
            } else {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                        new DeleteDocumentResponse(false, "删除失败")
                );
            }

        } catch (Exception e) {
            System.err.println("删除离线文档过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new DeleteDocumentResponse(false, "服务器内部错误: " + e.getMessage())
            );
        }
    }
}
--- 结束文件: OfflineDeleteDocument.java ---

--- 开始文件: OfflineDownloadDocument.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineDownloadDocument {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到下载文档到离线请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class DownloadDocumentRequest {
        private String documentId;

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }
    }

    // 响应DTO
    public static class DownloadDocumentResponse {
        private boolean success;
        private String message;
        private DownloadDocumentData data;

        public DownloadDocumentResponse(boolean success, String message, DownloadDocumentData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public DownloadDocumentData getData() { return data; }
        public void setData(DownloadDocumentData data) { this.data = data; }
    }

    public static class DownloadDocumentData {
        private String offlineDocId;
        private String downloadId;
        private String status;
        private int progress;

        public DownloadDocumentData(String offlineDocId, String downloadId, String status, int progress) {
            this.offlineDocId = offlineDocId;
            this.downloadId = downloadId;
            this.status = status;
            this.progress = progress;
        }

        public String getOfflineDocId() { return offlineDocId; }
        public void setOfflineDocId(String offlineDocId) { this.offlineDocId = offlineDocId; }

        public String getDownloadId() { return downloadId; }
        public void setDownloadId(String downloadId) { this.downloadId = downloadId; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }

        public int getProgress() { return progress; }
        public void setProgress(int progress) { this.progress = progress; }
    }

    // 创建 offline_downloads 表（如果不存在）
    private void createOfflineDownloadsTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_downloads (" +
                "download_id VARCHAR(50) PRIMARY KEY, " +
                "user_id INT NOT NULL, " +
                "document_id VARCHAR(50) NOT NULL, " +
                "offline_doc_id VARCHAR(50), " +
                "status VARCHAR(20) DEFAULT 'pending', " +
                "progress INT DEFAULT 0, " +
                "file_size BIGINT DEFAULT 0, " +
                "downloaded_size BIGINT DEFAULT 0, " +
                "speed VARCHAR(50), " +
                "eta VARCHAR(50), " +
                "error TEXT, " +
                "start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "end_time TIMESTAMP, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_downloads 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_downloads 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/documents/{documentId}/download")
    public ResponseEntity<DownloadDocumentResponse> downloadDocumentOffline(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String documentId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("documentId", documentId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DownloadDocumentResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DownloadDocumentResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证文档是否存在
            String checkDocSql = "SELECT document_id, title, content FROM documents WHERE document_id = ?";
            List<Map<String, Object>> documents = jdbcTemplate.queryForList(checkDocSql, documentId);

            if (documents.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new DownloadDocumentResponse(false, "文档不存在", null)
                );
            }

            Map<String, Object> document = documents.get(0);
            String title = (String) document.get("title");
            String content = (String) document.get("content");

            // 3. 创建相关表
            createOfflineDownloadsTableIfNotExists();

            // 4. 检查是否已经离线下载过
            String checkOfflineSql = "SELECT offline_doc_id FROM offline_documents WHERE document_id = ? AND user_id = ?";
            List<Map<String, Object>> existingOffline = jdbcTemplate.queryForList(checkOfflineSql, documentId, userId);

            String offlineDocId;
            if (!existingOffline.isEmpty()) {
                // 已经存在，更新版本
                offlineDocId = (String) existingOffline.get(0).get("offline_doc_id");
                String updateSql = "UPDATE offline_documents SET offline_version = offline_version + 1, " +
                        "updated_at = NOW() WHERE offline_doc_id = ?";
                jdbcTemplate.update(updateSql, offlineDocId);
            } else {
                // 创建新的离线文档记录
                offlineDocId = "offline_doc_" + UUID.randomUUID().toString();
                String insertSql = "INSERT INTO offline_documents (offline_doc_id, document_id, user_id, title, content, " +
                        "download_url, created_at) VALUES (?, ?, ?, ?, ?, ?, NOW())";
                jdbcTemplate.update(insertSql, offlineDocId, documentId, userId, title, content,
                        "/api/offline/documents/" + offlineDocId + "/download");
            }

            // 5. 创建下载任务
            String downloadId = "dl_" + UUID.randomUUID().toString();
            String insertDownloadSql = "INSERT INTO offline_downloads (download_id, user_id, document_id, " +
                    "offline_doc_id, status, progress, start_time) VALUES (?, ?, ?, ?, 'pending', 0, NOW())";
            jdbcTemplate.update(insertDownloadSql, downloadId, userId, documentId, offlineDocId);

            // 6. 模拟下载过程（实际项目中应该是异步任务）
            // 这里简单模拟，实际应该使用线程池或消息队列
            new Thread(() -> {
                try {
                    // 更新状态为下载中
                    String updateStatusSql = "UPDATE offline_downloads SET status = 'downloading', progress = 10 WHERE download_id = ?";
                    jdbcTemplate.update(updateStatusSql, downloadId);

                    Thread.sleep(1000); // 模拟下载时间

                    // 更新进度
                    updateStatusSql = "UPDATE offline_downloads SET progress = 50 WHERE download_id = ?";
                    jdbcTemplate.update(updateStatusSql, downloadId);

                    Thread.sleep(1000);

                    // 完成下载
                    updateStatusSql = "UPDATE offline_downloads SET status = 'completed', progress = 100, " +
                            "end_time = NOW() WHERE download_id = ?";
                    jdbcTemplate.update(updateStatusSql, downloadId);

                    // 更新离线文档状态
                    String updateOfflineSql = "UPDATE offline_documents SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE offline_doc_id = ?";
                    jdbcTemplate.update(updateOfflineSql, offlineDocId);

                } catch (InterruptedException e) {
                    // 下载失败
                    String updateStatusSql = "UPDATE offline_downloads SET status = 'failed', error = ?, " +
                            "end_time = NOW() WHERE download_id = ?";
                    jdbcTemplate.update(updateStatusSql, "下载中断", downloadId);
                }
            }).start();

            // 7. 准备响应数据
            DownloadDocumentData data = new DownloadDocumentData(offlineDocId, downloadId, "pending", 0);
            DownloadDocumentResponse response = new DownloadDocumentResponse(true, "文档下载任务已开始", data);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("下载文档到离线过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new DownloadDocumentResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineDownloadDocument.java ---

--- 开始文件: OfflineGetDocumentById.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetDocumentById {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取单个离线文档详情请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("================================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class OfflineDocumentResponse {
        private boolean success;
        private String message;
        private OfflineDocumentData data;

        public OfflineDocumentResponse(boolean success, String message, OfflineDocumentData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public OfflineDocumentData getData() { return data; }
        public void setData(OfflineDocumentData data) { this.data = data; }
    }

    public static class OfflineDocumentData {
        private OfflineDocument document;

        public OfflineDocumentData(OfflineDocument document) {
            this.document = document;
        }

        public OfflineDocument getDocument() { return document; }
        public void setDocument(OfflineDocument document) { this.document = document; }
    }

    public static class OfflineDocument {
        private String id;
        private String documentId;
        private String title;
        private String content;
        private String description;
        private List<String> tags;
        private long fileSize;
        private String fileType;
        private String downloadUrl;
        private boolean isSynced;
        private int offlineVersion;
        private String updatedAt;
        private String createdAt;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public List<String> getTags() { return tags; }
        public void setTags(List<String> tags) { this.tags = tags; }

        public long getFileSize() { return fileSize; }
        public void setFileSize(long fileSize) { this.fileSize = fileSize; }

        public String getFileType() { return fileType; }
        public void setFileType(String fileType) { this.fileType = fileType; }

        public String getDownloadUrl() { return downloadUrl; }
        public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }

        public boolean isSynced() { return isSynced; }
        public void setSynced(boolean synced) { isSynced = synced; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/documents/{offlineDocId}")
    public ResponseEntity<OfflineDocumentResponse> getOfflineDocumentById(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String offlineDocId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("offlineDocId", offlineDocId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineDocumentResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineDocumentResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 查询离线文档详情
            String querySql = "SELECT * FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(querySql, offlineDocId, userId);
            printQueryResult(offlineDocs);

            if (offlineDocs.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new OfflineDocumentResponse(false, "离线文档不存在", null)
                );
            }

            Map<String, Object> row = offlineDocs.get(0);

            // 3. 转换为DTO对象
            OfflineDocument doc = new OfflineDocument();
            doc.setId((String) row.get("offline_doc_id"));
            doc.setDocumentId((String) row.get("document_id"));
            doc.setTitle((String) row.get("title"));
            doc.setContent((String) row.get("content"));
            doc.setDescription((String) row.get("description"));

            // 解析tags JSON
            String tagsJson = (String) row.get("tags");
            if (tagsJson != null && !tagsJson.isEmpty()) {
                try {
                    List<String> tags = objectMapper.readValue(tagsJson, new TypeReference<List<String>>() {});
                    doc.setTags(tags);
                } catch (Exception e) {
                    doc.setTags(new ArrayList<>());
                }
            } else {
                doc.setTags(new ArrayList<>());
            }

            doc.setFileSize(row.get("file_size") != null ? ((Number) row.get("file_size")).longValue() : 0);
            doc.setFileType((String) row.get("file_type"));
            doc.setDownloadUrl((String) row.get("download_url"));
            doc.setSynced(row.get("is_synced") != null && (Boolean) row.get("is_synced"));
            doc.setOfflineVersion(row.get("offline_version") != null ? ((Number) row.get("offline_version")).intValue() : 1);
            doc.setUpdatedAt(row.get("updated_at") != null ? row.get("updated_at").toString() : null);
            doc.setCreatedAt(row.get("created_at") != null ? row.get("created_at").toString() : null);

            // 4. 准备响应数据
            OfflineDocumentData data = new OfflineDocumentData(doc);
            OfflineDocumentResponse response = new OfflineDocumentResponse(true, "获取离线文档详情成功", data);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取离线文档详情过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new OfflineDocumentResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineGetDocumentById.java ---

--- 开始文件: OfflineGetDocuments.java ---
package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetDocuments {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取离线文档列表请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class OfflineDocumentsResponse {
        private boolean success;
        private String message;
        private OfflineDocumentsData data;

        public OfflineDocumentsResponse(boolean success, String message, OfflineDocumentsData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public OfflineDocumentsData getData() { return data; }
        public void setData(OfflineDocumentsData data) { this.data = data; }
    }

    public static class OfflineDocumentsData {
        private List<OfflineDocument> documents;
        private Pagination pagination;

        public OfflineDocumentsData(List<OfflineDocument> documents, Pagination pagination) {
            this.documents = documents;
            this.pagination = pagination;
        }

        public List<OfflineDocument> getDocuments() { return documents; }
        public void setDocuments(List<OfflineDocument> documents) { this.documents = documents; }

        public Pagination getPagination() { return pagination; }
        public void setPagination(Pagination pagination) { this.pagination = pagination; }
    }

    public static class OfflineDocument {
        private String id;
        private String documentId;
        private String title;
        private String content;
        private String description;
        private List<String> tags;
        private long fileSize;
        private String fileType;
        private String downloadUrl;
        private boolean isSynced;
        private int offlineVersion;
        private String updatedAt;
        private String createdAt;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public List<String> getTags() { return tags; }
        public void setTags(List<String> tags) { this.tags = tags; }

        public long getFileSize() { return fileSize; }
        public void setFileSize(long fileSize) { this.fileSize = fileSize; }

        public String getFileType() { return fileType; }
        public void setFileType(String fileType) { this.fileType = fileType; }

        public String getDownloadUrl() { return downloadUrl; }
        public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }

        public boolean isSynced() { return isSynced; }
        public void setSynced(boolean synced) { isSynced = synced; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
    }

    public static class Pagination {
        private int page;
        private int pageSize;
        private int total;
        private int totalPages;

        public Pagination(int page, int pageSize, int total, int totalPages) {
            this.page = page;
            this.pageSize = pageSize;
            this.total = total;
            this.totalPages = totalPages;
        }

        public int getPage() { return page; }
        public void setPage(int page) { this.page = page; }

        public int getPageSize() { return pageSize; }
        public void setPageSize(int pageSize) { this.pageSize = pageSize; }

        public int getTotal() { return total; }
        public void setTotal(int total) { this.total = total; }

        public int getTotalPages() { return totalPages; }
        public void setTotalPages(int totalPages) { this.totalPages = totalPages; }
    }

    // 创建 offline_documents 表（如果不存在）
    private void createOfflineDocumentsTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_documents (" +
                "offline_doc_id VARCHAR(50) PRIMARY KEY, " +
                "document_id VARCHAR(50) NOT NULL, " +
                "user_id INT NOT NULL, " +
                "title VARCHAR(500) NOT NULL, " +
                "content LONGTEXT, " +
                "description TEXT, " +
                "tags JSON, " +
                "file_size BIGINT DEFAULT 0, " +
                "file_type VARCHAR(50), " +
                "download_url VARCHAR(500), " +
                "is_synced BOOLEAN DEFAULT FALSE, " +
                "offline_version INT DEFAULT 1, " +
                "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE, " +
                "FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_documents 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_documents 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            // 从 user_sessions 表中验证token
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/documents")
    public ResponseEntity<OfflineDocumentsResponse> getOfflineDocuments(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestParam(value = "page", defaultValue = "1") int page,
            @RequestParam(value = "pageSize", defaultValue = "20") int pageSize) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("page", page);
        requestInfo.put("pageSize", pageSize);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineDocumentsResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineDocumentsResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 创建表（如果不存在）
            createOfflineDocumentsTableIfNotExists();

            // 3. 计算分页参数
            int offset = (page - 1) * pageSize;

            // 4. 查询总记录数
            String countSql = "SELECT COUNT(*) as total FROM offline_documents WHERE user_id = ?";
            int total = jdbcTemplate.queryForObject(countSql, Integer.class, userId);

            // 5. 查询离线文档列表
            String querySql = "SELECT * FROM offline_documents WHERE user_id = ? ORDER BY updated_at DESC LIMIT ? OFFSET ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(querySql, userId, pageSize, offset);
            printQueryResult(offlineDocs);

            // 6. 转换为DTO对象
            List<OfflineDocument> documents = new ArrayList<>();

            for (Map<String, Object> row : offlineDocs) {
                OfflineDocument doc = new OfflineDocument();
                doc.setId((String) row.get("offline_doc_id"));
                doc.setDocumentId((String) row.get("document_id"));
                doc.setTitle((String) row.get("title"));
                doc.setContent((String) row.get("content"));
                doc.setDescription((String) row.get("description"));

                // 解析tags JSON
                String tagsJson = (String) row.get("tags");
                if (tagsJson != null && !tagsJson.isEmpty()) {
                    try {
                        List<String> tags = objectMapper.readValue(tagsJson, new TypeReference<List<String>>() {});
                        doc.setTags(tags);
                    } catch (Exception e) {
                        doc.setTags(new ArrayList<>());
                    }
                } else {
                    doc.setTags(new ArrayList<>());
                }

                doc.setFileSize(row.get("file_size") != null ? ((Number) row.get("file_size")).longValue() : 0);
                doc.setFileType((String) row.get("file_type"));
                doc.setDownloadUrl((String) row.get("download_url"));
                doc.setSynced(row.get("is_synced") != null && (Boolean) row.get("is_synced"));
                doc.setOfflineVersion(row.get("offline_version") != null ? ((Number) row.get("offline_version")).intValue() : 1);
                doc.setUpdatedAt(row.get("updated_at") != null ? row.get("updated_at").toString() : null);
                doc.setCreatedAt(row.get("created_at") != null ? row.get("created_at").toString() : null);

                documents.add(doc);
            }

            // 7. 计算分页信息
            int totalPages = (int) Math.ceil((double) total / pageSize);
            Pagination pagination = new Pagination(page, pageSize, total, totalPages);

            // 8. 准备响应数据
            OfflineDocumentsData data = new OfflineDocumentsData(documents, pagination);
            OfflineDocumentsResponse response = new OfflineDocumentsResponse(true, "获取离线文档列表成功", data);

            // 打印返回数据
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取离线文档列表过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new OfflineDocumentsResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}

--- 结束文件: OfflineGetDocuments.java ---

--- 开始文件: OfflineGetDownloadStatus.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetDownloadStatus {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取离线下载状态请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class DownloadStatusResponse {
        private boolean success;
        private String message;
        private DownloadStatusData data;

        public DownloadStatusResponse(boolean success, String message, DownloadStatusData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public DownloadStatusData getData() { return data; }
        public void setData(DownloadStatusData data) { this.data = data; }
    }

    public static class DownloadStatusData {
        private String downloadId;
        private String status;
        private int progress;
        private String speed;
        private String eta;
        private String documentId;
        private String documentTitle;
        private long fileSize;
        private long downloadedSize;
        private String startTime;
        private String endTime;
        private String error;

        public DownloadStatusData(String downloadId, String status, int progress, String speed,
                                  String eta, String documentId, String documentTitle,
                                  long fileSize, long downloadedSize, String startTime,
                                  String endTime, String error) {
            this.downloadId = downloadId;
            this.status = status;
            this.progress = progress;
            this.speed = speed;
            this.eta = eta;
            this.documentId = documentId;
            this.documentTitle = documentTitle;
            this.fileSize = fileSize;
            this.downloadedSize = downloadedSize;
            this.startTime = startTime;
            this.endTime = endTime;
            this.error = error;
        }

        // Getters and Setters
        public String getDownloadId() { return downloadId; }
        public void setDownloadId(String downloadId) { this.downloadId = downloadId; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }

        public int getProgress() { return progress; }
        public void setProgress(int progress) { this.progress = progress; }

        public String getSpeed() { return speed; }
        public void setSpeed(String speed) { this.speed = speed; }

        public String getEta() { return eta; }
        public void setEta(String eta) { this.eta = eta; }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public String getDocumentTitle() { return documentTitle; }
        public void setDocumentTitle(String documentTitle) { this.documentTitle = documentTitle; }

        public long getFileSize() { return fileSize; }
        public void setFileSize(long fileSize) { this.fileSize = fileSize; }

        public long getDownloadedSize() { return downloadedSize; }
        public void setDownloadedSize(long downloadedSize) { this.downloadedSize = downloadedSize; }

        public String getStartTime() { return startTime; }
        public void setStartTime(String startTime) { this.startTime = startTime; }

        public String getEndTime() { return endTime; }
        public void setEndTime(String endTime) { this.endTime = endTime; }

        public String getError() { return error; }
        public void setError(String error) { this.error = error; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/downloads/{downloadId}/status")
    public ResponseEntity<DownloadStatusResponse> getOfflineDownloadStatus(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String downloadId) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("downloadId", downloadId);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DownloadStatusResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new DownloadStatusResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 查询下载状态
            String querySql = "SELECT d.*, doc.title as document_title " +
                    "FROM offline_downloads d " +
                    "LEFT JOIN documents doc ON d.document_id = doc.document_id " +
                    "WHERE d.download_id = ? AND d.user_id = ?";

            List<Map<String, Object>> downloads = jdbcTemplate.queryForList(querySql, downloadId, userId);
            printQueryResult(downloads);

            if (downloads.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new DownloadStatusResponse(false, "下载任务不存在", null)
                );
            }

            Map<String, Object> row = downloads.get(0);

            // 3. 准备响应数据
            DownloadStatusData data = new DownloadStatusData(
                    (String) row.get("download_id"),
                    (String) row.get("status"),
                    row.get("progress") != null ? ((Number) row.get("progress")).intValue() : 0,
                    (String) row.get("speed"),
                    (String) row.get("eta"),
                    (String) row.get("document_id"),
                    (String) row.get("document_title"),
                    row.get("file_size") != null ? ((Number) row.get("file_size")).longValue() : 0,
                    row.get("downloaded_size") != null ? ((Number) row.get("downloaded_size")).longValue() : 0,
                    row.get("start_time") != null ? row.get("start_time").toString() : null,
                    row.get("end_time") != null ? row.get("end_time").toString() : null,
                    (String) row.get("error")
            );

            DownloadStatusResponse response = new DownloadStatusResponse(true, "获取下载状态成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取离线下载状态过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new DownloadStatusResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineGetDownloadStatus.java ---

--- 开始文件: OfflineGetSettings.java ---
package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetSettings {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取离线设置请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class OfflineSettingsResponse {
        private boolean success;
        private String message;
        private OfflineSettingsData data;

        public OfflineSettingsResponse(boolean success, String message, OfflineSettingsData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public OfflineSettingsData getData() { return data; }
        public void setData(OfflineSettingsData data) { this.data = data; }
    }

    public static class OfflineSettingsData {
        private boolean offlineMode;
        private boolean autoSync;
        private int syncInterval;
        private int storageLimit;
        private boolean wifiOnly;
        private String lastSyncTime;
        private String updatedAt;

        public OfflineSettingsData(boolean offlineMode, boolean autoSync, int syncInterval,
                                   int storageLimit, boolean wifiOnly, String lastSyncTime,
                                   String updatedAt) {
            this.offlineMode = offlineMode;
            this.autoSync = autoSync;
            this.syncInterval = syncInterval;
            this.storageLimit = storageLimit;
            this.wifiOnly = wifiOnly;
            this.lastSyncTime = lastSyncTime;
            this.updatedAt = updatedAt;
        }

        // Getters and Setters
        public boolean isOfflineMode() { return offlineMode; }
        public void setOfflineMode(boolean offlineMode) { this.offlineMode = offlineMode; }

        public boolean isAutoSync() { return autoSync; }
        public void setAutoSync(boolean autoSync) { this.autoSync = autoSync; }

        public int getSyncInterval() { return syncInterval; }
        public void setSyncInterval(int syncInterval) { this.syncInterval = syncInterval; }

        public int getStorageLimit() { return storageLimit; }
        public void setStorageLimit(int storageLimit) { this.storageLimit = storageLimit; }

        public boolean isWifiOnly() { return wifiOnly; }
        public void setWifiOnly(boolean wifiOnly) { this.wifiOnly = wifiOnly; }

        public String getLastSyncTime() { return lastSyncTime; }
        public void setLastSyncTime(String lastSyncTime) { this.lastSyncTime = lastSyncTime; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/settings")
    public ResponseEntity<OfflineSettingsResponse> getOfflineSettings(
            @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineSettingsResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new OfflineSettingsResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 查询所有设置
            String querySql = "SELECT setting_key, setting_value, updated_at FROM offline_settings WHERE user_id = ?";
            List<Map<String, Object>> settings = jdbcTemplate.queryForList(querySql, userId);
            printQueryResult(settings);

            // 3. 解析设置值
            boolean offlineMode = false;
            boolean autoSync = true;
            int syncInterval = 5;
            int storageLimit = 1024;
            boolean wifiOnly = true;
            String lastSyncTime = null;
            String updatedAt = null;

            for (Map<String, Object> row : settings) {
                String key = (String) row.get("setting_key");
                String value = (String) row.get("setting_value");

                switch (key) {
                    case "offlineMode":
                        offlineMode = Boolean.parseBoolean(value);
                        break;
                    case "autoSync":
                        autoSync = Boolean.parseBoolean(value);
                        break;
                    case "syncInterval":
                        syncInterval = Integer.parseInt(value);
                        break;
                    case "storageLimit":
                        storageLimit = Integer.parseInt(value);
                        break;
                    case "wifiOnly":
                        wifiOnly = Boolean.parseBoolean(value);
                        break;
                    case "lastSyncTime":
                        lastSyncTime = value;
                        break;
                }

                if (updatedAt == null) {
                    updatedAt = row.get("updated_at").toString();
                }
            }

            // 4. 如果没有设置，使用默认值
            if (settings.isEmpty()) {
                // 可以在这里插入默认设置
                String insertSql = "INSERT INTO offline_settings (user_id, setting_key, setting_value) VALUES " +
                        "(?, 'offlineMode', 'false'), " +
                        "(?, 'autoSync', 'true'), " +
                        "(?, 'syncInterval', '5'), " +
                        "(?, 'storageLimit', '1024'), " +
                        "(?, 'wifiOnly', 'true')";
                jdbcTemplate.update(insertSql, userId, userId, userId, userId, userId);

                updatedAt = "刚刚创建";
            }

            // 5. 准备响应数据
            OfflineSettingsData data = new OfflineSettingsData(
                    offlineMode,
                    autoSync,
                    syncInterval,
                    storageLimit,
                    wifiOnly,
                    lastSyncTime,
                    updatedAt
            );

            OfflineSettingsResponse response = new OfflineSettingsResponse(true, "获取离线设置成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取离线设置过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new OfflineSettingsResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}

--- 结束文件: OfflineGetSettings.java ---

--- 开始文件: OfflineGetStorageStats.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetStorageStats {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取离线存储统计请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class StorageStatsResponse {
        private boolean success;
        private String message;
        private StorageStatsData data;

        public StorageStatsResponse(boolean success, String message, StorageStatsData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public StorageStatsData getData() { return data; }
        public void setData(StorageStatsData data) { this.data = data; }
    }

    public static class StorageStatsData {
        private long totalSize;
        private int documentCount;
        private int vocabularyCount;
        private int reviewCount;
        private int noteCount;
        private int highlightCount;
        private StorageByType byType;
        private StorageByStatus byStatus;

        public StorageStatsData(long totalSize, int documentCount, int vocabularyCount,
                                int reviewCount, int noteCount, int highlightCount,
                                StorageByType byType, StorageByStatus byStatus) {
            this.totalSize = totalSize;
            this.documentCount = documentCount;
            this.vocabularyCount = vocabularyCount;
            this.reviewCount = reviewCount;
            this.noteCount = noteCount;
            this.highlightCount = highlightCount;
            this.byType = byType;
            this.byStatus = byStatus;
        }

        // Getters and Setters
        public long getTotalSize() { return totalSize; }
        public void setTotalSize(long totalSize) { this.totalSize = totalSize; }

        public int getDocumentCount() { return documentCount; }
        public void setDocumentCount(int documentCount) { this.documentCount = documentCount; }

        public int getVocabularyCount() { return vocabularyCount; }
        public void setVocabularyCount(int vocabularyCount) { this.vocabularyCount = vocabularyCount; }

        public int getReviewCount() { return reviewCount; }
        public void setReviewCount(int reviewCount) { this.reviewCount = reviewCount; }

        public int getNoteCount() { return noteCount; }
        public void setNoteCount(int noteCount) { this.noteCount = noteCount; }

        public int getHighlightCount() { return highlightCount; }
        public void setHighlightCount(int highlightCount) { this.highlightCount = highlightCount; }

        public StorageByType getByType() { return byType; }
        public void setByType(StorageByType byType) { this.byType = byType; }

        public StorageByStatus getByStatus() { return byStatus; }
        public void setByStatus(StorageByStatus byStatus) { this.byStatus = byStatus; }
    }

    public static class StorageByType {
        private long documents;
        private long vocabulary;
        private long reviews;
        private long notes;
        private long highlights;

        public StorageByType(long documents, long vocabulary, long reviews,
                             long notes, long highlights) {
            this.documents = documents;
            this.vocabulary = vocabulary;
            this.reviews = reviews;
            this.notes = notes;
            this.highlights = highlights;
        }

        // Getters and Setters
        public long getDocuments() { return documents; }
        public void setDocuments(long documents) { this.documents = documents; }

        public long getVocabulary() { return vocabulary; }
        public void setVocabulary(long vocabulary) { this.vocabulary = vocabulary; }

        public long getReviews() { return reviews; }
        public void setReviews(long reviews) { this.reviews = reviews; }

        public long getNotes() { return notes; }
        public void setNotes(long notes) { this.notes = notes; }

        public long getHighlights() { return highlights; }
        public void setHighlights(long highlights) { this.highlights = highlights; }
    }

    public static class StorageByStatus {
        private int synced;
        private int pending;
        private int failed;

        public StorageByStatus(int synced, int pending, int failed) {
            this.synced = synced;
            this.pending = pending;
            this.failed = failed;
        }

        // Getters and Setters
        public int getSynced() { return synced; }
        public void setSynced(int synced) { this.synced = synced; }

        public int getPending() { return pending; }
        public void setPending(int pending) { this.pending = pending; }

        public int getFailed() { return failed; }
        public void setFailed(int failed) { this.failed = failed; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/stats")
    public ResponseEntity<StorageStatsResponse> getOfflineStorageStats(
            @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new StorageStatsResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new StorageStatsResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 统计文档数据
            String docStatsSql = "SELECT COUNT(*) as count, SUM(file_size) as total_size, " +
                    "SUM(CASE WHEN is_synced THEN 1 ELSE 0 END) as synced_count " +
                    "FROM offline_documents WHERE user_id = ?";
            List<Map<String, Object>> docStats = jdbcTemplate.queryForList(docStatsSql, userId);

            int documentCount = 0;
            long docTotalSize = 0;
            int docSyncedCount = 0;

            if (!docStats.isEmpty()) {
                Map<String, Object> row = docStats.get(0);
                documentCount = row.get("count") != null ? ((Number) row.get("count")).intValue() : 0;
                docTotalSize = row.get("total_size") != null ? ((Number) row.get("total_size")).longValue() : 0;
                docSyncedCount = row.get("synced_count") != null ? ((Number) row.get("synced_count")).intValue() : 0;
            }

            // 3. 统计词汇数据（假设有offline_vocabulary表）
            String vocabStatsSql = "SELECT COUNT(*) as count FROM offline_vocabulary WHERE user_id = ?";
            List<Map<String, Object>> vocabStats = jdbcTemplate.queryForList(vocabStatsSql, userId);
            int vocabularyCount = vocabStats.isEmpty() ? 0 : ((Number) vocabStats.get(0).get("count")).intValue();

            // 4. 统计复习记录（假设有offline_reviews表）
            String reviewStatsSql = "SELECT COUNT(*) as count FROM offline_reviews WHERE user_id = ?";
            List<Map<String, Object>> reviewStats = jdbcTemplate.queryForList(reviewStatsSql, userId);
            int reviewCount = reviewStats.isEmpty() ? 0 : ((Number) reviewStats.get(0).get("count")).intValue();

            // 5. 统计笔记数据（假设有offline_notes表）
            String noteStatsSql = "SELECT COUNT(*) as count FROM offline_notes WHERE user_id = ?";
            List<Map<String, Object>> noteStats = jdbcTemplate.queryForList(noteStatsSql, userId);
            int noteCount = noteStats.isEmpty() ? 0 : ((Number) noteStats.get(0).get("count")).intValue();

            // 6. 统计高亮数据（假设有offline_highlights表）
            String highlightStatsSql = "SELECT COUNT(*) as count FROM offline_highlights WHERE user_id = ?";
            List<Map<String, Object>> highlightStats = jdbcTemplate.queryForList(highlightStatsSql, userId);
            int highlightCount = highlightStats.isEmpty() ? 0 : ((Number) highlightStats.get(0).get("count")).intValue();

            // 7. 计算总大小（估算）
            long totalSize = docTotalSize +
                    (vocabularyCount * 1024L) + // 假设每个词汇1KB
                    (reviewCount * 512L) +      // 假设每个复习记录512B
                    (noteCount * 2048L) +       // 假设每个笔记2KB
                    (highlightCount * 256L);    // 假设每个高亮256B

            // 8. 按类型统计
            StorageByType byType = new StorageByType(
                    docTotalSize,
                    vocabularyCount * 1024L,
                    reviewCount * 512L,
                    noteCount * 2048L,
                    highlightCount * 256L
            );

            // 9. 按状态统计
            int docPendingCount = documentCount - docSyncedCount;
            StorageByStatus byStatus = new StorageByStatus(
                    docSyncedCount,
                    docPendingCount,
                    0 // 假设没有失败
            );

            // 10. 准备响应数据
            StorageStatsData data = new StorageStatsData(
                    totalSize,
                    documentCount,
                    vocabularyCount,
                    reviewCount,
                    noteCount,
                    highlightCount,
                    byType,
                    byStatus
            );

            printQueryResult(data);

            StorageStatsResponse response = new StorageStatsResponse(true, "获取离线存储统计成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取离线存储统计过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new StorageStatsResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineGetStorageStats.java ---

--- 开始文件: OfflineGetSyncHistory.java ---
package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetSyncHistory {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取同步历史请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class SyncHistoryResponse {
        private boolean success;
        private String message;
        private SyncHistoryData data;

        public SyncHistoryResponse(boolean success, String message, SyncHistoryData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncHistoryData getData() { return data; }
        public void setData(SyncHistoryData data) { this.data = data; }
    }

    public static class SyncHistoryData {
        private int total;
        private int page;
        private int pageSize;
        private int totalPages;
        private List<SyncHistoryItem> items;

        public SyncHistoryData(int total, int page, int pageSize, int totalPages, List<SyncHistoryItem> items) {
            this.total = total;
            this.page = page;
            this.pageSize = pageSize;
            this.totalPages = totalPages;
            this.items = items;
        }

        // Getters and Setters
        public int getTotal() { return total; }
        public void setTotal(int total) { this.total = total; }

        public int getPage() { return page; }
        public void setPage(int page) { this.page = page; }

        public int getPageSize() { return pageSize; }
        public void setPageSize(int pageSize) { this.pageSize = pageSize; }

        public int getTotalPages() { return totalPages; }
        public void setTotalPages(int totalPages) { this.totalPages = totalPages; }

        public List<SyncHistoryItem> getItems() { return items; }
        public void setItems(List<SyncHistoryItem> items) { this.items = items; }
    }

    public static class SyncHistoryItem {
        private String syncHistId;
        private String taskId;
        private String taskType;
        private String status;
        private int syncedItems;
        private int failedItems;
        private double duration;
        private String error;
        private String startTime;
        private String endTime;
        private String createdAt;

        public SyncHistoryItem(String syncHistId, String taskId, String taskType, String status,
                               int syncedItems, int failedItems, double duration, String error,
                               String startTime, String endTime, String createdAt) {
            this.syncHistId = syncHistId;
            this.taskId = taskId;
            this.taskType = taskType;
            this.status = status;
            this.syncedItems = syncedItems;
            this.failedItems = failedItems;
            this.duration = duration;
            this.error = error;
            this.startTime = startTime;
            this.endTime = endTime;
            this.createdAt = createdAt;
        }

        // Getters and Setters
        public String getSyncHistId() { return syncHistId; }
        public void setSyncHistId(String syncHistId) { this.syncHistId = syncHistId; }

        public String getTaskId() { return taskId; }
        public void setTaskId(String taskId) { this.taskId = taskId; }

        public String getTaskType() { return taskType; }
        public void setTaskType(String taskType) { this.taskType = taskType; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }

        public int getSyncedItems() { return syncedItems; }
        public void setSyncedItems(int syncedItems) { this.syncedItems = syncedItems; }

        public int getFailedItems() { return failedItems; }
        public void setFailedItems(int failedItems) { this.failedItems = failedItems; }

        public double getDuration() { return duration; }
        public void setDuration(double duration) { this.duration = duration; }

        public String getError() { return error; }
        public void setError(String error) { this.error = error; }

        public String getStartTime() { return startTime; }
        public void setStartTime(String startTime) { this.startTime = startTime; }

        public String getEndTime() { return endTime; }
        public void setEndTime(String endTime) { this.endTime = endTime; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/sync/history")
    public ResponseEntity<SyncHistoryResponse> getSyncHistory(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestParam(value = "page", defaultValue = "1") int page,
            @RequestParam(value = "pageSize", defaultValue = "20") int pageSize,
            @RequestParam(value = "startDate", required = false) String startDate,
            @RequestParam(value = "endDate", required = false) String endDate,
            @RequestParam(value = "type", defaultValue = "all") String type,
            @RequestParam(value = "status", required = false) String status) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("page", page);
        requestInfo.put("pageSize", pageSize);
        requestInfo.put("startDate", startDate);
        requestInfo.put("endDate", endDate);
        requestInfo.put("type", type);
        requestInfo.put("status", status);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncHistoryResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncHistoryResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 创建相关表（如果不存在）
            createOfflineSyncHistoryTableIfNotExists();

            // 3. 计算分页参数
            int offset = (page - 1) * pageSize;

            // 4. 构建查询条件
            StringBuilder whereClause = new StringBuilder("WHERE user_id = ?");
            List<Object> params = new ArrayList<>();
            params.add(userId);

            if (startDate != null && !startDate.trim().isEmpty()) {
                whereClause.append(" AND DATE(start_time) >= ?");
                params.add(startDate);
            }

            if (endDate != null && !endDate.trim().isEmpty()) {
                whereClause.append(" AND DATE(end_time) <= ?");
                params.add(endDate);
            }

            if (type != null && !type.equals("all")) {
                whereClause.append(" AND task_type = ?");
                params.add(type);
            }

            if (status != null && !status.trim().isEmpty()) {
                whereClause.append(" AND status = ?");
                params.add(status);
            }

            // 5. 查询总记录数
            String countSql = "SELECT COUNT(*) as total FROM offline_sync_history " + whereClause;
            List<Map<String, Object>> countResults = jdbcTemplate.queryForList(countSql, params.toArray());

            int total = 0;
            if (!countResults.isEmpty()) {
                total = ((Number) countResults.get(0).get("total")).intValue();
            }

            // 6. 查询历史记录
            String querySql = "SELECT * FROM offline_sync_history " + whereClause +
                    " ORDER BY created_at DESC LIMIT ? OFFSET ?";

            // 添加分页参数
            List<Object> queryParams = new ArrayList<>(params);
            queryParams.add(pageSize);
            queryParams.add(offset);

            List<Map<String, Object>> historyRecords = jdbcTemplate.queryForList(querySql, queryParams.toArray());
            printQueryResult(historyRecords);

            // 7. 转换为DTO对象
            List<SyncHistoryItem> items = new ArrayList<>();

            for (Map<String, Object> row : historyRecords) {
                SyncHistoryItem item = new SyncHistoryItem(
                        (String) row.get("sync_hist_id"),
                        (String) row.get("task_id"),
                        (String) row.get("task_type"),
                        (String) row.get("status"),
                        row.get("synced_items") != null ? ((Number) row.get("synced_items")).intValue() : 0,
                        row.get("failed_items") != null ? ((Number) row.get("failed_items")).intValue() : 0,
                        row.get("duration") != null ? ((Number) row.get("duration")).doubleValue() : 0.0,
                        (String) row.get("error"),
                        row.get("start_time") != null ? row.get("start_time").toString() : null,
                        row.get("end_time") != null ? row.get("end_time").toString() : null,
                        row.get("created_at") != null ? row.get("created_at").toString() : null
                );

                items.add(item);
            }

            // 8. 计算总页数
            int totalPages = (int) Math.ceil((double) total / pageSize);

            // 9. 准备响应数据
            SyncHistoryData data = new SyncHistoryData(total, page, pageSize, totalPages, items);
            SyncHistoryResponse response = new SyncHistoryResponse(true, "获取同步历史成功", data);

            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取同步历史过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncHistoryResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }

    // 创建 offline_sync_history 表（如果不存在）
    private void createOfflineSyncHistoryTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_sync_history (" +
                "sync_hist_id VARCHAR(50) PRIMARY KEY, " +
                "user_id INT NOT NULL, " +
                "task_id VARCHAR(50) NOT NULL, " +
                "task_type VARCHAR(50), " +
                "status VARCHAR(20) NOT NULL, " +
                "synced_items INT DEFAULT 0, " +
                "failed_items INT DEFAULT 0, " +
                "duration DOUBLE DEFAULT 0, " +
                "error TEXT, " +
                "start_time TIMESTAMP, " +
                "end_time TIMESTAMP, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_sync_history 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_sync_history 表失败: " + e.getMessage());
        }
    }
}
--- 结束文件: OfflineGetSyncHistory.java ---

--- 开始文件: OfflineGetSyncStatus.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineGetSyncStatus {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到获取同步状态请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 响应DTO
    public static class SyncStatusResponse {
        private boolean success;
        private String message;
        private SyncStatusData data;

        public SyncStatusResponse(boolean success, String message, SyncStatusData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncStatusData getData() { return data; }
        public void setData(SyncStatusData data) { this.data = data; }
    }

    public static class SyncStatusData {
        private boolean isSyncing;
        private String lastSyncTime;
        private int syncProgress;
        private String syncError;
        private int pendingOperations;
        private String syncSpeed;
        private int syncedItems;
        private int failedItems;

        public SyncStatusData(boolean isSyncing, String lastSyncTime, int syncProgress,
                              String syncError, int pendingOperations, String syncSpeed,
                              int syncedItems, int failedItems) {
            this.isSyncing = isSyncing;
            this.lastSyncTime = lastSyncTime;
            this.syncProgress = syncProgress;
            this.syncError = syncError;
            this.pendingOperations = pendingOperations;
            this.syncSpeed = syncSpeed;
            this.syncedItems = syncedItems;
            this.failedItems = failedItems;
        }

        // Getters and Setters
        public boolean isSyncing() { return isSyncing; }
        public void setSyncing(boolean syncing) { isSyncing = syncing; }

        public String getLastSyncTime() { return lastSyncTime; }
        public void setLastSyncTime(String lastSyncTime) { this.lastSyncTime = lastSyncTime; }

        public int getSyncProgress() { return syncProgress; }
        public void setSyncProgress(int syncProgress) { this.syncProgress = syncProgress; }

        public String getSyncError() { return syncError; }
        public void setSyncError(String syncError) { this.syncError = syncError; }

        public int getPendingOperations() { return pendingOperations; }
        public void setPendingOperations(int pendingOperations) { this.pendingOperations = pendingOperations; }

        public String getSyncSpeed() { return syncSpeed; }
        public void setSyncSpeed(String syncSpeed) { this.syncSpeed = syncSpeed; }

        public int getSyncedItems() { return syncedItems; }
        public void setSyncedItems(int syncedItems) { this.syncedItems = syncedItems; }

        public int getFailedItems() { return failedItems; }
        public void setFailedItems(int failedItems) { this.failedItems = failedItems; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @GetMapping("/sync/status")
    public ResponseEntity<SyncStatusResponse> getSyncStatus(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestParam(value = "type", defaultValue = "all") String type,
            @RequestParam(value = "status", defaultValue = "pending") String status) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("type", type);
        requestInfo.put("status", status);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncStatusResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncStatusResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 查询同步状态
            // 查询待同步操作数量
            String pendingSql = "SELECT COUNT(*) as count FROM offline_documents WHERE user_id = ? AND is_synced = FALSE";
            List<Map<String, Object>> pendingResults = jdbcTemplate.queryForList(pendingSql, userId);
            int pendingOperations = pendingResults.isEmpty() ? 0 : ((Number) pendingResults.get(0).get("count")).intValue();

            // 查询最近同步时间
            String lastSyncSql = "SELECT MAX(updated_at) as last_sync FROM offline_documents " +
                    "WHERE user_id = ? AND is_synced = TRUE";
            List<Map<String, Object>> lastSyncResults = jdbcTemplate.queryForList(lastSyncSql, userId);
            String lastSyncTime = null;
            if (!lastSyncResults.isEmpty() && lastSyncResults.get(0).get("last_sync") != null) {
                lastSyncTime = lastSyncResults.get(0).get("last_sync").toString();
            }

            // 查询同步统计
            String statsSql = "SELECT " +
                    "SUM(CASE WHEN is_synced = TRUE THEN 1 ELSE 0 END) as synced_items, " +
                    "SUM(CASE WHEN is_synced = FALSE THEN 1 ELSE 0 END) as failed_items " +
                    "FROM offline_documents WHERE user_id = ?";
            List<Map<String, Object>> statsResults = jdbcTemplate.queryForList(statsSql, userId);

            int syncedItems = 0;
            int failedItems = 0;
            if (!statsResults.isEmpty()) {
                Map<String, Object> row = statsResults.get(0);
                syncedItems = row.get("synced_items") != null ? ((Number) row.get("synced_items")).intValue() : 0;
                failedItems = row.get("failed_items") != null ? ((Number) row.get("failed_items")).intValue() : 0;
            }

            // 计算同步进度
            int totalItems = syncedItems + failedItems + pendingOperations;
            int syncProgress = totalItems > 0 ? (int) ((double) syncedItems / totalItems * 100) : 0;

            // 3. 准备响应数据
            SyncStatusData data = new SyncStatusData(
                    false, // 假设当前没有正在进行的同步
                    lastSyncTime,
                    syncProgress,
                    null, // 假设没有错误
                    pendingOperations,
                    "0 KB/s", // 假设没有正在进行的同步
                    syncedItems,
                    failedItems
            );

            printQueryResult(data);

            SyncStatusResponse response = new SyncStatusResponse(true, "获取同步状态成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("获取同步状态过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncStatusResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineGetSyncStatus.java ---

--- 开始文件: OfflineSetStorageLimit.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSetStorageLimit {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到设置离线存储限制请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SetStorageLimitRequest {
        private int limit_mb;

        public int getLimit_mb() { return limit_mb; }
        public void setLimit_mb(int limit_mb) { this.limit_mb = limit_mb; }
    }

    // 响应DTO
    public static class SetStorageLimitResponse {
        private boolean success;
        private String message;
        private SetStorageLimitData data;

        public SetStorageLimitResponse(boolean success, String message, SetStorageLimitData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SetStorageLimitData getData() { return data; }
        public void setData(SetStorageLimitData data) { this.data = data; }
    }

    public static class SetStorageLimitData {
        private int limit_mb;
        private String updatedAt;

        public SetStorageLimitData(int limit_mb, String updatedAt) {
            this.limit_mb = limit_mb;
            this.updatedAt = updatedAt;
        }

        // Getters and Setters
        public int getLimit_mb() { return limit_mb; }
        public void setLimit_mb(int limit_mb) { this.limit_mb = limit_mb; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
    }

    // 创建 offline_settings 表（如果不存在）
    private void createOfflineSettingsTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_settings (" +
                "user_id INT NOT NULL, " +
                "setting_key VARCHAR(50) NOT NULL, " +
                "setting_value TEXT, " +
                "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, " +
                "PRIMARY KEY (user_id, setting_key), " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_settings 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_settings 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PutMapping("/storage-limit")
    public ResponseEntity<SetStorageLimitResponse> setOfflineStorageLimit(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SetStorageLimitRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SetStorageLimitResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SetStorageLimitResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null) {
                return ResponseEntity.badRequest().body(
                        new SetStorageLimitResponse(false, "请求数据不能为空", null)
                );
            }

            int limitMb = request.getLimit_mb();
            if (limitMb < 1 || limitMb > 10240) {
                return ResponseEntity.badRequest().body(
                        new SetStorageLimitResponse(false, "存储限制必须在1-10240MB之间", null)
                );
            }

            // 3. 创建设置表
            createOfflineSettingsTableIfNotExists();

            // 4. 检查是否已有设置
            String checkSql = "SELECT setting_value FROM offline_settings WHERE user_id = ? AND setting_key = 'storage_limit'";
            List<Map<String, Object>> existingSettings = jdbcTemplate.queryForList(checkSql, userId);

            int rowsAffected;
            if (existingSettings.isEmpty()) {
                // 插入新设置
                String insertSql = "INSERT INTO offline_settings (user_id, setting_key, setting_value) VALUES (?, 'storage_limit', ?)";
                rowsAffected = jdbcTemplate.update(insertSql, userId, String.valueOf(limitMb));
            } else {
                // 更新现有设置
                String updateSql = "UPDATE offline_settings SET setting_value = ?, updated_at = NOW() " +
                        "WHERE user_id = ? AND setting_key = 'storage_limit'";
                rowsAffected = jdbcTemplate.update(updateSql, String.valueOf(limitMb), userId);
            }

            printQueryResult("设置行数: " + rowsAffected);

            if (rowsAffected > 0) {
                // 5. 查询更新后的设置
                String querySql = "SELECT setting_value, updated_at FROM offline_settings " +
                        "WHERE user_id = ? AND setting_key = 'storage_limit'";
                List<Map<String, Object>> settings = jdbcTemplate.queryForList(querySql, userId);

                if (!settings.isEmpty()) {
                    Map<String, Object> row = settings.get(0);

                    // 6. 准备响应数据
                    SetStorageLimitData data = new SetStorageLimitData(
                            limitMb,
                            row.get("updated_at").toString()
                    );

                    SetStorageLimitResponse response = new SetStorageLimitResponse(true,
                            String.format("离线存储限制已设置为 %d MB", limitMb), data);

                    printResponse(response);

                    return ResponseEntity.ok(response);
                }
            }

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SetStorageLimitResponse(false, "设置失败", null)
            );

        } catch (Exception e) {
            System.err.println("设置离线存储限制过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SetStorageLimitResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineSetStorageLimit.java ---

--- 开始文件: OfflineStartSyncTask.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import java.time.LocalDateTime;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineStartSyncTask {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到开始同步任务请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class StartSyncTaskRequest {
        private String taskType;

        public String getTaskType() { return taskType; }
        public void setTaskType(String taskType) { this.taskType = taskType; }
    }

    // 响应DTO
    public static class StartSyncTaskResponse {
        private boolean success;
        private String message;
        private StartSyncTaskData data;

        public StartSyncTaskResponse(boolean success, String message, StartSyncTaskData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public StartSyncTaskData getData() { return data; }
        public void setData(StartSyncTaskData data) { this.data = data; }
    }

    public static class StartSyncTaskData {
        private String taskId;
        private String taskType;
        private String status;
        private String startTime;

        public StartSyncTaskData(String taskId, String taskType, String status, String startTime) {
            this.taskId = taskId;
            this.taskType = taskType;
            this.status = status;
            this.startTime = startTime;
        }

        // Getters and Setters
        public String getTaskId() { return taskId; }
        public void setTaskId(String taskId) { this.taskId = taskId; }

        public String getTaskType() { return taskType; }
        public void setTaskType(String taskType) { this.taskType = taskType; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }

        public String getStartTime() { return startTime; }
        public void setStartTime(String startTime) { this.startTime = startTime; }
    }

    // 创建 offline_sync_tasks 表（如果不存在）
    private void createOfflineSyncTasksTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_sync_tasks (" +
                "task_id VARCHAR(50) PRIMARY KEY, " +
                "user_id INT NOT NULL, " +
                "task_type VARCHAR(50) NOT NULL, " +
                "status VARCHAR(20) DEFAULT 'running', " +
                "progress INT DEFAULT 0, " +
                "total_operations INT DEFAULT 0, " +
                "completed_operations INT DEFAULT 0, " +
                "failed_operations INT DEFAULT 0, " +
                "estimated_end_time TIMESTAMP, " +
                "start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "end_time TIMESTAMP, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_sync_tasks 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_sync_tasks 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/task")
    public ResponseEntity<StartSyncTaskResponse> startSyncTask(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody StartSyncTaskRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new StartSyncTaskResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new StartSyncTaskResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getTaskType() == null || request.getTaskType().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new StartSyncTaskResponse(false, "任务类型不能为空", null)
                );
            }

            String taskType = request.getTaskType();

            // 3. 创建相关表
            createOfflineSyncTasksTableIfNotExists();

            // 4. 检查是否有正在进行的同步任务
            String checkRunningSql = "SELECT task_id FROM offline_sync_tasks WHERE user_id = ? AND status = 'running'";
            List<Map<String, Object>> runningTasks = jdbcTemplate.queryForList(checkRunningSql, userId);

            if (!runningTasks.isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new StartSyncTaskResponse(false, "已有正在进行的同步任务", null)
                );
            }

            // 5. 创建同步任务
            String taskId = "sync_task_" + UUID.randomUUID().toString();
            LocalDateTime startTime = LocalDateTime.now();
            LocalDateTime estimatedEndTime = startTime.plusMinutes(5); // 假设5分钟完成

            String insertSql = "INSERT INTO offline_sync_tasks (task_id, user_id, task_type, status, " +
                    "start_time, estimated_end_time, created_at) VALUES (?, ?, ?, 'running', ?, ?, NOW())";
            int rowsAffected = jdbcTemplate.update(insertSql, taskId, userId, taskType, startTime, estimatedEndTime);

            printQueryResult("创建任务行数: " + rowsAffected);

            if (rowsAffected > 0) {
                // 6. 启动异步同步任务（简化处理）
                new Thread(() -> {
                    try {
                        // 模拟同步过程
                        Thread.sleep(2000);

                        // 更新任务进度
                        String updateProgressSql = "UPDATE offline_sync_tasks SET progress = 50, " +
                                "completed_operations = 5, total_operations = 10 " +
                                "WHERE task_id = ? AND user_id = ?";
                        jdbcTemplate.update(updateProgressSql, taskId, userId);

                        Thread.sleep(2000);

                        // 完成任务
                        String completeSql = "UPDATE offline_sync_tasks SET status = 'completed', progress = 100, " +
                                "completed_operations = 10, failed_operations = 0, " +
                                "end_time = NOW() WHERE task_id = ? AND user_id = ?";
                        jdbcTemplate.update(completeSql, taskId, userId);

                        // 将同步记录添加到历史表
                        addSyncHistory(userId, taskId, taskType, "completed", 10, 0, 4.0);

                    } catch (InterruptedException e) {
                        // 任务失败
                        String failSql = "UPDATE offline_sync_tasks SET status = 'failed', end_time = NOW(), " +
                                "error = '同步任务被中断' WHERE task_id = ? AND user_id = ?";
                        jdbcTemplate.update(failSql, taskId, userId);

                        addSyncHistory(userId, taskId, taskType, "failed", 0, 10, 4.0);
                    }
                }).start();

                // 7. 准备响应数据
                StartSyncTaskData data = new StartSyncTaskData(
                        taskId,
                        taskType,
                        "running",
                        startTime.toString()
                );

                StartSyncTaskResponse response = new StartSyncTaskResponse(true, "同步任务已开始", data);
                printResponse(response);

                return ResponseEntity.ok(response);
            }

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new StartSyncTaskResponse(false, "创建同步任务失败", null)
            );

        } catch (Exception e) {
            System.err.println("开始同步任务过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new StartSyncTaskResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }

    // 添加同步历史记录
    private void addSyncHistory(Integer userId, String taskId, String taskType,
                                String status, int syncedItems, int failedItems, double duration) {
        try {
            // 创建 offline_sync_history 表（如果不存在）
            String createTableSql = "CREATE TABLE IF NOT EXISTS offline_sync_history (" +
                    "sync_hist_id VARCHAR(50) PRIMARY KEY, " +
                    "user_id INT NOT NULL, " +
                    "task_id VARCHAR(50) NOT NULL, " +
                    "task_type VARCHAR(50) NOT NULL, " +
                    "status VARCHAR(20) NOT NULL, " +
                    "synced_items INT DEFAULT 0, " +
                    "failed_items INT DEFAULT 0, " +
                    "duration DOUBLE DEFAULT 0, " +
                    "start_time TIMESTAMP, " +
                    "end_time TIMESTAMP, " +
                    "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                    "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                    ")";
            jdbcTemplate.execute(createTableSql);

            // 插入历史记录
            String syncHistId = "sync_hist_" + UUID.randomUUID().toString();
            String insertSql = "INSERT INTO offline_sync_history (sync_hist_id, user_id, task_id, task_type, " +
                    "status, synced_items, failed_items, duration, start_time, end_time, created_at) " +
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW() - INTERVAL ? SECOND, NOW(), NOW())";
            jdbcTemplate.update(insertSql, syncHistId, userId, taskId, taskType, status,
                    syncedItems, failedItems, duration, (int)duration);

        } catch (Exception e) {
            System.err.println("添加同步历史记录失败: " + e.getMessage());
        }
    }
}
--- 结束文件: OfflineStartSyncTask.java ---

--- 开始文件: OfflineSyncDocument.java ---
package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSyncDocument {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到同步文档数据请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SyncDocumentRequest {
        private DocumentData document;

        public DocumentData getDocument() { return document; }
        public void setDocument(DocumentData document) { this.document = document; }
    }

    public static class DocumentData {
        private String id;
        private String title;
        private String content;
        private String updatedAt;
        private int offlineVersion;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 响应DTO
    public static class SyncDocumentResponse {
        private boolean success;
        private String message;
        private SyncDocumentData data;

        public SyncDocumentResponse(boolean success, String message, SyncDocumentData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncDocumentData getData() { return data; }
        public void setData(SyncDocumentData data) { this.data = data; }
    }

    public static class SyncDocumentData {
        private String documentId;
        private boolean synced;
        private String syncedAt;
        private int offlineVersion;

        public SyncDocumentData(String documentId, boolean synced, String syncedAt, int offlineVersion) {
            this.documentId = documentId;
            this.synced = synced;
            this.syncedAt = syncedAt;
            this.offlineVersion = offlineVersion;
        }

        // Getters and Setters
        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public boolean isSynced() { return synced; }
        public void setSynced(boolean synced) { this.synced = synced; }

        public String getSyncedAt() { return syncedAt; }
        public void setSyncedAt(String syncedAt) { this.syncedAt = syncedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/document")
    public ResponseEntity<SyncDocumentResponse> syncDocument(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SyncDocumentRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncDocumentResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncDocumentResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getDocument() == null) {
                return ResponseEntity.badRequest().body(
                        new SyncDocumentResponse(false, "文档数据不能为空", null)
                );
            }

            DocumentData documentData = request.getDocument();
            if (documentData.getId() == null || documentData.getId().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new SyncDocumentResponse(false, "文档ID不能为空", null)
                );
            }

            // 3. 检查文档是否存在
            String checkDocSql = "SELECT document_id FROM documents WHERE document_id = ?";
            List<Map<String, Object>> documents = jdbcTemplate.queryForList(checkDocSql, documentData.getId());

            if (documents.isEmpty()) {
                // 文档不存在，创建新文档
                String insertDocSql = "INSERT INTO documents (document_id, user_id, title, content, status, created_at) " +
                        "VALUES (?, ?, ?, ?, 'active', NOW())";
                jdbcTemplate.update(insertDocSql, documentData.getId(), userId,
                        documentData.getTitle(), documentData.getContent());
            } else {
                // 文档存在，更新文档
                String updateDocSql = "UPDATE documents SET title = ?, content = ?, updated_at = NOW() " +
                        "WHERE document_id = ? AND user_id = ?";
                jdbcTemplate.update(updateDocSql, documentData.getTitle(),
                        documentData.getContent(), documentData.getId(), userId);
            }

            // 4. 检查是否已有离线文档记录
            String checkOfflineSql = "SELECT offline_doc_id, offline_version FROM offline_documents " +
                    "WHERE document_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(checkOfflineSql,
                    documentData.getId(), userId);

            if (offlineDocs.isEmpty()) {
                // 创建离线文档记录
                String offlineDocId = "offline_doc_" + UUID.randomUUID().toString();
                String insertOfflineSql = "INSERT INTO offline_documents (offline_doc_id, document_id, user_id, " +
                        "title, content, is_synced, offline_version, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, TRUE, ?, NOW())";
                jdbcTemplate.update(insertOfflineSql, offlineDocId, documentData.getId(), userId,
                        documentData.getTitle(), documentData.getContent(),
                        documentData.getOfflineVersion());
            } else {
                // 更新离线文档记录
                Map<String, Object> offlineDoc = offlineDocs.get(0);
                int currentVersion = offlineDoc.get("offline_version") != null ?
                        ((Number) offlineDoc.get("offline_version")).intValue() : 0;

                if (documentData.getOfflineVersion() > currentVersion) {
                    // 离线版本较新，更新服务器数据
                    String updateOfflineSql = "UPDATE offline_documents SET title = ?, content = ?, " +
                            "is_synced = TRUE, offline_version = ?, updated_at = NOW() " +
                            "WHERE document_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateOfflineSql, documentData.getTitle(),
                            documentData.getContent(), documentData.getOfflineVersion(),
                            documentData.getId(), userId);
                } else {
                    // 服务器版本较新或相同，标记为已同步
                    String updateSyncSql = "UPDATE offline_documents SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE document_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateSyncSql, documentData.getId(), userId);
                }
            }

            // 5. 准备响应数据
            SyncDocumentData data = new SyncDocumentData(
                    documentData.getId(),
                    true,
                    "刚刚同步",
                    documentData.getOfflineVersion()
            );

            SyncDocumentResponse response = new SyncDocumentResponse(true, "文档同步成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("同步文档数据过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncDocumentResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}

--- 结束文件: OfflineSyncDocument.java ---

--- 开始文件: OfflineSyncHighlight.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSyncHighlight {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到同步高亮数据请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SyncHighlightRequest {
        private HighlightData highlight;

        public HighlightData getHighlight() { return highlight; }
        public void setHighlight(HighlightData highlight) { this.highlight = highlight; }
    }

    public static class HighlightData {
        private String id;
        private String documentId;
        private String text;
        private String color;
        private String createdAt;
        private int offlineVersion;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public String getText() { return text; }
        public void setText(String text) { this.text = text; }

        public String getColor() { return color; }
        public void setColor(String color) { this.color = color; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 响应DTO
    public static class SyncHighlightResponse {
        private boolean success;
        private String message;
        private SyncHighlightData data;

        public SyncHighlightResponse(boolean success, String message, SyncHighlightData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncHighlightData getData() { return data; }
        public void setData(SyncHighlightData data) { this.data = data; }
    }

    public static class SyncHighlightData {
        private String highlightId;
        private boolean synced;
        private String syncedAt;
        private int offlineVersion;

        public SyncHighlightData(String highlightId, boolean synced, String syncedAt, int offlineVersion) {
            this.highlightId = highlightId;
            this.synced = synced;
            this.syncedAt = syncedAt;
            this.offlineVersion = offlineVersion;
        }

        // Getters and Setters
        public String getHighlightId() { return highlightId; }
        public void setHighlightId(String highlightId) { this.highlightId = highlightId; }

        public boolean isSynced() { return synced; }
        public void setSynced(boolean synced) { this.synced = synced; }

        public String getSyncedAt() { return syncedAt; }
        public void setSyncedAt(String syncedAt) { this.syncedAt = syncedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 创建 offline_highlights 表（如果不存在）
    private void createOfflineHighlightsTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_highlights (" +
                "offline_highlight_id VARCHAR(50) PRIMARY KEY, " +
                "highlight_id VARCHAR(50) NOT NULL, " +
                "user_id INT NOT NULL, " +
                "document_id VARCHAR(50) NOT NULL, " +
                "text TEXT, " +
                "color VARCHAR(20), " +
                "is_synced BOOLEAN DEFAULT FALSE, " +
                "offline_version INT DEFAULT 1, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE, " +
                "FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_highlights 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_highlights 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/highlight")
    public ResponseEntity<SyncHighlightResponse> syncHighlight(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SyncHighlightRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncHighlightResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncHighlightResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getHighlight() == null) {
                return ResponseEntity.badRequest().body(
                        new SyncHighlightResponse(false, "高亮数据不能为空", null)
                );
            }

            HighlightData highlightData = request.getHighlight();
            if (highlightData.getId() == null || highlightData.getId().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new SyncHighlightResponse(false, "高亮ID不能为空", null)
                );
            }

            // 3. 创建相关表
            createOfflineHighlightsTableIfNotExists();

            // 4. 检查高亮是否存在（假设有highlights表）
            String checkHighlightSql = "SELECT highlight_id FROM highlights WHERE highlight_id = ?";
            List<Map<String, Object>> highlights = jdbcTemplate.queryForList(checkHighlightSql, highlightData.getId());

            if (highlights.isEmpty()) {
                // 高亮不存在，创建新高亮
                String insertHighlightSql = "INSERT INTO highlights (highlight_id, user_id, document_id, text, color, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, NOW())";
                jdbcTemplate.update(insertHighlightSql, highlightData.getId(), userId,
                        highlightData.getDocumentId(), highlightData.getText(),
                        highlightData.getColor());
            } else {
                // 高亮存在，更新高亮
                String updateHighlightSql = "UPDATE highlights SET document_id = ?, text = ?, color = ?, updated_at = NOW() " +
                        "WHERE highlight_id = ? AND user_id = ?";
                jdbcTemplate.update(updateHighlightSql, highlightData.getDocumentId(),
                        highlightData.getText(), highlightData.getColor(),
                        highlightData.getId(), userId);
            }

            // 5. 检查是否已有离线高亮记录
            String checkOfflineSql = "SELECT offline_highlight_id, offline_version FROM offline_highlights " +
                    "WHERE highlight_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineHighlights = jdbcTemplate.queryForList(checkOfflineSql,
                    highlightData.getId(), userId);

            if (offlineHighlights.isEmpty()) {
                // 创建离线高亮记录
                String offlineHighlightId = "offline_highlight_" + UUID.randomUUID().toString();
                String insertOfflineSql = "INSERT INTO offline_highlights (offline_highlight_id, highlight_id, user_id, " +
                        "document_id, text, color, is_synced, offline_version, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, ?, TRUE, ?, NOW())";
                jdbcTemplate.update(insertOfflineSql, offlineHighlightId, highlightData.getId(), userId,
                        highlightData.getDocumentId(), highlightData.getText(),
                        highlightData.getColor(), highlightData.getOfflineVersion());
            } else {
                // 更新离线高亮记录
                Map<String, Object> offlineHighlight = offlineHighlights.get(0);
                int currentVersion = offlineHighlight.get("offline_version") != null ?
                        ((Number) offlineHighlight.get("offline_version")).intValue() : 0;

                if (highlightData.getOfflineVersion() > currentVersion) {
                    // 离线版本较新，更新服务器数据
                    String updateOfflineSql = "UPDATE offline_highlights SET document_id = ?, text = ?, color = ?, " +
                            "is_synced = TRUE, offline_version = ?, updated_at = NOW() " +
                            "WHERE highlight_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateOfflineSql, highlightData.getDocumentId(),
                            highlightData.getText(), highlightData.getColor(),
                            highlightData.getOfflineVersion(), highlightData.getId(), userId);
                } else {
                    // 服务器版本较新或相同，标记为已同步
                    String updateSyncSql = "UPDATE offline_highlights SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE highlight_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateSyncSql, highlightData.getId(), userId);
                }
            }

            // 6. 准备响应数据
            SyncHighlightData data = new SyncHighlightData(
                    highlightData.getId(),
                    true,
                    "刚刚同步",
                    highlightData.getOfflineVersion()
            );

            SyncHighlightResponse response = new SyncHighlightResponse(true, "高亮同步成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("同步高亮数据过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncHighlightResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineSyncHighlight.java ---

--- 开始文件: OfflineSyncNote.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSyncNote {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到同步笔记数据请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SyncNoteRequest {
        private NoteData note;

        public NoteData getNote() { return note; }
        public void setNote(NoteData note) { this.note = note; }
    }

    public static class NoteData {
        private String id;
        private String documentId;
        private String content;
        private String createdAt;
        private int offlineVersion;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getDocumentId() { return documentId; }
        public void setDocumentId(String documentId) { this.documentId = documentId; }

        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }

        public String getCreatedAt() { return createdAt; }
        public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 响应DTO
    public static class SyncNoteResponse {
        private boolean success;
        private String message;
        private SyncNoteData data;

        public SyncNoteResponse(boolean success, String message, SyncNoteData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncNoteData getData() { return data; }
        public void setData(SyncNoteData data) { this.data = data; }
    }

    public static class SyncNoteData {
        private String noteId;
        private boolean synced;
        private String syncedAt;
        private int offlineVersion;

        public SyncNoteData(String noteId, boolean synced, String syncedAt, int offlineVersion) {
            this.noteId = noteId;
            this.synced = synced;
            this.syncedAt = syncedAt;
            this.offlineVersion = offlineVersion;
        }

        // Getters and Setters
        public String getNoteId() { return noteId; }
        public void setNoteId(String noteId) { this.noteId = noteId; }

        public boolean isSynced() { return synced; }
        public void setSynced(boolean synced) { this.synced = synced; }

        public String getSyncedAt() { return syncedAt; }
        public void setSyncedAt(String syncedAt) { this.syncedAt = syncedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 创建 offline_notes 表（如果不存在）
    private void createOfflineNotesTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_notes (" +
                "offline_note_id VARCHAR(50) PRIMARY KEY, " +
                "note_id VARCHAR(50) NOT NULL, " +
                "user_id INT NOT NULL, " +
                "document_id VARCHAR(50) NOT NULL, " +
                "content TEXT, " +
                "is_synced BOOLEAN DEFAULT FALSE, " +
                "offline_version INT DEFAULT 1, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE, " +
                "FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_notes 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_notes 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/note")
    public ResponseEntity<SyncNoteResponse> syncNote(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SyncNoteRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncNoteResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncNoteResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getNote() == null) {
                return ResponseEntity.badRequest().body(
                        new SyncNoteResponse(false, "笔记数据不能为空", null)
                );
            }

            NoteData noteData = request.getNote();
            if (noteData.getId() == null || noteData.getId().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new SyncNoteResponse(false, "笔记ID不能为空", null)
                );
            }

            // 3. 创建相关表
            createOfflineNotesTableIfNotExists();

            // 4. 检查笔记是否存在（假设有notes表）
            String checkNoteSql = "SELECT note_id FROM notes WHERE note_id = ?";
            List<Map<String, Object>> notes = jdbcTemplate.queryForList(checkNoteSql, noteData.getId());

            if (notes.isEmpty()) {
                // 笔记不存在，创建新笔记
                String insertNoteSql = "INSERT INTO notes (note_id, user_id, document_id, content, created_at) " +
                        "VALUES (?, ?, ?, ?, NOW())";
                jdbcTemplate.update(insertNoteSql, noteData.getId(), userId,
                        noteData.getDocumentId(), noteData.getContent());
            } else {
                // 笔记存在，更新笔记
                String updateNoteSql = "UPDATE notes SET document_id = ?, content = ?, updated_at = NOW() " +
                        "WHERE note_id = ? AND user_id = ?";
                jdbcTemplate.update(updateNoteSql, noteData.getDocumentId(),
                        noteData.getContent(), noteData.getId(), userId);
            }

            // 5. 检查是否已有离线笔记记录
            String checkOfflineSql = "SELECT offline_note_id, offline_version FROM offline_notes " +
                    "WHERE note_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineNotes = jdbcTemplate.queryForList(checkOfflineSql,
                    noteData.getId(), userId);

            if (offlineNotes.isEmpty()) {
                // 创建离线笔记记录
                String offlineNoteId = "offline_note_" + UUID.randomUUID().toString();
                String insertOfflineSql = "INSERT INTO offline_notes (offline_note_id, note_id, user_id, " +
                        "document_id, content, is_synced, offline_version, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, TRUE, ?, NOW())";
                jdbcTemplate.update(insertOfflineSql, offlineNoteId, noteData.getId(), userId,
                        noteData.getDocumentId(), noteData.getContent(),
                        noteData.getOfflineVersion());
            } else {
                // 更新离线笔记记录
                Map<String, Object> offlineNote = offlineNotes.get(0);
                int currentVersion = offlineNote.get("offline_version") != null ?
                        ((Number) offlineNote.get("offline_version")).intValue() : 0;

                if (noteData.getOfflineVersion() > currentVersion) {
                    // 离线版本较新，更新服务器数据
                    String updateOfflineSql = "UPDATE offline_notes SET document_id = ?, content = ?, " +
                            "is_synced = TRUE, offline_version = ?, updated_at = NOW() " +
                            "WHERE note_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateOfflineSql, noteData.getDocumentId(),
                            noteData.getContent(), noteData.getOfflineVersion(),
                            noteData.getId(), userId);
                } else {
                    // 服务器版本较新或相同，标记为已同步
                    String updateSyncSql = "UPDATE offline_notes SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE note_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateSyncSql, noteData.getId(), userId);
                }
            }

            // 6. 准备响应数据
            SyncNoteData data = new SyncNoteData(
                    noteData.getId(),
                    true,
                    "刚刚同步",
                    noteData.getOfflineVersion()
            );

            SyncNoteResponse response = new SyncNoteResponse(true, "笔记同步成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("同步笔记数据过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncNoteResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineSyncNote.java ---

--- 开始文件: OfflineSyncReview.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSyncReview {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到同步复习记录请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SyncReviewRequest {
        private ReviewData review;

        public ReviewData getReview() { return review; }
        public void setReview(ReviewData review) { this.review = review; }
    }

    public static class ReviewData {
        private String id;
        private String vocabularyId;
        private int difficulty;
        private String reviewTime;
        private int offlineVersion;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getVocabularyId() { return vocabularyId; }
        public void setVocabularyId(String vocabularyId) { this.vocabularyId = vocabularyId; }

        public int getDifficulty() { return difficulty; }
        public void setDifficulty(int difficulty) { this.difficulty = difficulty; }

        public String getReviewTime() { return reviewTime; }
        public void setReviewTime(String reviewTime) { this.reviewTime = reviewTime; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 响应DTO
    public static class SyncReviewResponse {
        private boolean success;
        private String message;
        private SyncReviewData data;

        public SyncReviewResponse(boolean success, String message, SyncReviewData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncReviewData getData() { return data; }
        public void setData(SyncReviewData data) { this.data = data; }
    }

    public static class SyncReviewData {
        private String reviewId;
        private boolean synced;
        private String syncedAt;
        private int offlineVersion;

        public SyncReviewData(String reviewId, boolean synced, String syncedAt, int offlineVersion) {
            this.reviewId = reviewId;
            this.synced = synced;
            this.syncedAt = syncedAt;
            this.offlineVersion = offlineVersion;
        }

        // Getters and Setters
        public String getReviewId() { return reviewId; }
        public void setReviewId(String reviewId) { this.reviewId = reviewId; }

        public boolean isSynced() { return synced; }
        public void setSynced(boolean synced) { this.synced = synced; }

        public String getSyncedAt() { return syncedAt; }
        public void setSyncedAt(String syncedAt) { this.syncedAt = syncedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 创建 offline_reviews 表（如果不存在）
    private void createOfflineReviewsTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_reviews (" +
                "offline_rev_id VARCHAR(50) PRIMARY KEY, " +
                "review_id VARCHAR(50) NOT NULL, " +
                "user_id INT NOT NULL, " +
                "vocabulary_id VARCHAR(50) NOT NULL, " +
                "difficulty INT DEFAULT 3, " +
                "review_time TIMESTAMP, " +
                "is_synced BOOLEAN DEFAULT FALSE, " +
                "offline_version INT DEFAULT 1, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_reviews 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_reviews 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/review")
    public ResponseEntity<SyncReviewResponse> syncReview(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SyncReviewRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncReviewResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncReviewResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getReview() == null) {
                return ResponseEntity.badRequest().body(
                        new SyncReviewResponse(false, "复习记录数据不能为空", null)
                );
            }

            ReviewData reviewData = request.getReview();
            if (reviewData.getId() == null || reviewData.getId().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new SyncReviewResponse(false, "复习记录ID不能为空", null)
                );
            }

            // 3. 创建相关表
            createOfflineReviewsTableIfNotExists();

            // 4. 检查复习记录是否存在（假设有reviews表）
            String checkReviewSql = "SELECT review_id FROM reviews WHERE review_id = ?";
            List<Map<String, Object>> reviews = jdbcTemplate.queryForList(checkReviewSql, reviewData.getId());

            if (reviews.isEmpty()) {
                // 复习记录不存在，创建新记录
                String insertReviewSql = "INSERT INTO reviews (review_id, user_id, vocabulary_id, " +
                        "difficulty, review_time, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, NOW())";
                jdbcTemplate.update(insertReviewSql, reviewData.getId(), userId,
                        reviewData.getVocabularyId(), reviewData.getDifficulty(),
                        reviewData.getReviewTime());
            } else {
                // 复习记录存在，更新记录
                String updateReviewSql = "UPDATE reviews SET vocabulary_id = ?, difficulty = ?, " +
                        "review_time = ?, updated_at = NOW() " +
                        "WHERE review_id = ? AND user_id = ?";
                jdbcTemplate.update(updateReviewSql, reviewData.getVocabularyId(),
                        reviewData.getDifficulty(), reviewData.getReviewTime(),
                        reviewData.getId(), userId);
            }

            // 5. 检查是否已有离线复习记录
            String checkOfflineSql = "SELECT offline_rev_id, offline_version FROM offline_reviews " +
                    "WHERE review_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineReviews = jdbcTemplate.queryForList(checkOfflineSql,
                    reviewData.getId(), userId);

            if (offlineReviews.isEmpty()) {
                // 创建离线复习记录
                String offlineRevId = "offline_rev_" + UUID.randomUUID().toString();
                String insertOfflineSql = "INSERT INTO offline_reviews (offline_rev_id, review_id, user_id, " +
                        "vocabulary_id, difficulty, review_time, is_synced, offline_version, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, ?, TRUE, ?, NOW())";
                jdbcTemplate.update(insertOfflineSql, offlineRevId, reviewData.getId(), userId,
                        reviewData.getVocabularyId(), reviewData.getDifficulty(),
                        reviewData.getReviewTime(), reviewData.getOfflineVersion());
            } else {
                // 更新离线复习记录
                Map<String, Object> offlineReview = offlineReviews.get(0);
                int currentVersion = offlineReview.get("offline_version") != null ?
                        ((Number) offlineReview.get("offline_version")).intValue() : 0;

                if (reviewData.getOfflineVersion() > currentVersion) {
                    // 离线版本较新，更新服务器数据
                    String updateOfflineSql = "UPDATE offline_reviews SET vocabulary_id = ?, difficulty = ?, " +
                            "review_time = ?, is_synced = TRUE, offline_version = ?, updated_at = NOW() " +
                            "WHERE review_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateOfflineSql, reviewData.getVocabularyId(),
                            reviewData.getDifficulty(), reviewData.getReviewTime(),
                            reviewData.getOfflineVersion(), reviewData.getId(), userId);
                } else {
                    // 服务器版本较新或相同，标记为已同步
                    String updateSyncSql = "UPDATE offline_reviews SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE review_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateSyncSql, reviewData.getId(), userId);
                }
            }

            // 6. 准备响应数据
            SyncReviewData data = new SyncReviewData(
                    reviewData.getId(),
                    true,
                    "刚刚同步",
                    reviewData.getOfflineVersion()
            );

            SyncReviewResponse response = new SyncReviewResponse(true, "复习记录同步成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("同步复习记录过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncReviewResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineSyncReview.java ---

--- 开始文件: OfflineSyncVocabulary.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineSyncVocabulary {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到同步词汇数据请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class SyncVocabularyRequest {
        private VocabularyData vocabulary;

        public VocabularyData getVocabulary() { return vocabulary; }
        public void setVocabulary(VocabularyData vocabulary) { this.vocabulary = vocabulary; }
    }

    public static class VocabularyData {
        private String id;
        private String word;
        private String translation;
        private String updatedAt;
        private int offlineVersion;

        // Getters and Setters
        public String getId() { return id; }
        public void setId(String id) { this.id = id; }

        public String getWord() { return word; }
        public void setWord(String word) { this.word = word; }

        public String getTranslation() { return translation; }
        public void setTranslation(String translation) { this.translation = translation; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 响应DTO
    public static class SyncVocabularyResponse {
        private boolean success;
        private String message;
        private SyncVocabularyData data;

        public SyncVocabularyResponse(boolean success, String message, SyncVocabularyData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public SyncVocabularyData getData() { return data; }
        public void setData(SyncVocabularyData data) { this.data = data; }
    }

    public static class SyncVocabularyData {
        private String vocabularyId;
        private boolean synced;
        private String syncedAt;
        private int offlineVersion;

        public SyncVocabularyData(String vocabularyId, boolean synced, String syncedAt, int offlineVersion) {
            this.vocabularyId = vocabularyId;
            this.synced = synced;
            this.syncedAt = syncedAt;
            this.offlineVersion = offlineVersion;
        }

        // Getters and Setters
        public String getVocabularyId() { return vocabularyId; }
        public void setVocabularyId(String vocabularyId) { this.vocabularyId = vocabularyId; }

        public boolean isSynced() { return synced; }
        public void setSynced(boolean synced) { this.synced = synced; }

        public String getSyncedAt() { return syncedAt; }
        public void setSyncedAt(String syncedAt) { this.syncedAt = syncedAt; }

        public int getOfflineVersion() { return offlineVersion; }
        public void setOfflineVersion(int offlineVersion) { this.offlineVersion = offlineVersion; }
    }

    // 创建 offline_vocabulary 表（如果不存在）
    private void createOfflineVocabularyTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS offline_vocabulary (" +
                "offline_voc_id VARCHAR(50) PRIMARY KEY, " +
                "vocabulary_id VARCHAR(50) NOT NULL, " +
                "user_id INT NOT NULL, " +
                "word VARCHAR(200) NOT NULL, " +
                "translation TEXT, " +
                "is_synced BOOLEAN DEFAULT FALSE, " +
                "offline_version INT DEFAULT 1, " +
                "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, " +
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, " +
                "FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE" +
                ")";

        try {
            jdbcTemplate.execute(sql);
            System.out.println("offline_vocabulary 表已创建或已存在");
        } catch (Exception e) {
            System.err.println("创建 offline_vocabulary 表失败: " + e.getMessage());
        }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PostMapping("/sync/vocabulary")
    public ResponseEntity<SyncVocabularyResponse> syncVocabulary(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody SyncVocabularyRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncVocabularyResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new SyncVocabularyResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getVocabulary() == null) {
                return ResponseEntity.badRequest().body(
                        new SyncVocabularyResponse(false, "词汇数据不能为空", null)
                );
            }

            VocabularyData vocabularyData = request.getVocabulary();
            if (vocabularyData.getId() == null || vocabularyData.getId().trim().isEmpty()) {
                return ResponseEntity.badRequest().body(
                        new SyncVocabularyResponse(false, "词汇ID不能为空", null)
                );
            }

            // 3. 创建相关表
            createOfflineVocabularyTableIfNotExists();

            // 4. 检查词汇是否存在（假设有vocabulary表）
            String checkVocabSql = "SELECT vocabulary_id FROM vocabulary WHERE vocabulary_id = ?";
            List<Map<String, Object>> vocabularies = jdbcTemplate.queryForList(checkVocabSql, vocabularyData.getId());

            if (vocabularies.isEmpty()) {
                // 词汇不存在，创建新词汇
                String insertVocabSql = "INSERT INTO vocabulary (vocabulary_id, user_id, word, translation, created_at) " +
                        "VALUES (?, ?, ?, ?, NOW())";
                jdbcTemplate.update(insertVocabSql, vocabularyData.getId(), userId,
                        vocabularyData.getWord(), vocabularyData.getTranslation());
            } else {
                // 词汇存在，更新词汇
                String updateVocabSql = "UPDATE vocabulary SET word = ?, translation = ?, updated_at = NOW() " +
                        "WHERE vocabulary_id = ? AND user_id = ?";
                jdbcTemplate.update(updateVocabSql, vocabularyData.getWord(),
                        vocabularyData.getTranslation(), vocabularyData.getId(), userId);
            }

            // 5. 检查是否已有离线词汇记录
            String checkOfflineSql = "SELECT offline_voc_id, offline_version FROM offline_vocabulary " +
                    "WHERE vocabulary_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineVocabs = jdbcTemplate.queryForList(checkOfflineSql,
                    vocabularyData.getId(), userId);

            if (offlineVocabs.isEmpty()) {
                // 创建离线词汇记录
                String offlineVocId = "offline_voc_" + UUID.randomUUID().toString();
                String insertOfflineSql = "INSERT INTO offline_vocabulary (offline_voc_id, vocabulary_id, user_id, " +
                        "word, translation, is_synced, offline_version, created_at) " +
                        "VALUES (?, ?, ?, ?, ?, TRUE, ?, NOW())";
                jdbcTemplate.update(insertOfflineSql, offlineVocId, vocabularyData.getId(), userId,
                        vocabularyData.getWord(), vocabularyData.getTranslation(),
                        vocabularyData.getOfflineVersion());
            } else {
                // 更新离线词汇记录
                Map<String, Object> offlineVoc = offlineVocabs.get(0);
                int currentVersion = offlineVoc.get("offline_version") != null ?
                        ((Number) offlineVoc.get("offline_version")).intValue() : 0;

                if (vocabularyData.getOfflineVersion() > currentVersion) {
                    // 离线版本较新，更新服务器数据
                    String updateOfflineSql = "UPDATE offline_vocabulary SET word = ?, translation = ?, " +
                            "is_synced = TRUE, offline_version = ?, updated_at = NOW() " +
                            "WHERE vocabulary_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateOfflineSql, vocabularyData.getWord(),
                            vocabularyData.getTranslation(), vocabularyData.getOfflineVersion(),
                            vocabularyData.getId(), userId);
                } else {
                    // 服务器版本较新或相同，标记为已同步
                    String updateSyncSql = "UPDATE offline_vocabulary SET is_synced = TRUE, updated_at = NOW() " +
                            "WHERE vocabulary_id = ? AND user_id = ?";
                    jdbcTemplate.update(updateSyncSql, vocabularyData.getId(), userId);
                }
            }

            // 6. 准备响应数据
            SyncVocabularyData data = new SyncVocabularyData(
                    vocabularyData.getId(),
                    true,
                    "刚刚同步",
                    vocabularyData.getOfflineVersion()
            );

            SyncVocabularyResponse response = new SyncVocabularyResponse(true, "词汇同步成功", data);
            printResponse(response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            System.err.println("同步词汇数据过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new SyncVocabularyResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineSyncVocabulary.java ---

--- 开始文件: OfflineUpdateDocument.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.databind.ObjectMapper;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineUpdateDocument {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private ObjectMapper objectMapper = new ObjectMapper();

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到更新离线文档信息请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("=============================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class UpdateDocumentRequest {
        private UpdateData data;

        public UpdateData getData() { return data; }
        public void setData(UpdateData data) { this.data = data; }
    }

    public static class UpdateData {
        private String title;
        private String description;
        private String[] tags;

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public String[] getTags() { return tags; }
        public void setTags(String[] tags) { this.tags = tags; }
    }

    // 响应DTO
    public static class UpdateDocumentResponse {
        private boolean success;
        private String message;
        private UpdateDocumentData data;

        public UpdateDocumentResponse(boolean success, String message, UpdateDocumentData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public UpdateDocumentData getData() { return data; }
        public void setData(UpdateDocumentData data) { this.data = data; }
    }

    public static class UpdateDocumentData {
        private String offlineDocId;
        private String title;
        private String description;
        private String[] tags;
        private boolean isSynced;
        private String updatedAt;

        public UpdateDocumentData(String offlineDocId, String title, String description,
                                  String[] tags, boolean isSynced, String updatedAt) {
            this.offlineDocId = offlineDocId;
            this.title = title;
            this.description = description;
            this.tags = tags;
            this.isSynced = isSynced;
            this.updatedAt = updatedAt;
        }

        public String getOfflineDocId() { return offlineDocId; }
        public void setOfflineDocId(String offlineDocId) { this.offlineDocId = offlineDocId; }

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }

        public String[] getTags() { return tags; }
        public void setTags(String[] tags) { this.tags = tags; }

        public boolean isSynced() { return isSynced; }
        public void setSynced(boolean synced) { isSynced = synced; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PutMapping("/documents/{offlineDocId}")
    public ResponseEntity<UpdateDocumentResponse> updateOfflineDocument(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @PathVariable String offlineDocId,
            @RequestBody UpdateDocumentRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("offlineDocId", offlineDocId);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new UpdateDocumentResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new UpdateDocumentResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null || request.getData() == null) {
                return ResponseEntity.badRequest().body(
                        new UpdateDocumentResponse(false, "请求数据不能为空", null)
                );
            }

            UpdateData updateData = request.getData();

            // 3. 检查离线文档是否存在且属于该用户
            String checkSql = "SELECT offline_doc_id FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
            List<Map<String, Object>> offlineDocs = jdbcTemplate.queryForList(checkSql, offlineDocId, userId);

            if (offlineDocs.isEmpty()) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                        new UpdateDocumentResponse(false, "离线文档不存在或无权更新", null)
                );
            }

            // 4. 构建更新SQL
            StringBuilder updateSql = new StringBuilder("UPDATE offline_documents SET ");
            List<Object> params = new ArrayList<>();

            if (updateData.getTitle() != null && !updateData.getTitle().trim().isEmpty()) {
                updateSql.append("title = ?, ");
                params.add(updateData.getTitle());
            }

            if (updateData.getDescription() != null) {
                updateSql.append("description = ?, ");
                params.add(updateData.getDescription());
            }

            if (updateData.getTags() != null) {
                updateSql.append("tags = ?, ");
                try {
                    String tagsJson = objectMapper.writeValueAsString(updateData.getTags());
                    params.add(tagsJson);
                } catch (Exception e) {
                    params.add("[]");
                }
            }

            // 标记为未同步（因为内容已更新）
            updateSql.append("is_synced = FALSE, ");

            // 增加版本号
            updateSql.append("offline_version = offline_version + 1, ");

            // 更新时间
            updateSql.append("updated_at = NOW() ");

            updateSql.append("WHERE offline_doc_id = ? AND user_id = ?");
            params.add(offlineDocId);
            params.add(userId);

            // 5. 执行更新
            int rowsAffected = jdbcTemplate.update(updateSql.toString(), params.toArray());
            printQueryResult("更新行数: " + rowsAffected);

            if (rowsAffected > 0) {
                // 6. 查询更新后的数据
                String querySql = "SELECT offline_doc_id, title, description, tags, is_synced, updated_at " +
                        "FROM offline_documents WHERE offline_doc_id = ? AND user_id = ?";
                List<Map<String, Object>> updatedDocs = jdbcTemplate.queryForList(querySql, offlineDocId, userId);

                if (!updatedDocs.isEmpty()) {
                    Map<String, Object> row = updatedDocs.get(0);

                    // 解析tags
                    String[] tagsArray = new String[0];
                    String tagsJson = (String) row.get("tags");
                    if (tagsJson != null && !tagsJson.isEmpty()) {
                        try {
                            tagsArray = objectMapper.readValue(tagsJson, String[].class);
                        } catch (Exception e) {
                            tagsArray = new String[0];
                        }
                    }

                    // 7. 准备响应数据
                    UpdateDocumentData data = new UpdateDocumentData(
                            (String) row.get("offline_doc_id"),
                            (String) row.get("title"),
                            (String) row.get("description"),
                            tagsArray,
                            row.get("is_synced") != null && (Boolean) row.get("is_synced"),
                            row.get("updated_at").toString()
                    );

                    UpdateDocumentResponse response = new UpdateDocumentResponse(true, "离线文档更新成功", data);
                    printResponse(response);

                    return ResponseEntity.ok(response);
                }
            }

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new UpdateDocumentResponse(false, "更新失败", null)
            );

        } catch (Exception e) {
            System.err.println("更新离线文档信息过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new UpdateDocumentResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineUpdateDocument.java ---

--- 开始文件: OfflineUpdateSettings.java ---

package com.vue.readingapp.offline;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/v1/offline")
public class OfflineUpdateSettings {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 打印接收到的请求
    private void printRequest(Object request) {
        System.out.println("=== 收到更新离线设置请求 ===");
        System.out.println("请求数据: " + request);
        System.out.println("==========================");
    }

    // 打印查询结果
    private void printQueryResult(Object result) {
        System.out.println("=== 数据库查询结果 ===");
        System.out.println("查询结果: " + result);
        System.out.println("===================");
    }

    // 打印返回数据
    private void printResponse(Object response) {
        System.out.println("=== 准备返回的响应 ===");
        System.out.println("响应数据: " + response);
        System.out.println("===================");
    }

    // 请求DTO
    public static class UpdateSettingsRequest {
        private boolean offlineMode;
        private boolean autoSync;
        private int syncInterval;
        private int storageLimit;
        private boolean wifiOnly;

        // Getters and Setters
        public boolean isOfflineMode() { return offlineMode; }
        public void setOfflineMode(boolean offlineMode) { this.offlineMode = offlineMode; }

        public boolean isAutoSync() { return autoSync; }
        public void setAutoSync(boolean autoSync) { this.autoSync = autoSync; }

        public int getSyncInterval() { return syncInterval; }
        public void setSyncInterval(int syncInterval) { this.syncInterval = syncInterval; }

        public int getStorageLimit() { return storageLimit; }
        public void setStorageLimit(int storageLimit) { this.storageLimit = storageLimit; }

        public boolean isWifiOnly() { return wifiOnly; }
        public void setWifiOnly(boolean wifiOnly) { this.wifiOnly = wifiOnly; }
    }

    // 响应DTO
    public static class UpdateSettingsResponse {
        private boolean success;
        private String message;
        private UpdateSettingsData data;

        public UpdateSettingsResponse(boolean success, String message, UpdateSettingsData data) {
            this.success = success;
            this.message = message;
            this.data = data;
        }

        public boolean isSuccess() { return success; }
        public void setSuccess(boolean success) { this.success = success; }

        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }

        public UpdateSettingsData getData() { return data; }
        public void setData(UpdateSettingsData data) { this.data = data; }
    }

    public static class UpdateSettingsData {
        private boolean offlineMode;
        private boolean autoSync;
        private int syncInterval;
        private int storageLimit;
        private boolean wifiOnly;
        private String updatedAt;

        public UpdateSettingsData(boolean offlineMode, boolean autoSync, int syncInterval,
                                  int storageLimit, boolean wifiOnly, String updatedAt) {
            this.offlineMode = offlineMode;
            this.autoSync = autoSync;
            this.syncInterval = syncInterval;
            this.storageLimit = storageLimit;
            this.wifiOnly = wifiOnly;
            this.updatedAt = updatedAt;
        }

        // Getters and Setters
        public boolean isOfflineMode() { return offlineMode; }
        public void setOfflineMode(boolean offlineMode) { this.offlineMode = offlineMode; }

        public boolean isAutoSync() { return autoSync; }
        public void setAutoSync(boolean autoSync) { this.autoSync = autoSync; }

        public int getSyncInterval() { return syncInterval; }
        public void setSyncInterval(int syncInterval) { this.syncInterval = syncInterval; }

        public int getStorageLimit() { return storageLimit; }
        public void setStorageLimit(int storageLimit) { this.storageLimit = storageLimit; }

        public boolean isWifiOnly() { return wifiOnly; }
        public void setWifiOnly(boolean wifiOnly) { this.wifiOnly = wifiOnly; }

        public String getUpdatedAt() { return updatedAt; }
        public void setUpdatedAt(String updatedAt) { this.updatedAt = updatedAt; }
    }

    // 验证用户token
    private Integer validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return null;
        }

        try {
            String sql = "SELECT user_id FROM user_sessions WHERE access_token = ? AND expires_at > NOW()";
            List<Map<String, Object>> sessions = jdbcTemplate.queryForList(sql, token);

            if (sessions.isEmpty()) {
                return null;
            }

            return (Integer) sessions.get(0).get("user_id");
        } catch (Exception e) {
            System.err.println("验证token失败: " + e.getMessage());
            return null;
        }
    }

    @PutMapping("/settings")
    public ResponseEntity<UpdateSettingsResponse> updateOfflineSettings(
            @RequestHeader(value = "Authorization", required = false) String authHeader,
            @RequestBody UpdateSettingsRequest request) {

        // 打印接收到的请求
        Map<String, Object> requestInfo = new HashMap<>();
        requestInfo.put("authHeader", authHeader);
        requestInfo.put("requestBody", request);
        printRequest(requestInfo);

        try {
            // 1. 验证用户认证
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new UpdateSettingsResponse(false, "请先登录", null)
                );
            }

            String token = authHeader.substring(7);
            Integer userId = validateToken(token);

            if (userId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                        new UpdateSettingsResponse(false, "登录已过期，请重新登录", null)
                );
            }

            // 2. 验证请求数据
            if (request == null) {
                return ResponseEntity.badRequest().body(
                        new UpdateSettingsResponse(false, "请求数据不能为空", null)
                );
            }

            // 验证同步间隔
            if (request.getSyncInterval() < 1 || request.getSyncInterval() > 1440) {
                return ResponseEntity.badRequest().body(
                        new UpdateSettingsResponse(false, "同步间隔必须在1-1440分钟之间", null)
                );
            }

            // 验证存储限制
            if (request.getStorageLimit() < 1 || request.getStorageLimit() > 10240) {
                return ResponseEntity.badRequest().body(
                        new UpdateSettingsResponse(false, "存储限制必须在1-10240MB之间", null)
                );
            }

            // 3. 更新或插入设置
            String[] settingKeys = {"offlineMode", "autoSync", "syncInterval", "storageLimit", "wifiOnly"};
            String[] settingValues = {
                    String.valueOf(request.isOfflineMode()),
                    String.valueOf(request.isAutoSync()),
                    String.valueOf(request.getSyncInterval()),
                    String.valueOf(request.getStorageLimit()),
                    String.valueOf(request.isWifiOnly())
            };

            int totalRowsAffected = 0;

            for (int i = 0; i < settingKeys.length; i++) {
                // 检查是否已有设置
                String checkSql = "SELECT setting_key FROM offline_settings WHERE user_id = ? AND setting_key = ?";
                List<Map<String, Object>> existing = jdbcTemplate.queryForList(checkSql, userId, settingKeys[i]);

                int rowsAffected;
                if (existing.isEmpty()) {
                    // 插入新设置
                    String insertSql = "INSERT INTO offline_settings (user_id, setting_key, setting_value) VALUES (?, ?, ?)";
                    rowsAffected = jdbcTemplate.update(insertSql, userId, settingKeys[i], settingValues[i]);
                } else {
                    // 更新现有设置
                    String updateSql = "UPDATE offline_settings SET setting_value = ?, updated_at = NOW() " +
                            "WHERE user_id = ? AND setting_key = ?";
                    rowsAffected = jdbcTemplate.update(updateSql, settingValues[i], userId, settingKeys[i]);
                }

                totalRowsAffected += rowsAffected;
            }

            printQueryResult("更新行数: " + totalRowsAffected);

            if (totalRowsAffected > 0) {
                // 4. 查询更新后的设置
                String querySql = "SELECT setting_key, setting_value, updated_at FROM offline_settings " +
                        "WHERE user_id = ? AND setting_key IN ('offlineMode', 'autoSync', 'syncInterval', 'storageLimit', 'wifiOnly') " +
                        "ORDER BY updated_at DESC LIMIT 1";

                List<Map<String, Object>> updatedSettings = jdbcTemplate.queryForList(querySql, userId);

                String updatedAt = "刚刚更新";
                if (!updatedSettings.isEmpty()) {
                    updatedAt = updatedSettings.get(0).get("updated_at").toString();
                }

                // 5. 准备响应数据
                UpdateSettingsData data = new UpdateSettingsData(
                        request.isOfflineMode(),
                        request.isAutoSync(),
                        request.getSyncInterval(),
                        request.getStorageLimit(),
                        request.isWifiOnly(),
                        updatedAt
                );

                UpdateSettingsResponse response = new UpdateSettingsResponse(true, "离线设置更新成功", data);
                printResponse(response);

                return ResponseEntity.ok(response);
            }

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new UpdateSettingsResponse(false, "更新失败", null)
            );

        } catch (Exception e) {
            System.err.println("更新离线设置过程中发生错误: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new UpdateSettingsResponse(false, "服务器内部错误: " + e.getMessage(), null)
            );
        }
    }
}
--- 结束文件: OfflineUpdateSettings.java ---

